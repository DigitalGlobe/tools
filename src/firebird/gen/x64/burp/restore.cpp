/*********** Preprocessed module -- do not edit ***************/
/*********** Preprocessed module -- do not edit ***************/
/*********** Preprocessed module -- do not edit ***************/
/*********** Preprocessed module -- do not edit ***************/
/*********** Preprocessed module -- do not edit ***************/
/***************** gpre version WI-V2.5.7.27050 Firebird 2.5 **********************/
/*
 *	PROGRAM:	JRD Backup and Restore Program
 *	MODULE:		restore.epp
 *	DESCRIPTION:	Restore routine
 *
 * The contents of this file are subject to the Interbase Public
 * License Version 1.0 (the "License"); you may not use this file
 * except in compliance with the License. You may obtain a copy
 * of the License at http://www.Inprise.com/IPL.html
 *
 * Software distributed under the License is distributed on an
 * "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * rights and limitations under the License.
 *
 * The Original Code was created by Inprise Corporation
 * and its predecessors. Portions created by Inprise Corporation are
 * Copyright (C) Inprise Corporation.
 *
 * All Rights Reserved.
 * Contributor(s): ______________________________________.
 * Toni Martir: Verbose records restored as RESTORE_VERBOSE_INTERVAL,
 * also verbose restoring indexes as DEFERRED when verbose
 * 2003.08.17 Claudio Valderrama: Fix SF Bug #750659.
 * Adriano dos Santos Fernandes
 *
 */

#include "firebird.h"
#include <stdio.h>
#include <string.h>
#include <errno.h>
#include "../burp/burp.h"
#include "../jrd/align.h"
#include "../jrd/common.h"
#include "../jrd/flags.h"
#include "../jrd/license.h"
#include "../jrd/obj.h"
#include "../jrd/ods.h"
#include "../common/stuff.h"
#include "../burp/burp_proto.h"
#include "../burp/canon_proto.h"
#include "../burp/misc_proto.h"
#include "../burp/mvol_proto.h"
#include "../burp/resto_proto.h"
#include "../jrd/gdsassert.h"
#include "../jrd/constants.h"
#include "../remote/protocol.h"
#ifdef DEBUG
#include "../gpre/prett_proto.h"
#endif
#include "../common/classes/ClumpletWriter.h"
#include "../common/classes/UserBlob.h"
#include "../common/classes/SafeArg.h"
#include "memory_routines.h"

using MsgFormat::SafeArg;


//  For service APIs the follow DB handle is a value stored
//  in thread data.  This is also done for other statics generated by
//  GPRE.  This is to avoid multiple threading problems with module
//  level statics.

/*DATABASE DB = STATIC FILENAME "yachts.lnk";*/
/**** GDS Preprocessor Definitions ****/
#ifndef JRD_IBASE_H
#include <ibase.h>
#endif

static const ISC_QUAD
   isc_blob_null = {0, 0};	/* initializer for blobs */
static isc_db_handle
   DB = 0;		/* database handle */

static isc_tr_handle
   gds_trans = 0;		/* default transaction handle */
static ISC_STATUS
   isc_status [20],	/* status vector */
   isc_status2 [20];	/* status vector */
static ISC_LONG
   isc_array_length, 	/* array return size */
   SQLCODE;		/* SQL status code */
static const char
   isc_tpb_27 [4] = {1,9,2,6};

static const char
   isc_tpb_26 [5] = {1,9,2,6,20};

static const char
   isc_tpb_25 [4] = {1,9,2,6};

static const char
   isc_tpb_24 [5] = {1,9,2,6,20};

static const char
   isc_tpb_23 [5] = {1,9,15,6,18};

static const char
   isc_tpb_22 [4] = {1,9,2,6};

static const char
   isc_tpb_21 [5] = {1,9,2,6,20};

static const char
   isc_tpb_20 [4] = {1,9,2,6};

static const char
   isc_tpb_19 [5] = {1,9,2,6,20};

static const char
   isc_tpb_18 [4] = {1,9,2,6};

static const char
   isc_tpb_17 [5] = {1,9,2,6,20};

static const char
   isc_tpb_16 [4] = {1,9,2,6};

static const char
   isc_tpb_15 [5] = {1,9,2,6,20};

static const char
   isc_tpb_14 [4] = {1,9,2,6};

static const char
   isc_tpb_13 [5] = {1,9,2,6,20};

static const char
   isc_tpb_12 [4] = {1,9,2,6};

static const char
   isc_tpb_11 [5] = {1,9,2,6,20};

static const char
   isc_tpb_10 [4] = {1,9,2,6};

static const char
   isc_tpb_9 [5] = {1,9,2,6,20};

static const char
   isc_tpb_8 [4] = {1,9,2,6};

static const char
   isc_tpb_7 [5] = {1,9,2,6,20};

static const char
   isc_tpb_6 [4] = {1,9,2,6};

static const char
   isc_tpb_5 [6] = {1,9,15,6,18,20};

static const char
   isc_tpb_4 [4] = {1,9,2,6};

static const char
   isc_tpb_3 [4] = {1,9,2,6};

static const char
   isc_tpb_2 [6] = {1,9,15,6,18,20};

static const char
   isc_tpb_1 [4] = {1,9,2,6};

static const char
   isc_tpb_0 [6] = {1,9,15,6,18,20};

static const short
   isc_28l = 238;
static const char
   isc_28 [] = {
   4,2,4,2,1,0,7,0,4,1,1,0,7,0,4,0,3,0,41,3,0,32,0,7,0,7,0,2,7,
   'C',1,'J',13,'R','D','B','$','R','E','L','A','T','I','O','N',
   'S',0,'G',58,59,61,23,0,12,'R','D','B','$','V','I','E','W','_',
   'B','L','R',57,48,23,0,15,'R','D','B','$','S','Y','S','T','E',
   'M','_','F','L','A','G',21,8,0,1,0,0,0,61,23,0,15,'R','D','B',
   '$','S','Y','S','T','E','M','_','F','L','A','G',-1,2,14,0,2,
   1,23,0,17,'R','D','B','$','R','E','L','A','T','I','O','N','_',
   'N','A','M','E',25,0,0,0,1,21,8,0,1,0,0,0,25,0,1,0,1,23,0,16,
   'R','D','B','$','D','B','K','E','Y','_','L','E','N','G','T',
   'H',25,0,2,0,-1,17,0,9,13,12,2,18,0,12,1,11,10,0,1,2,1,25,1,
   0,0,23,1,16,'R','D','B','$','D','B','K','E','Y','_','L','E',
   'N','G','T','H',-1,-1,-1,14,0,1,21,8,0,0,0,0,0,25,0,1,0,-1,-1,
   'L'
   };	/* end of blr string for request isc_28 */

static const short
   isc_37l = 382;
static const char
   isc_37 [] = {
   4,2,4,3,1,0,7,0,4,2,8,0,9,0,9,0,9,0,9,0,7,0,7,0,7,0,7,0,4,1,
   9,0,9,0,9,0,9,0,9,0,7,0,7,0,7,0,7,0,7,0,4,0,1,0,41,3,0,32,0,
   12,0,2,7,'C',1,'J',10,'R','D','B','$','F','I','E','L','D','S',
   0,'G',47,23,0,14,'R','D','B','$','F','I','E','L','D','_','N',
   'A','M','E',25,0,0,0,-1,2,14,1,2,1,23,0,19,'R','D','B','$','C',
   'O','M','P','U','T','E','D','_','S','O','U','R','C','E',41,1,
   0,0,5,0,1,23,0,16,'R','D','B','$','C','O','M','P','U','T','E',
   'D','_','B','L','R',41,1,1,0,6,0,1,23,0,21,'R','D','B','$','V',
   'A','L','I','D','A','T','I','O','N','_','S','O','U','R','C',
   'E',41,1,2,0,7,0,1,23,0,18,'R','D','B','$','V','A','L','I','D',
   'A','T','I','O','N','_','B','L','R',41,1,3,0,8,0,1,21,8,0,1,
   0,0,0,25,1,4,0,-1,17,0,9,13,12,3,18,0,12,2,11,10,0,1,2,1,41,
   2,3,0,7,0,23,1,19,'R','D','B','$','C','O','M','P','U','T','E',
   'D','_','S','O','U','R','C','E',1,41,2,2,0,6,0,23,1,16,'R','D',
   'B','$','C','O','M','P','U','T','E','D','_','B','L','R',1,41,
   2,1,0,5,0,23,1,21,'R','D','B','$','V','A','L','I','D','A','T',
   'I','O','N','_','S','O','U','R','C','E',1,41,2,0,0,4,0,23,1,
   18,'R','D','B','$','V','A','L','I','D','A','T','I','O','N','_',
   'B','L','R',-1,-1,-1,14,1,1,21,8,0,0,0,0,0,25,1,4,0,-1,-1,'L'
   
   };	/* end of blr string for request isc_37 */

static const short
   isc_61l = 90;
static const char
   isc_61 [] = {
   4,2,4,0,3,0,41,3,0,32,0,7,0,7,0,12,0,15,'J',14,'R','D','B','$',
   'G','E','N','E','R','A','T','O','R','S',0,2,1,41,0,2,0,1,0,23,
   0,15,'R','D','B','$','S','Y','S','T','E','M','_','F','L','A',
   'G',1,25,0,0,0,23,0,18,'R','D','B','$','G','E','N','E','R','A',
   'T','O','R','_','N','A','M','E',-1,-1,'L'
   };	/* end of blr string for request isc_61 */

static const short
   isc_66l = 119;
static const char
   isc_66 [] = {
   4,2,4,0,5,0,9,0,41,3,0,32,0,7,0,7,0,7,0,12,0,15,'J',14,'R','D',
   'B','$','G','E','N','E','R','A','T','O','R','S',0,2,1,41,0,3,
   0,2,0,23,0,15,'R','D','B','$','S','Y','S','T','E','M','_','F',
   'L','A','G',1,41,0,0,0,4,0,23,0,15,'R','D','B','$','D','E','S',
   'C','R','I','P','T','I','O','N',1,25,0,1,0,23,0,18,'R','D','B',
   '$','G','E','N','E','R','A','T','O','R','_','N','A','M','E',
   -1,-1,'L'
   };	/* end of blr string for request isc_66 */

static const short
   isc_73l = 214;
static const char
   isc_73 [] = {
   4,2,4,1,4,0,41,3,0,32,0,9,0,7,0,7,0,4,0,1,0,41,3,0,32,0,12,0,
   2,7,'C',2,'J',18,'R','D','B','$','V','I','E','W','_','R','E',
   'L','A','T','I','O','N','S',0,'J',13,'R','D','B','$','R','E',
   'L','A','T','I','O','N','S',1,'G',58,47,23,0,13,'R','D','B',
   '$','V','I','E','W','_','N','A','M','E',25,0,0,0,47,23,1,17,
   'R','D','B','$','R','E','L','A','T','I','O','N','_','N','A',
   'M','E',23,0,17,'R','D','B','$','R','E','L','A','T','I','O',
   'N','_','N','A','M','E',-1,14,1,2,1,23,0,17,'R','D','B','$',
   'R','E','L','A','T','I','O','N','_','N','A','M','E',25,1,0,0,
   1,23,1,12,'R','D','B','$','V','I','E','W','_','B','L','R',41,
   1,1,0,3,0,1,21,8,0,1,0,0,0,25,1,2,0,-1,14,1,1,21,8,0,0,0,0,0,
   25,1,2,0,-1,-1,'L'
   };	/* end of blr string for request isc_73 */

static const short
   isc_81l = 170;
static const char
   isc_81 [] = {
   4,2,4,3,1,0,7,0,4,2,1,0,9,0,4,1,2,0,9,0,7,0,4,0,1,0,41,3,0,32,
   0,12,0,2,7,'C',1,'J',20,'R','D','B','$','S','E','C','U','R',
   'I','T','Y','_','C','L','A','S','S','E','S',0,'G',47,23,0,18,
   'R','D','B','$','S','E','C','U','R','I','T','Y','_','C','L',
   'A','S','S',25,0,0,0,-1,2,14,1,2,1,23,0,7,'R','D','B','$','A',
   'C','L',25,1,0,0,1,21,8,0,1,0,0,0,25,1,1,0,-1,17,0,9,13,12,3,
   18,0,12,2,11,10,0,1,2,1,25,2,0,0,23,1,7,'R','D','B','$','A',
   'C','L',-1,-1,-1,14,1,1,21,8,0,0,0,0,0,25,1,1,0,-1,-1,'L'
   };	/* end of blr string for request isc_81 */

static const short
   isc_91l = 170;
static const char
   isc_91 [] = {
   4,2,4,2,1,0,7,0,4,1,2,0,27,7,0,4,0,3,0,27,7,0,7,0,2,7,'C',1,
   'J',11,'R','D','B','$','I','N','D','I','C','E','S',0,'G',47,
   23,0,15,'R','D','B','$','S','Y','S','T','E','M','_','F','L',
   'A','G',21,8,0,1,0,0,0,-1,2,14,0,2,1,23,0,14,'R','D','B','$',
   'S','T','A','T','I','S','T','I','C','S',41,0,0,0,2,0,1,21,8,
   0,1,0,0,0,25,0,1,0,-1,17,0,9,13,12,2,18,0,12,1,11,10,0,1,2,1,
   41,1,0,0,1,0,23,1,14,'R','D','B','$','S','T','A','T','I','S',
   'T','I','C','S',-1,-1,-1,14,0,1,21,8,0,0,0,0,0,25,0,1,0,-1,-1,
   'L'
   };	/* end of blr string for request isc_91 */

static const short
   isc_101l = 138;
static const char
   isc_101 [] = {
   4,2,4,2,1,0,7,0,4,1,1,0,7,0,4,0,1,0,7,0,2,7,'C',1,'J',9,'R',
   'D','B','$','F','I','L','E','S',0,'G',58,59,61,23,0,17,'R','D',
   'B','$','S','H','A','D','O','W','_','N','U','M','B','E','R',
   48,23,0,17,'R','D','B','$','S','H','A','D','O','W','_','N','U',
   'M','B','E','R',21,8,0,0,0,0,0,-1,2,14,0,2,1,21,8,0,1,0,0,0,
   25,0,0,0,-1,17,0,9,13,12,2,18,0,12,1,11,5,0,-1,-1,14,0,1,21,
   8,0,0,0,0,0,25,0,0,0,-1,-1,'L'
   };	/* end of blr string for request isc_101 */

static const short
   isc_108l = 213;
static const char
   isc_108 [] = {
   4,2,4,2,1,0,7,0,4,1,2,0,41,3,0,32,0,7,0,4,0,4,0,41,3,0,32,0,
   41,3,0,32,0,7,0,7,0,2,7,'C',1,'J',18,'R','D','B','$','C','H',
   'A','R','A','C','T','E','R','_','S','E','T','S',0,-1,2,14,0,
   2,1,23,0,24,'R','D','B','$','D','E','F','A','U','L','T','_',
   'C','O','L','L','A','T','E','_','N','A','M','E',41,0,0,0,3,0,
   1,23,0,22,'R','D','B','$','C','H','A','R','A','C','T','E','R',
   '_','S','E','T','_','N','A','M','E',25,0,1,0,1,21,8,0,1,0,0,
   0,25,0,2,0,-1,17,0,9,13,12,2,18,0,12,1,11,10,0,1,2,1,41,1,0,
   0,1,0,23,1,24,'R','D','B','$','D','E','F','A','U','L','T','_',
   'C','O','L','L','A','T','E','_','N','A','M','E',-1,-1,-1,14,
   0,1,21,8,0,0,0,0,0,25,0,2,0,-1,-1,'L'
   };	/* end of blr string for request isc_108 */

static const short
   isc_119l = 139;
static const char
   isc_119 [] = {
   4,2,4,1,2,0,7,0,7,0,4,0,1,0,41,3,0,32,0,12,0,2,7,'C',1,'J',18,
   'R','D','B','$','C','H','A','R','A','C','T','E','R','_','S',
   'E','T','S',0,'G',47,23,0,22,'R','D','B','$','C','H','A','R',
   'A','C','T','E','R','_','S','E','T','_','N','A','M','E',25,0,
   0,0,-1,14,1,2,1,21,8,0,1,0,0,0,25,1,0,0,1,23,0,20,'R','D','B',
   '$','C','H','A','R','A','C','T','E','R','_','S','E','T','_',
   'I','D',25,1,1,0,-1,14,1,1,21,8,0,0,0,0,0,25,1,0,0,-1,-1,'L'
   
   };	/* end of blr string for request isc_119 */

static const short
   isc_125l = 139;
static const char
   isc_125 [] = {
   4,2,4,1,2,0,7,0,7,0,4,0,1,0,41,3,0,32,0,12,0,2,7,'C',1,'J',18,
   'R','D','B','$','C','H','A','R','A','C','T','E','R','_','S',
   'E','T','S',0,'G',47,23,0,22,'R','D','B','$','C','H','A','R',
   'A','C','T','E','R','_','S','E','T','_','N','A','M','E',25,0,
   0,0,-1,14,1,2,1,21,8,0,1,0,0,0,25,1,0,0,1,23,0,20,'R','D','B',
   '$','C','H','A','R','A','C','T','E','R','_','S','E','T','_',
   'I','D',25,1,1,0,-1,14,1,1,21,8,0,0,0,0,0,25,1,0,0,-1,-1,'L'
   
   };	/* end of blr string for request isc_125 */

static const short
   isc_131l = 160;
static const char
   isc_131 [] = {
   4,2,4,2,1,0,7,0,4,1,1,0,41,3,0,32,0,4,0,2,0,41,3,0,32,0,7,0,
   2,7,'C',1,'J',12,'R','D','B','$','D','A','T','A','B','A','S',
   'E',0,-1,2,14,0,2,1,23,0,22,'R','D','B','$','C','H','A','R',
   'A','C','T','E','R','_','S','E','T','_','N','A','M','E',25,0,
   0,0,1,21,8,0,1,0,0,0,25,0,1,0,-1,17,0,9,13,12,2,18,0,12,1,11,
   10,0,1,2,1,25,1,0,0,23,1,22,'R','D','B','$','C','H','A','R',
   'A','C','T','E','R','_','S','E','T','_','N','A','M','E',-1,-1,
   -1,14,0,1,21,8,0,0,0,0,0,25,0,1,0,-1,-1,'L'
   };	/* end of blr string for request isc_131 */

static const short
   isc_139l = 140;
static const char
   isc_139 [] = {
   4,2,4,2,1,0,7,0,4,1,1,0,9,0,4,0,2,0,9,0,7,0,2,7,'C',1,'J',12,
   'R','D','B','$','D','A','T','A','B','A','S','E',0,-1,2,14,0,
   2,1,23,0,15,'R','D','B','$','D','E','S','C','R','I','P','T',
   'I','O','N',25,0,0,0,1,21,8,0,1,0,0,0,25,0,1,0,-1,17,0,9,13,
   12,2,18,0,12,1,11,10,0,1,2,1,25,1,0,0,23,1,15,'R','D','B','$',
   'D','E','S','C','R','I','P','T','I','O','N',-1,-1,-1,14,0,1,
   21,8,0,0,0,0,0,25,0,1,0,-1,-1,'L'
   };	/* end of blr string for request isc_139 */

static const short
   isc_147l = 145;
static const char
   isc_147 [] = {
   4,2,4,0,4,0,41,3,0,0,1,41,3,0,32,0,41,3,0,32,0,7,0,12,0,15,'J',
   18,'R','D','B','$','V','I','E','W','_','R','E','L','A','T','I',
   'O','N','S',0,2,1,25,0,3,0,23,0,16,'R','D','B','$','V','I','E',
   'W','_','C','O','N','T','E','X','T',1,25,0,0,0,23,0,16,'R','D',
   'B','$','C','O','N','T','E','X','T','_','N','A','M','E',1,25,
   0,1,0,23,0,17,'R','D','B','$','R','E','L','A','T','I','O','N',
   '_','N','A','M','E',1,25,0,2,0,23,0,13,'R','D','B','$','V','I',
   'E','W','_','N','A','M','E',-1,-1,'L'
   };	/* end of blr string for request isc_147 */

static const short
   isc_153l = 253;
static const char
   isc_153 [] = {
   4,2,4,0,12,0,41,3,0,32,0,41,3,0,32,0,41,3,0,32,0,41,3,0,32,0,
   7,0,7,0,7,0,7,0,7,0,7,0,7,0,41,0,0,7,0,12,0,15,'J',19,'R','D',
   'B','$','U','S','E','R','_','P','R','I','V','I','L','E','G',
   'E','S',0,2,1,41,0,5,0,4,0,23,0,13,'R','D','B','$','U','S','E',
   'R','_','T','Y','P','E',1,25,0,0,0,23,0,17,'R','D','B','$','R',
   'E','L','A','T','I','O','N','_','N','A','M','E',1,41,0,7,0,6,
   0,23,0,16,'R','D','B','$','G','R','A','N','T','_','O','P','T',
   'I','O','N',1,25,0,11,0,23,0,13,'R','D','B','$','P','R','I',
   'V','I','L','E','G','E',1,25,0,1,0,23,0,11,'R','D','B','$','G',
   'R','A','N','T','O','R',1,25,0,2,0,23,0,8,'R','D','B','$','U',
   'S','E','R',1,41,0,9,0,8,0,23,0,15,'R','D','B','$','O','B','J',
   'E','C','T','_','T','Y','P','E',1,41,0,3,0,10,0,23,0,14,'R',
   'D','B','$','F','I','E','L','D','_','N','A','M','E',-1,-1,'L'
   
   };	/* end of blr string for request isc_153 */

static const short
   isc_167l = 154;
static const char
   isc_167 [] = {
   4,2,4,0,7,0,41,3,0,32,0,41,3,0,32,0,9,0,7,0,7,0,7,0,7,0,12,0,
   15,'J',9,'R','D','B','$','T','Y','P','E','S',0,2,1,25,0,0,0,
   23,0,14,'R','D','B','$','F','I','E','L','D','_','N','A','M',
   'E',1,25,0,3,0,23,0,8,'R','D','B','$','T','Y','P','E',1,25,0,
   1,0,23,0,13,'R','D','B','$','T','Y','P','E','_','N','A','M',
   'E',1,41,0,5,0,4,0,23,0,15,'R','D','B','$','S','Y','S','T','E',
   'M','_','F','L','A','G',1,41,0,2,0,6,0,23,0,15,'R','D','B','$',
   'D','E','S','C','R','I','P','T','I','O','N',-1,-1,'L'
   };	/* end of blr string for request isc_167 */

static const short
   isc_176l = 117;
static const char
   isc_176 [] = {
   4,2,4,0,3,0,41,0,0,0,4,41,3,0,32,0,7,0,12,0,15,'J',20,'R','D',
   'B','$','T','R','I','G','G','E','R','_','M','E','S','S','A',
   'G','E','S',0,2,1,25,0,0,0,23,0,11,'R','D','B','$','M','E','S',
   'S','A','G','E',1,25,0,2,0,23,0,18,'R','D','B','$','M','E','S',
   'S','A','G','E','_','N','U','M','B','E','R',1,25,0,1,0,23,0,
   16,'R','D','B','$','T','R','I','G','G','E','R','_','N','A','M',
   'E',-1,-1,'L'
   };	/* end of blr string for request isc_176 */

static const short
   isc_181l = 132;
static const char
   isc_181 [] = {
   4,2,4,1,1,0,7,0,4,0,1,0,41,3,0,32,0,12,0,2,7,'C',1,'J',12,'R',
   'D','B','$','T','R','I','G','G','E','R','S',0,'D',21,8,0,1,0,
   0,0,'G',58,47,23,0,15,'R','D','B','$','S','Y','S','T','E','M',
   '_','F','L','A','G',21,8,0,1,0,0,0,47,23,0,16,'R','D','B','$',
   'T','R','I','G','G','E','R','_','N','A','M','E',25,0,0,0,-1,
   14,1,2,1,21,8,0,1,0,0,0,25,1,0,0,-1,14,1,1,21,8,0,0,0,0,0,25,
   1,0,0,-1,-1,'L'
   };	/* end of blr string for request isc_181 */

static const short
   isc_186l = 319;
static const char
   isc_186 [] = {
   4,2,4,0,16,0,41,3,0,32,0,9,0,9,0,9,0,41,3,0,32,0,7,0,7,0,7,0,
   7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,12,0,15,'J',12,'R','D','B','$',
   'T','R','I','G','G','E','R','S',0,2,1,25,0,5,0,23,0,20,'R','D',
   'B','$','T','R','I','G','G','E','R','_','I','N','A','C','T',
   'I','V','E',1,25,0,6,0,23,0,20,'R','D','B','$','T','R','I','G',
   'G','E','R','_','S','E','Q','U','E','N','C','E',1,25,0,0,0,23,
   0,16,'R','D','B','$','T','R','I','G','G','E','R','_','N','A',
   'M','E',1,25,0,7,0,23,0,16,'R','D','B','$','T','R','I','G','G',
   'E','R','_','T','Y','P','E',1,41,0,9,0,8,0,23,0,9,'R','D','B',
   '$','F','L','A','G','S',1,41,0,11,0,10,0,23,0,15,'R','D','B',
   '$','S','Y','S','T','E','M','_','F','L','A','G',1,41,0,1,0,12,
   0,23,0,18,'R','D','B','$','T','R','I','G','G','E','R','_','S',
   'O','U','R','C','E',1,41,0,2,0,13,0,23,0,15,'R','D','B','$',
   'T','R','I','G','G','E','R','_','B','L','R',1,41,0,3,0,14,0,
   23,0,15,'R','D','B','$','D','E','S','C','R','I','P','T','I',
   'O','N',1,41,0,4,0,15,0,23,0,17,'R','D','B','$','R','E','L',
   'A','T','I','O','N','_','N','A','M','E',-1,-1,'L'
   };	/* end of blr string for request isc_186 */

static const short
   isc_204l = 374;
static const char
   isc_204 [] = {
   4,2,4,0,20,0,41,3,0,32,0,9,0,9,0,9,0,9,0,41,3,0,32,0,7,0,7,0,
   7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,12,0,15,'J',
   12,'R','D','B','$','T','R','I','G','G','E','R','S',0,2,1,25,
   0,6,0,23,0,20,'R','D','B','$','T','R','I','G','G','E','R','_',
   'I','N','A','C','T','I','V','E',1,25,0,7,0,23,0,20,'R','D','B',
   '$','T','R','I','G','G','E','R','_','S','E','Q','U','E','N',
   'C','E',1,25,0,0,0,23,0,16,'R','D','B','$','T','R','I','G','G',
   'E','R','_','N','A','M','E',1,25,0,8,0,23,0,16,'R','D','B','$',
   'T','R','I','G','G','E','R','_','T','Y','P','E',1,41,0,1,0,9,
   0,23,0,14,'R','D','B','$','D','E','B','U','G','_','I','N','F',
   'O',1,41,0,11,0,10,0,23,0,13,'R','D','B','$','V','A','L','I',
   'D','_','B','L','R',1,41,0,13,0,12,0,23,0,9,'R','D','B','$',
   'F','L','A','G','S',1,41,0,15,0,14,0,23,0,15,'R','D','B','$',
   'S','Y','S','T','E','M','_','F','L','A','G',1,41,0,2,0,16,0,
   23,0,18,'R','D','B','$','T','R','I','G','G','E','R','_','S',
   'O','U','R','C','E',1,41,0,3,0,17,0,23,0,15,'R','D','B','$',
   'T','R','I','G','G','E','R','_','B','L','R',1,41,0,4,0,18,0,
   23,0,15,'R','D','B','$','D','E','S','C','R','I','P','T','I',
   'O','N',1,41,0,5,0,19,0,23,0,17,'R','D','B','$','R','E','L',
   'A','T','I','O','N','_','N','A','M','E',-1,-1,'L'
   };	/* end of blr string for request isc_204 */

static const short
   isc_226l = 262;
static const char
   isc_226 [] = {
   4,2,4,0,12,0,41,3,0,32,0,41,3,0,32,0,9,0,9,0,9,0,7,0,7,0,7,0,
   7,0,7,0,7,0,7,0,12,0,15,'J',12,'R','D','B','$','T','R','I','G',
   'G','E','R','S',0,2,1,25,0,5,0,23,0,20,'R','D','B','$','T','R',
   'I','G','G','E','R','_','S','E','Q','U','E','N','C','E',1,25,
   0,0,0,23,0,17,'R','D','B','$','R','E','L','A','T','I','O','N',
   '_','N','A','M','E',1,25,0,6,0,23,0,16,'R','D','B','$','T','R',
   'I','G','G','E','R','_','T','Y','P','E',1,25,0,1,0,23,0,16,'R',
   'D','B','$','T','R','I','G','G','E','R','_','N','A','M','E',
   1,41,0,8,0,7,0,23,0,15,'R','D','B','$','S','Y','S','T','E','M',
   '_','F','L','A','G',1,41,0,2,0,9,0,23,0,18,'R','D','B','$','T',
   'R','I','G','G','E','R','_','S','O','U','R','C','E',1,41,0,3,
   0,10,0,23,0,15,'R','D','B','$','T','R','I','G','G','E','R','_',
   'B','L','R',1,41,0,4,0,11,0,23,0,15,'R','D','B','$','D','E',
   'S','C','R','I','P','T','I','O','N',-1,-1,'L'
   };	/* end of blr string for request isc_226 */

static const short
   isc_240l = 113;
static const char
   isc_240 [] = {
   4,2,4,0,4,0,9,0,41,3,0,32,0,9,0,7,0,12,0,15,'J',20,'R','D','B',
   '$','S','E','C','U','R','I','T','Y','_','C','L','A','S','S',
   'E','S',0,2,1,25,0,0,0,23,0,7,'R','D','B','$','A','C','L',1,
   25,0,1,0,23,0,18,'R','D','B','$','S','E','C','U','R','I','T',
   'Y','_','C','L','A','S','S',1,41,0,2,0,3,0,23,0,15,'R','D','B',
   '$','D','E','S','C','R','I','P','T','I','O','N',-1,-1,'L'
   };	/* end of blr string for request isc_240 */

static const short
   isc_246l = 86;
static const char
   isc_246 [] = {
   4,2,4,0,4,0,41,3,0,32,0,41,3,0,32,0,7,0,7,0,12,0,15,'J',9,'R',
   'D','B','$','R','O','L','E','S',0,2,1,41,0,0,0,2,0,23,0,14,'R',
   'D','B','$','O','W','N','E','R','_','N','A','M','E',1,41,0,1,
   0,3,0,23,0,13,'R','D','B','$','R','O','L','E','_','N','A','M',
   'E',-1,-1,'L'
   };	/* end of blr string for request isc_246 */

static const short
   isc_252l = 144;
static const char
   isc_252 [] = {
   4,2,4,0,8,0,9,0,41,3,0,32,0,41,3,0,32,0,7,0,7,0,7,0,7,0,7,0,
   12,0,15,'J',9,'R','D','B','$','R','O','L','E','S',0,2,1,41,0,
   4,0,3,0,23,0,15,'R','D','B','$','S','Y','S','T','E','M','_',
   'F','L','A','G',1,41,0,0,0,5,0,23,0,15,'R','D','B','$','D','E',
   'S','C','R','I','P','T','I','O','N',1,41,0,1,0,6,0,23,0,14,'R',
   'D','B','$','O','W','N','E','R','_','N','A','M','E',1,41,0,2,
   0,7,0,23,0,13,'R','D','B','$','R','O','L','E','_','N','A','M',
   'E',-1,-1,'L'
   };	/* end of blr string for request isc_252 */

static const short
   isc_262l = 247;
static const char
   isc_262 [] = {
   4,2,4,0,12,0,41,3,0,32,0,41,3,0,32,0,41,3,0,32,0,41,0,0,4,0,
   41,0,0,4,0,41,0,0,12,0,7,0,7,0,7,0,7,0,7,0,7,0,12,0,15,'J',24,
   'R','D','B','$','R','E','L','A','T','I','O','N','_','C','O',
   'N','S','T','R','A','I','N','T','S',0,2,1,41,0,0,0,6,0,23,0,
   14,'R','D','B','$','I','N','D','E','X','_','N','A','M','E',1,
   41,0,3,0,7,0,23,0,22,'R','D','B','$','I','N','I','T','I','A',
   'L','L','Y','_','D','E','F','E','R','R','E','D',1,41,0,4,0,8,
   0,23,0,14,'R','D','B','$','D','E','F','E','R','R','A','B','L',
   'E',1,41,0,1,0,9,0,23,0,17,'R','D','B','$','R','E','L','A','T',
   'I','O','N','_','N','A','M','E',1,41,0,5,0,10,0,23,0,19,'R',
   'D','B','$','C','O','N','S','T','R','A','I','N','T','_','T',
   'Y','P','E',1,41,0,2,0,11,0,23,0,19,'R','D','B','$','C','O',
   'N','S','T','R','A','I','N','T','_','N','A','M','E',-1,-1,'L'
   
   };	/* end of blr string for request isc_262 */

static const short
   isc_276l = 327;
static const char
   isc_276 [] = {
   4,2,4,0,19,0,41,3,0,32,0,41,0,0,0,1,9,0,9,0,9,0,9,0,9,0,41,3,
   0,32,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,12,0,15,'J',
   13,'R','D','B','$','R','E','L','A','T','I','O','N','S',0,2,1,
   25,0,0,0,23,0,17,'R','D','B','$','R','E','L','A','T','I','O',
   'N','_','N','A','M','E',1,41,0,1,0,8,0,23,0,17,'R','D','B','$',
   'E','X','T','E','R','N','A','L','_','F','I','L','E',1,41,0,2,
   0,9,0,23,0,24,'R','D','B','$','E','X','T','E','R','N','A','L',
   '_','D','E','S','C','R','I','P','T','I','O','N',1,41,0,3,0,10,
   0,23,0,11,'R','D','B','$','R','U','N','T','I','M','E',1,41,0,
   4,0,11,0,23,0,15,'R','D','B','$','D','E','S','C','R','I','P',
   'T','I','O','N',1,41,0,5,0,12,0,23,0,15,'R','D','B','$','V',
   'I','E','W','_','S','O','U','R','C','E',1,41,0,6,0,13,0,23,0,
   12,'R','D','B','$','V','I','E','W','_','B','L','R',1,41,0,7,
   0,14,0,23,0,18,'R','D','B','$','S','E','C','U','R','I','T','Y',
   '_','C','L','A','S','S',1,41,0,16,0,15,0,23,0,9,'R','D','B',
   '$','F','L','A','G','S',1,41,0,18,0,17,0,23,0,15,'R','D','B',
   '$','S','Y','S','T','E','M','_','F','L','A','G',-1,-1,'L'
   };	/* end of blr string for request isc_276 */

static const short
   isc_297l = 358;
static const char
   isc_297 [] = {
   4,2,4,0,21,0,41,3,0,32,0,41,0,0,0,1,9,0,9,0,9,0,9,0,9,0,41,3,
   0,32,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,12,
   0,15,'J',13,'R','D','B','$','R','E','L','A','T','I','O','N',
   'S',0,2,1,25,0,0,0,23,0,17,'R','D','B','$','R','E','L','A','T',
   'I','O','N','_','N','A','M','E',1,41,0,9,0,8,0,23,0,17,'R','D',
   'B','$','R','E','L','A','T','I','O','N','_','T','Y','P','E',
   1,41,0,1,0,10,0,23,0,17,'R','D','B','$','E','X','T','E','R',
   'N','A','L','_','F','I','L','E',1,41,0,2,0,11,0,23,0,24,'R',
   'D','B','$','E','X','T','E','R','N','A','L','_','D','E','S',
   'C','R','I','P','T','I','O','N',1,41,0,3,0,12,0,23,0,11,'R',
   'D','B','$','R','U','N','T','I','M','E',1,41,0,4,0,13,0,23,0,
   15,'R','D','B','$','D','E','S','C','R','I','P','T','I','O','N',
   1,41,0,5,0,14,0,23,0,15,'R','D','B','$','V','I','E','W','_',
   'S','O','U','R','C','E',1,41,0,6,0,15,0,23,0,12,'R','D','B',
   '$','V','I','E','W','_','B','L','R',1,41,0,7,0,16,0,23,0,18,
   'R','D','B','$','S','E','C','U','R','I','T','Y','_','C','L',
   'A','S','S',1,41,0,18,0,17,0,23,0,9,'R','D','B','$','F','L',
   'A','G','S',1,41,0,20,0,19,0,23,0,15,'R','D','B','$','S','Y',
   'S','T','E','M','_','F','L','A','G',-1,-1,'L'
   };	/* end of blr string for request isc_297 */

static const short
   isc_320l = 202;
static const char
   isc_320 [] = {
   4,2,4,0,10,0,41,0,0,8,0,41,3,0,32,0,41,3,0,32,0,41,0,0,12,0,
   41,0,0,12,0,7,0,7,0,7,0,7,0,7,0,12,0,15,'J',19,'R','D','B','$',
   'R','E','F','_','C','O','N','S','T','R','A','I','N','T','S',
   0,2,1,41,0,3,0,5,0,23,0,15,'R','D','B','$','D','E','L','E','T',
   'E','_','R','U','L','E',1,41,0,4,0,6,0,23,0,15,'R','D','B','$',
   'U','P','D','A','T','E','_','R','U','L','E',1,41,0,0,0,7,0,23,
   0,16,'R','D','B','$','M','A','T','C','H','_','O','P','T','I',
   'O','N',1,41,0,1,0,8,0,23,0,17,'R','D','B','$','C','O','N','S',
   'T','_','N','A','M','E','_','U','Q',1,41,0,2,0,9,0,23,0,19,'R',
   'D','B','$','C','O','N','S','T','R','A','I','N','T','_','N',
   'A','M','E',-1,-1,'L'
   };	/* end of blr string for request isc_320 */

static const short
   isc_332l = 247;
static const char
   isc_332 [] = {
   4,2,4,0,9,0,41,3,0,32,0,41,3,0,32,0,41,3,0,32,0,9,0,7,0,7,0,
   7,0,7,0,7,0,12,0,15,'J',24,'R','D','B','$','P','R','O','C','E',
   'D','U','R','E','_','P','A','R','A','M','E','T','E','R','S',
   0,2,1,25,0,0,0,23,0,16,'R','D','B','$','F','I','E','L','D','_',
   'S','O','U','R','C','E',1,25,0,4,0,23,0,20,'R','D','B','$','P',
   'A','R','A','M','E','T','E','R','_','N','U','M','B','E','R',
   1,25,0,5,0,23,0,18,'R','D','B','$','P','A','R','A','M','E','T',
   'E','R','_','T','Y','P','E',1,25,0,1,0,23,0,18,'R','D','B','$',
   'P','A','R','A','M','E','T','E','R','_','N','A','M','E',1,41,
   0,7,0,6,0,23,0,15,'R','D','B','$','S','Y','S','T','E','M','_',
   'F','L','A','G',1,25,0,2,0,23,0,18,'R','D','B','$','P','R','O',
   'C','E','D','U','R','E','_','N','A','M','E',1,41,0,3,0,8,0,23,
   0,15,'R','D','B','$','D','E','S','C','R','I','P','T','I','O',
   'N',-1,-1,'L'
   };	/* end of blr string for request isc_332 */

static const short
   isc_343l = 469;
static const char
   isc_343 [] = {
   4,2,4,0,23,0,41,3,0,32,0,41,3,0,32,0,41,3,0,32,0,41,3,0,32,0,
   9,0,9,0,9,0,41,3,0,32,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,
   7,0,7,0,7,0,7,0,7,0,7,0,12,0,15,'J',24,'R','D','B','$','P','R',
   'O','C','E','D','U','R','E','_','P','A','R','A','M','E','T',
   'E','R','S',0,2,1,25,0,0,0,23,0,16,'R','D','B','$','F','I','E',
   'L','D','_','S','O','U','R','C','E',1,25,0,8,0,23,0,20,'R','D',
   'B','$','P','A','R','A','M','E','T','E','R','_','N','U','M',
   'B','E','R',1,25,0,9,0,23,0,18,'R','D','B','$','P','A','R','A',
   'M','E','T','E','R','_','T','Y','P','E',1,25,0,1,0,23,0,18,'R',
   'D','B','$','P','A','R','A','M','E','T','E','R','_','N','A',
   'M','E',1,41,0,2,0,10,0,23,0,17,'R','D','B','$','R','E','L',
   'A','T','I','O','N','_','N','A','M','E',1,41,0,3,0,11,0,23,0,
   14,'R','D','B','$','F','I','E','L','D','_','N','A','M','E',1,
   41,0,13,0,12,0,23,0,23,'R','D','B','$','P','A','R','A','M','E',
   'T','E','R','_','M','E','C','H','A','N','I','S','M',1,41,0,15,
   0,14,0,23,0,13,'R','D','B','$','N','U','L','L','_','F','L','A',
   'G',1,41,0,17,0,16,0,23,0,15,'R','D','B','$','S','Y','S','T',
   'E','M','_','F','L','A','G',1,41,0,19,0,18,0,23,0,16,'R','D',
   'B','$','C','O','L','L','A','T','I','O','N','_','I','D',1,41,
   0,4,0,20,0,23,0,18,'R','D','B','$','D','E','F','A','U','L','T',
   '_','S','O','U','R','C','E',1,41,0,5,0,21,0,23,0,17,'R','D',
   'B','$','D','E','F','A','U','L','T','_','V','A','L','U','E',
   1,41,0,6,0,22,0,23,0,15,'R','D','B','$','D','E','S','C','R',
   'I','P','T','I','O','N',1,25,0,7,0,23,0,18,'R','D','B','$','P',
   'R','O','C','E','D','U','R','E','_','N','A','M','E',-1,-1,'L'
   
   };	/* end of blr string for request isc_343 */

static const short
   isc_368l = 311;
static const char
   isc_368 [] = {
   4,2,4,0,15,0,9,0,41,3,0,32,0,41,3,0,32,0,41,3,0,32,0,9,0,9,0,
   7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,12,0,15,'J',14,'R','D','B',
   '$','P','R','O','C','E','D','U','R','E','S',0,2,1,25,0,6,0,23,
   0,21,'R','D','B','$','P','R','O','C','E','D','U','R','E','_',
   'O','U','T','P','U','T','S',1,41,0,8,0,7,0,23,0,20,'R','D','B',
   '$','P','R','O','C','E','D','U','R','E','_','I','N','P','U',
   'T','S',1,25,0,0,0,23,0,17,'R','D','B','$','P','R','O','C','E',
   'D','U','R','E','_','B','L','R',1,25,0,1,0,23,0,18,'R','D','B',
   '$','P','R','O','C','E','D','U','R','E','_','N','A','M','E',
   1,41,0,10,0,9,0,23,0,15,'R','D','B','$','S','Y','S','T','E',
   'M','_','F','L','A','G',1,41,0,2,0,11,0,23,0,14,'R','D','B',
   '$','O','W','N','E','R','_','N','A','M','E',1,41,0,3,0,12,0,
   23,0,18,'R','D','B','$','S','E','C','U','R','I','T','Y','_',
   'C','L','A','S','S',1,41,0,4,0,13,0,23,0,15,'R','D','B','$',
   'D','E','S','C','R','I','P','T','I','O','N',1,41,0,5,0,14,0,
   23,0,20,'R','D','B','$','P','R','O','C','E','D','U','R','E',
   '_','S','O','U','R','C','E',-1,-1,'L'
   };	/* end of blr string for request isc_368 */

static const short
   isc_385l = 398;
static const char
   isc_385 [] = {
   4,2,4,0,21,0,9,0,41,3,0,32,0,9,0,41,3,0,32,0,41,3,0,32,0,9,0,
   9,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,
   12,0,15,'J',14,'R','D','B','$','P','R','O','C','E','D','U','R',
   'E','S',0,2,1,25,0,7,0,23,0,21,'R','D','B','$','P','R','O','C',
   'E','D','U','R','E','_','O','U','T','P','U','T','S',1,41,0,9,
   0,8,0,23,0,20,'R','D','B','$','P','R','O','C','E','D','U','R',
   'E','_','I','N','P','U','T','S',1,25,0,0,0,23,0,17,'R','D','B',
   '$','P','R','O','C','E','D','U','R','E','_','B','L','R',1,25,
   0,1,0,23,0,18,'R','D','B','$','P','R','O','C','E','D','U','R',
   'E','_','N','A','M','E',1,41,0,2,0,10,0,23,0,14,'R','D','B',
   '$','D','E','B','U','G','_','I','N','F','O',1,41,0,12,0,11,0,
   23,0,13,'R','D','B','$','V','A','L','I','D','_','B','L','R',
   1,41,0,14,0,13,0,23,0,15,'R','D','B','$','S','Y','S','T','E',
   'M','_','F','L','A','G',1,41,0,16,0,15,0,23,0,18,'R','D','B',
   '$','P','R','O','C','E','D','U','R','E','_','T','Y','P','E',
   1,41,0,3,0,17,0,23,0,14,'R','D','B','$','O','W','N','E','R',
   '_','N','A','M','E',1,41,0,4,0,18,0,23,0,18,'R','D','B','$',
   'S','E','C','U','R','I','T','Y','_','C','L','A','S','S',1,41,
   0,5,0,19,0,23,0,15,'R','D','B','$','D','E','S','C','R','I','P',
   'T','I','O','N',1,41,0,6,0,20,0,23,0,20,'R','D','B','$','P',
   'R','O','C','E','D','U','R','E','_','S','O','U','R','C','E',
   -1,-1,'L'
   };	/* end of blr string for request isc_385 */

static const short
   isc_408l = 129;
static const char
   isc_408 [] = {
   4,2,4,3,1,0,7,0,4,2,1,0,7,0,4,1,1,0,7,0,4,0,1,0,41,3,0,32,0,
   12,0,2,7,'C',1,'J',18,'R','D','B','$','I','N','D','E','X','_',
   'S','E','G','M','E','N','T','S',0,'G',47,23,0,14,'R','D','B',
   '$','I','N','D','E','X','_','N','A','M','E',25,0,0,0,-1,2,14,
   1,2,1,21,8,0,1,0,0,0,25,1,0,0,-1,17,0,9,13,12,3,18,0,12,2,11,
   5,0,-1,-1,14,1,1,21,8,0,0,0,0,0,25,1,0,0,-1,-1,'L'
   };	/* end of blr string for request isc_408 */

static const short
   isc_417l = 190;
static const char
   isc_417 [] = {
   4,2,4,1,1,0,7,0,4,0,2,0,41,3,0,32,0,41,3,0,32,0,12,0,2,7,'C',
   2,'J',19,'R','D','B','$','R','E','L','A','T','I','O','N','_',
   'F','I','E','L','D','S',0,'J',18,'R','D','B','$','I','N','D',
   'E','X','_','S','E','G','M','E','N','T','S',1,'G',58,47,23,1,
   14,'R','D','B','$','F','I','E','L','D','_','N','A','M','E',23,
   0,14,'R','D','B','$','F','I','E','L','D','_','N','A','M','E',
   58,47,23,1,14,'R','D','B','$','I','N','D','E','X','_','N','A',
   'M','E',25,0,1,0,47,23,0,17,'R','D','B','$','R','E','L','A',
   'T','I','O','N','_','N','A','M','E',25,0,0,0,-1,14,1,2,1,21,
   8,0,1,0,0,0,25,1,0,0,-1,14,1,1,21,8,0,0,0,0,0,25,1,0,0,-1,-1,
   'L'
   };	/* end of blr string for request isc_417 */

static const short
   isc_423l = 116;
static const char
   isc_423 [] = {
   4,2,4,0,3,0,41,3,0,32,0,41,3,0,32,0,7,0,12,0,15,'J',18,'R','D',
   'B','$','I','N','D','E','X','_','S','E','G','M','E','N','T',
   'S',0,2,1,25,0,2,0,23,0,18,'R','D','B','$','F','I','E','L','D',
   '_','P','O','S','I','T','I','O','N',1,25,0,0,0,23,0,14,'R','D',
   'B','$','I','N','D','E','X','_','N','A','M','E',1,25,0,1,0,23,
   0,14,'R','D','B','$','F','I','E','L','D','_','N','A','M','E',
   -1,-1,'L'
   };	/* end of blr string for request isc_423 */

static const short
   isc_428l = 349;
static const char
   isc_428 [] = {
   4,2,4,0,17,0,41,3,0,32,0,9,0,9,0,41,3,0,32,0,9,0,41,3,0,32,0,
   7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,12,0,15,'J',11,'R',
   'D','B','$','I','N','D','I','C','E','S',0,2,1,25,0,6,0,23,0,
   17,'R','D','B','$','S','E','G','M','E','N','T','_','C','O','U',
   'N','T',1,25,0,0,0,23,0,14,'R','D','B','$','I','N','D','E','X',
   '_','N','A','M','E',1,41,0,8,0,7,0,23,0,15,'R','D','B','$','S',
   'Y','S','T','E','M','_','F','L','A','G',1,41,0,1,0,9,0,23,0,
   18,'R','D','B','$','E','X','P','R','E','S','S','I','O','N','_',
   'B','L','R',1,41,0,2,0,10,0,23,0,21,'R','D','B','$','E','X',
   'P','R','E','S','S','I','O','N','_','S','O','U','R','C','E',
   1,41,0,3,0,11,0,23,0,15,'R','D','B','$','F','O','R','E','I',
   'G','N','_','K','E','Y',1,41,0,4,0,12,0,23,0,15,'R','D','B',
   '$','D','E','S','C','R','I','P','T','I','O','N',1,41,0,14,0,
   13,0,23,0,14,'R','D','B','$','I','N','D','E','X','_','T','Y',
   'P','E',1,25,0,15,0,23,0,18,'R','D','B','$','I','N','D','E',
   'X','_','I','N','A','C','T','I','V','E',1,25,0,16,0,23,0,15,
   'R','D','B','$','U','N','I','Q','U','E','_','F','L','A','G',
   1,25,0,5,0,23,0,17,'R','D','B','$','R','E','L','A','T','I','O',
   'N','_','N','A','M','E',-1,-1,'L'
   };	/* end of blr string for request isc_428 */

static const short
   isc_447l = 852;
static const char
   isc_447 [] = {
   4,2,4,0,51,0,41,3,0,32,0,9,0,9,0,9,0,9,0,9,0,9,0,9,0,9,0,41,
   0,0,-128,0,41,3,0,32,0,9,0,9,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,
   0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,
   0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,
   0,12,0,15,'J',10,'R','D','B','$','F','I','E','L','D','S',0,2,
   1,25,0,14,0,23,0,16,'R','D','B','$','F','I','E','L','D','_',
   'L','E','N','G','T','H',1,25,0,15,0,23,0,14,'R','D','B','$',
   'F','I','E','L','D','_','T','Y','P','E',1,25,0,0,0,23,0,14,'R',
   'D','B','$','F','I','E','L','D','_','N','A','M','E',1,41,0,1,
   0,19,0,23,0,18,'R','D','B','$','D','E','F','A','U','L','T','_',
   'S','O','U','R','C','E',1,41,0,2,0,20,0,23,0,18,'R','D','B',
   '$','M','I','S','S','I','N','G','_','S','O','U','R','C','E',
   1,41,0,22,0,21,0,23,0,20,'R','D','B','$','C','H','A','R','A',
   'C','T','E','R','_','L','E','N','G','T','H',1,41,0,25,0,24,0,
   23,0,18,'R','D','B','$','E','X','T','E','R','N','A','L','_',
   'S','C','A','L','E',1,41,0,27,0,26,0,23,0,17,'R','D','B','$',
   'E','X','T','E','R','N','A','L','_','T','Y','P','E',1,41,0,29,
   0,28,0,23,0,19,'R','D','B','$','E','X','T','E','R','N','A','L',
   '_','L','E','N','G','T','H',1,41,0,31,0,30,0,23,0,14,'R','D',
   'B','$','D','I','M','E','N','S','I','O','N','S',1,41,0,3,0,32,
   0,23,0,15,'R','D','B','$','D','E','S','C','R','I','P','T','I',
   'O','N',1,41,0,34,0,33,0,23,0,13,'R','D','B','$','N','U','L',
   'L','_','F','L','A','G',1,41,0,'$',0,35,0,23,0,15,'R','D','B',
   '$','S','Y','S','T','E','M','_','F','L','A','G',1,41,0,4,0,37,
   0,23,0,21,'R','D','B','$','V','A','L','I','D','A','T','I','O',
   'N','_','S','O','U','R','C','E',1,41,0,5,0,38,0,23,0,18,'R',
   'D','B','$','V','A','L','I','D','A','T','I','O','N','_','B',
   'L','R',1,41,0,6,0,39,0,23,0,17,'R','D','B','$','D','E','F',
   'A','U','L','T','_','V','A','L','U','E',1,41,0,7,0,40,0,23,0,
   17,'R','D','B','$','M','I','S','S','I','N','G','_','V','A','L',
   'U','E',1,41,0,8,0,41,0,23,0,16,'R','D','B','$','Q','U','E',
   'R','Y','_','H','E','A','D','E','R',1,41,0,9,0,42,0,23,0,15,
   'R','D','B','$','E','D','I','T','_','S','T','R','I','N','G',
   1,41,0,10,0,43,0,23,0,14,'R','D','B','$','Q','U','E','R','Y',
   '_','N','A','M','E',1,41,0,11,0,44,0,23,0,19,'R','D','B','$',
   'C','O','M','P','U','T','E','D','_','S','O','U','R','C','E',
   1,41,0,12,0,45,0,23,0,16,'R','D','B','$','C','O','M','P','U',
   'T','E','D','_','B','L','R',1,41,0,46,0,18,0,23,0,18,'R','D',
   'B','$','F','I','E','L','D','_','S','U','B','_','T','Y','P',
   'E',1,41,0,47,0,16,0,23,0,16,'R','D','B','$','C','O','L','L',
   'A','T','I','O','N','_','I','D',1,41,0,48,0,17,0,23,0,20,'R',
   'D','B','$','C','H','A','R','A','C','T','E','R','_','S','E',
   'T','_','I','D',1,41,0,49,0,23,0,23,0,18,'R','D','B','$','S',
   'E','G','M','E','N','T','_','L','E','N','G','T','H',1,41,0,50,
   0,13,0,23,0,15,'R','D','B','$','F','I','E','L','D','_','S','C',
   'A','L','E',-1,-1,'L'
   };	/* end of blr string for request isc_447 */

static const short
   isc_500l = 885;
static const char
   isc_500 [] = {
   4,2,4,0,53,0,41,3,0,32,0,9,0,9,0,9,0,9,0,9,0,9,0,9,0,9,0,41,
   0,0,-128,0,41,3,0,32,0,9,0,9,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,
   0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,
   0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,
   0,7,0,7,0,12,0,15,'J',10,'R','D','B','$','F','I','E','L','D',
   'S',0,2,1,25,0,14,0,23,0,16,'R','D','B','$','F','I','E','L',
   'D','_','L','E','N','G','T','H',1,25,0,15,0,23,0,14,'R','D',
   'B','$','F','I','E','L','D','_','T','Y','P','E',1,25,0,0,0,23,
   0,14,'R','D','B','$','F','I','E','L','D','_','N','A','M','E',
   1,41,0,17,0,16,0,23,0,19,'R','D','B','$','F','I','E','L','D',
   '_','P','R','E','C','I','S','I','O','N',1,41,0,1,0,21,0,23,0,
   18,'R','D','B','$','D','E','F','A','U','L','T','_','S','O','U',
   'R','C','E',1,41,0,2,0,22,0,23,0,18,'R','D','B','$','M','I',
   'S','S','I','N','G','_','S','O','U','R','C','E',1,41,0,24,0,
   23,0,23,0,20,'R','D','B','$','C','H','A','R','A','C','T','E',
   'R','_','L','E','N','G','T','H',1,41,0,27,0,26,0,23,0,18,'R',
   'D','B','$','E','X','T','E','R','N','A','L','_','S','C','A',
   'L','E',1,41,0,29,0,28,0,23,0,17,'R','D','B','$','E','X','T',
   'E','R','N','A','L','_','T','Y','P','E',1,41,0,31,0,30,0,23,
   0,19,'R','D','B','$','E','X','T','E','R','N','A','L','_','L',
   'E','N','G','T','H',1,41,0,33,0,32,0,23,0,14,'R','D','B','$',
   'D','I','M','E','N','S','I','O','N','S',1,41,0,3,0,34,0,23,0,
   15,'R','D','B','$','D','E','S','C','R','I','P','T','I','O','N',
   1,41,0,'$',0,35,0,23,0,13,'R','D','B','$','N','U','L','L','_',
   'F','L','A','G',1,41,0,38,0,37,0,23,0,15,'R','D','B','$','S',
   'Y','S','T','E','M','_','F','L','A','G',1,41,0,4,0,39,0,23,0,
   21,'R','D','B','$','V','A','L','I','D','A','T','I','O','N','_',
   'S','O','U','R','C','E',1,41,0,5,0,40,0,23,0,18,'R','D','B',
   '$','V','A','L','I','D','A','T','I','O','N','_','B','L','R',
   1,41,0,6,0,41,0,23,0,17,'R','D','B','$','D','E','F','A','U',
   'L','T','_','V','A','L','U','E',1,41,0,7,0,42,0,23,0,17,'R',
   'D','B','$','M','I','S','S','I','N','G','_','V','A','L','U',
   'E',1,41,0,8,0,43,0,23,0,16,'R','D','B','$','Q','U','E','R',
   'Y','_','H','E','A','D','E','R',1,41,0,9,0,44,0,23,0,15,'R',
   'D','B','$','E','D','I','T','_','S','T','R','I','N','G',1,41,
   0,10,0,45,0,23,0,14,'R','D','B','$','Q','U','E','R','Y','_',
   'N','A','M','E',1,41,0,11,0,46,0,23,0,19,'R','D','B','$','C',
   'O','M','P','U','T','E','D','_','S','O','U','R','C','E',1,41,
   0,12,0,47,0,23,0,16,'R','D','B','$','C','O','M','P','U','T',
   'E','D','_','B','L','R',1,41,0,48,0,20,0,23,0,18,'R','D','B',
   '$','F','I','E','L','D','_','S','U','B','_','T','Y','P','E',
   1,41,0,49,0,18,0,23,0,16,'R','D','B','$','C','O','L','L','A',
   'T','I','O','N','_','I','D',1,41,0,50,0,19,0,23,0,20,'R','D',
   'B','$','C','H','A','R','A','C','T','E','R','_','S','E','T',
   '_','I','D',1,41,0,51,0,25,0,23,0,18,'R','D','B','$','S','E',
   'G','M','E','N','T','_','L','E','N','G','T','H',1,41,0,52,0,
   13,0,23,0,15,'R','D','B','$','F','I','E','L','D','_','S','C',
   'A','L','E',-1,-1,'L'
   };	/* end of blr string for request isc_500 */

static const short
   isc_555l = 263;
static const char
   isc_555 [] = {
   4,2,4,0,10,0,41,3,0,32,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,
   12,0,15,'J',22,'R','D','B','$','F','U','N','C','T','I','O','N',
   '_','A','R','G','U','M','E','N','T','S',0,2,1,25,0,1,0,23,0,
   16,'R','D','B','$','F','I','E','L','D','_','L','E','N','G','T',
   'H',1,25,0,2,0,23,0,15,'R','D','B','$','F','I','E','L','D','_',
   'S','C','A','L','E',1,25,0,3,0,23,0,14,'R','D','B','$','F','I',
   'E','L','D','_','T','Y','P','E',1,25,0,4,0,23,0,13,'R','D','B',
   '$','M','E','C','H','A','N','I','S','M',1,25,0,5,0,23,0,21,'R',
   'D','B','$','A','R','G','U','M','E','N','T','_','P','O','S',
   'I','T','I','O','N',1,25,0,0,0,23,0,17,'R','D','B','$','F','U',
   'N','C','T','I','O','N','_','N','A','M','E',1,41,0,7,0,6,0,23,
   0,20,'R','D','B','$','C','H','A','R','A','C','T','E','R','_',
   'S','E','T','_','I','D',1,41,0,9,0,8,0,23,0,18,'R','D','B','$',
   'F','I','E','L','D','_','S','U','B','_','T','Y','P','E',-1,-1,
   'L'
   };	/* end of blr string for request isc_555 */

static const short
   isc_567l = 296;
static const char
   isc_567 [] = {
   4,2,4,0,12,0,41,3,0,32,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,
   7,0,7,0,12,0,15,'J',22,'R','D','B','$','F','U','N','C','T','I',
   'O','N','_','A','R','G','U','M','E','N','T','S',0,2,1,25,0,1,
   0,23,0,16,'R','D','B','$','F','I','E','L','D','_','L','E','N',
   'G','T','H',1,25,0,2,0,23,0,15,'R','D','B','$','F','I','E','L',
   'D','_','S','C','A','L','E',1,25,0,3,0,23,0,14,'R','D','B','$',
   'F','I','E','L','D','_','T','Y','P','E',1,25,0,4,0,23,0,13,'R',
   'D','B','$','M','E','C','H','A','N','I','S','M',1,25,0,5,0,23,
   0,21,'R','D','B','$','A','R','G','U','M','E','N','T','_','P',
   'O','S','I','T','I','O','N',1,25,0,0,0,23,0,17,'R','D','B','$',
   'F','U','N','C','T','I','O','N','_','N','A','M','E',1,41,0,7,
   0,6,0,23,0,19,'R','D','B','$','F','I','E','L','D','_','P','R',
   'E','C','I','S','I','O','N',1,41,0,9,0,8,0,23,0,20,'R','D','B',
   '$','C','H','A','R','A','C','T','E','R','_','S','E','T','_',
   'I','D',1,41,0,11,0,10,0,23,0,18,'R','D','B','$','F','I','E',
   'L','D','_','S','U','B','_','T','Y','P','E',-1,-1,'L'
   };	/* end of blr string for request isc_567 */

static const short
   isc_581l = 255;
static const char
   isc_581 [] = {
   4,2,4,0,10,0,41,3,0,32,0,41,0,0,32,0,41,0,0,0,1,41,3,0,32,0,
   9,0,7,0,7,0,7,0,7,0,7,0,12,0,15,'J',13,'R','D','B','$','F','U',
   'N','C','T','I','O','N','S',0,2,1,25,0,5,0,23,0,17,'R','D','B',
   '$','F','U','N','C','T','I','O','N','_','T','Y','P','E',1,25,
   0,0,0,23,0,14,'R','D','B','$','Q','U','E','R','Y','_','N','A',
   'M','E',1,25,0,6,0,23,0,19,'R','D','B','$','R','E','T','U','R',
   'N','_','A','R','G','U','M','E','N','T',1,25,0,1,0,23,0,14,'R',
   'D','B','$','E','N','T','R','Y','P','O','I','N','T',1,25,0,2,
   0,23,0,15,'R','D','B','$','M','O','D','U','L','E','_','N','A',
   'M','E',1,25,0,3,0,23,0,17,'R','D','B','$','F','U','N','C','T',
   'I','O','N','_','N','A','M','E',1,41,0,4,0,7,0,23,0,15,'R','D',
   'B','$','D','E','S','C','R','I','P','T','I','O','N',1,41,0,9,
   0,8,0,23,0,15,'R','D','B','$','S','Y','S','T','E','M','_','F',
   'L','A','G',-1,-1,'L'
   };	/* end of blr string for request isc_581 */

static const short
   isc_593l = 227;
static const char
   isc_593 [] = {
   4,2,4,0,9,0,41,0,0,32,0,41,0,0,0,1,41,3,0,32,0,9,0,7,0,7,0,7,
   0,7,0,7,0,12,0,15,'J',11,'R','D','B','$','F','I','L','T','E',
   'R','S',0,2,1,25,0,4,0,23,0,19,'R','D','B','$','O','U','T','P',
   'U','T','_','S','U','B','_','T','Y','P','E',1,25,0,5,0,23,0,
   18,'R','D','B','$','I','N','P','U','T','_','S','U','B','_','T',
   'Y','P','E',1,25,0,0,0,23,0,14,'R','D','B','$','E','N','T','R',
   'Y','P','O','I','N','T',1,25,0,1,0,23,0,15,'R','D','B','$','M',
   'O','D','U','L','E','_','N','A','M','E',1,25,0,2,0,23,0,17,'R',
   'D','B','$','F','U','N','C','T','I','O','N','_','N','A','M',
   'E',1,41,0,7,0,6,0,23,0,15,'R','D','B','$','S','Y','S','T','E',
   'M','_','F','L','A','G',1,41,0,3,0,8,0,23,0,15,'R','D','B','$',
   'D','E','S','C','R','I','P','T','I','O','N',-1,-1,'L'
   };	/* end of blr string for request isc_593 */

static const short
   isc_604l = 178;
static const char
   isc_604 [] = {
   4,2,4,0,6,0,41,0,0,0,1,8,0,8,0,7,0,7,0,7,0,12,0,15,'J',9,'R',
   'D','B','$','F','I','L','E','S',0,2,1,25,0,3,0,23,0,17,'R','D',
   'B','$','S','H','A','D','O','W','_','N','U','M','B','E','R',
   1,25,0,1,0,23,0,15,'R','D','B','$','F','I','L','E','_','L','E',
   'N','G','T','H',1,25,0,2,0,23,0,14,'R','D','B','$','F','I','L',
   'E','_','S','T','A','R','T',1,25,0,4,0,23,0,17,'R','D','B','$',
   'F','I','L','E','_','S','E','Q','U','E','N','C','E',1,25,0,0,
   0,23,0,13,'R','D','B','$','F','I','L','E','_','N','A','M','E',
   1,25,0,5,0,23,0,14,'R','D','B','$','F','I','L','E','_','F','L',
   'A','G','S',-1,-1,'L'
   };	/* end of blr string for request isc_604 */

static const short
   isc_612l = 136;
static const char
   isc_612 [] = {
   4,2,4,0,4,0,41,3,0,32,0,8,0,8,0,7,0,12,0,15,'J',20,'R','D','B',
   '$','F','I','E','L','D','_','D','I','M','E','N','S','I','O',
   'N','S',0,2,1,25,0,1,0,23,0,15,'R','D','B','$','U','P','P','E',
   'R','_','B','O','U','N','D',1,25,0,2,0,23,0,15,'R','D','B','$',
   'L','O','W','E','R','_','B','O','U','N','D',1,25,0,3,0,23,0,
   13,'R','D','B','$','D','I','M','E','N','S','I','O','N',1,25,
   0,0,0,23,0,14,'R','D','B','$','F','I','E','L','D','_','N','A',
   'M','E',-1,-1,'L'
   };	/* end of blr string for request isc_612 */

static const short
   isc_618l = 582;
static const char
   isc_618 [] = {
   4,2,4,0,33,0,41,3,0,32,0,41,3,0,32,0,9,0,9,0,41,3,0,32,0,9,0,
   41,0,0,-128,0,9,0,41,3,0,32,0,41,3,0,32,0,41,3,0,32,0,41,3,0,
   32,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,
   7,0,7,0,7,0,7,0,7,0,7,0,7,0,12,0,15,'J',19,'R','D','B','$','R',
   'E','L','A','T','I','O','N','_','F','I','E','L','D','S',0,2,
   1,25,0,0,0,23,0,16,'R','D','B','$','F','I','E','L','D','_','S',
   'O','U','R','C','E',1,25,0,1,0,23,0,14,'R','D','B','$','F','I',
   'E','L','D','_','N','A','M','E',1,41,0,13,0,12,0,23,0,16,'R',
   'D','B','$','C','O','L','L','A','T','I','O','N','_','I','D',
   1,41,0,15,0,14,0,23,0,13,'R','D','B','$','N','U','L','L','_',
   'F','L','A','G',1,41,0,2,0,16,0,23,0,17,'R','D','B','$','D',
   'E','F','A','U','L','T','_','V','A','L','U','E',1,41,0,3,0,17,
   0,23,0,18,'R','D','B','$','D','E','F','A','U','L','T','_','S',
   'O','U','R','C','E',1,41,0,19,0,18,0,23,0,15,'R','D','B','$',
   'U','P','D','A','T','E','_','F','L','A','G',1,41,0,4,0,20,0,
   23,0,16,'R','D','B','$','C','O','M','P','L','E','X','_','N',
   'A','M','E',1,41,0,22,0,21,0,23,0,15,'R','D','B','$','S','Y',
   'S','T','E','M','_','F','L','A','G',1,41,0,5,0,24,0,23,0,15,
   'R','D','B','$','D','E','S','C','R','I','P','T','I','O','N',
   1,41,0,6,0,25,0,23,0,15,'R','D','B','$','E','D','I','T','_',
   'S','T','R','I','N','G',1,41,0,7,0,26,0,23,0,16,'R','D','B',
   '$','Q','U','E','R','Y','_','H','E','A','D','E','R',1,41,0,8,
   0,27,0,23,0,14,'R','D','B','$','Q','U','E','R','Y','_','N','A',
   'M','E',1,41,0,9,0,28,0,23,0,18,'R','D','B','$','S','E','C',
   'U','R','I','T','Y','_','C','L','A','S','S',1,41,0,10,0,29,0,
   23,0,14,'R','D','B','$','B','A','S','E','_','F','I','E','L',
   'D',1,41,0,31,0,30,0,23,0,16,'R','D','B','$','V','I','E','W',
   '_','C','O','N','T','E','X','T',1,41,0,32,0,23,0,23,0,18,'R',
   'D','B','$','F','I','E','L','D','_','P','O','S','I','T','I',
   'O','N',1,25,0,11,0,23,0,17,'R','D','B','$','R','E','L','A',
   'T','I','O','N','_','N','A','M','E',-1,-1,'L'
   };	/* end of blr string for request isc_618 */

static const short
   isc_653l = 151;
static const char
   isc_653 [] = {
   4,2,4,0,8,0,41,0,0,0,4,9,0,41,3,0,32,0,7,0,7,0,7,0,7,0,7,0,12,
   0,15,'J',14,'R','D','B','$','E','X','C','E','P','T','I','O',
   'N','S',0,2,1,41,0,4,0,3,0,23,0,15,'R','D','B','$','S','Y','S',
   'T','E','M','_','F','L','A','G',1,41,0,0,0,5,0,23,0,11,'R','D',
   'B','$','M','E','S','S','A','G','E',1,41,0,1,0,6,0,23,0,15,'R',
   'D','B','$','D','E','S','C','R','I','P','T','I','O','N',1,41,
   0,2,0,7,0,23,0,18,'R','D','B','$','E','X','C','E','P','T','I',
   'O','N','_','N','A','M','E',-1,-1,'L'
   };	/* end of blr string for request isc_653 */

static const short
   isc_663l = 178;
static const char
   isc_663 [] = {
   4,2,4,3,1,0,7,0,4,2,1,0,7,0,4,1,2,0,7,0,7,0,4,0,1,0,41,3,0,32,
   0,12,0,2,7,'C',1,'J',11,'R','D','B','$','I','N','D','I','C',
   'E','S',0,'G',47,23,0,14,'R','D','B','$','I','N','D','E','X',
   '_','N','A','M','E',25,0,0,0,-1,2,14,1,2,1,21,8,0,1,0,0,0,25,
   1,0,0,1,23,0,18,'R','D','B','$','I','N','D','E','X','_','I',
   'N','A','C','T','I','V','E',25,1,1,0,-1,17,0,9,13,12,3,18,0,
   12,2,10,0,1,2,1,25,2,0,0,23,1,18,'R','D','B','$','I','N','D',
   'E','X','_','I','N','A','C','T','I','V','E',-1,-1,-1,14,1,1,
   21,8,0,0,0,0,0,25,1,0,0,-1,-1,'L'
   };	/* end of blr string for request isc_663 */

static const short
   isc_673l = 336;
static const char
   isc_673 [] = {
   4,2,4,0,18,0,9,0,41,3,0,32,0,41,3,0,32,0,9,0,41,3,0,32,0,7,0,
   7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,12,0,15,'J',
   14,'R','D','B','$','C','O','L','L','A','T','I','O','N','S',0,
   2,1,41,0,0,0,5,0,23,0,23,'R','D','B','$','S','P','E','C','I',
   'F','I','C','_','A','T','T','R','I','B','U','T','E','S',1,41,
   0,1,0,6,0,23,0,23,'R','D','B','$','B','A','S','E','_','C','O',
   'L','L','A','T','I','O','N','_','N','A','M','E',1,41,0,2,0,7,
   0,23,0,17,'R','D','B','$','F','U','N','C','T','I','O','N','_',
   'N','A','M','E',1,41,0,3,0,8,0,23,0,15,'R','D','B','$','D','E',
   'S','C','R','I','P','T','I','O','N',1,41,0,10,0,9,0,23,0,15,
   'R','D','B','$','S','Y','S','T','E','M','_','F','L','A','G',
   1,41,0,12,0,11,0,23,0,24,'R','D','B','$','C','O','L','L','A',
   'T','I','O','N','_','A','T','T','R','I','B','U','T','E','S',
   1,41,0,14,0,13,0,23,0,20,'R','D','B','$','C','H','A','R','A',
   'C','T','E','R','_','S','E','T','_','I','D',1,41,0,16,0,15,0,
   23,0,16,'R','D','B','$','C','O','L','L','A','T','I','O','N',
   '_','I','D',1,41,0,4,0,17,0,23,0,18,'R','D','B','$','C','O',
   'L','L','A','T','I','O','N','_','N','A','M','E',-1,-1,'L'
   };	/* end of blr string for request isc_673 */

static const short
   isc_693l = 336;
static const char
   isc_693 [] = {
   4,2,4,0,18,0,9,0,41,3,0,32,0,41,3,0,32,0,9,0,41,3,0,32,0,7,0,
   7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,12,0,15,'J',
   14,'R','D','B','$','C','O','L','L','A','T','I','O','N','S',0,
   2,1,41,0,0,0,5,0,23,0,23,'R','D','B','$','S','P','E','C','I',
   'F','I','C','_','A','T','T','R','I','B','U','T','E','S',1,41,
   0,1,0,6,0,23,0,23,'R','D','B','$','B','A','S','E','_','C','O',
   'L','L','A','T','I','O','N','_','N','A','M','E',1,41,0,2,0,7,
   0,23,0,17,'R','D','B','$','F','U','N','C','T','I','O','N','_',
   'N','A','M','E',1,41,0,3,0,8,0,23,0,15,'R','D','B','$','D','E',
   'S','C','R','I','P','T','I','O','N',1,41,0,10,0,9,0,23,0,15,
   'R','D','B','$','S','Y','S','T','E','M','_','F','L','A','G',
   1,41,0,12,0,11,0,23,0,24,'R','D','B','$','C','O','L','L','A',
   'T','I','O','N','_','A','T','T','R','I','B','U','T','E','S',
   1,41,0,14,0,13,0,23,0,20,'R','D','B','$','C','H','A','R','A',
   'C','T','E','R','_','S','E','T','_','I','D',1,41,0,16,0,15,0,
   23,0,16,'R','D','B','$','C','O','L','L','A','T','I','O','N',
   '_','I','D',1,41,0,4,0,17,0,23,0,18,'R','D','B','$','C','O',
   'L','L','A','T','I','O','N','_','N','A','M','E',-1,-1,'L'
   };	/* end of blr string for request isc_693 */

static const short
   isc_713l = 106;
static const char
   isc_713 [] = {
   4,2,4,0,4,0,41,3,0,32,0,41,3,0,32,0,7,0,7,0,12,0,15,'J',21,'R',
   'D','B','$','C','H','E','C','K','_','C','O','N','S','T','R',
   'A','I','N','T','S',0,2,1,41,0,0,0,2,0,23,0,16,'R','D','B','$',
   'T','R','I','G','G','E','R','_','N','A','M','E',1,41,0,1,0,3,
   0,23,0,19,'R','D','B','$','C','O','N','S','T','R','A','I','N',
   'T','_','N','A','M','E',-1,-1,'L'
   };	/* end of blr string for request isc_713 */

static const short
   isc_719l = 347;
static const char
   isc_719 [] = {
   4,2,4,0,18,0,41,3,0,32,0,9,0,41,3,0,32,0,41,3,0,32,0,41,3,0,
   32,0,8,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,12,
   0,15,'J',18,'R','D','B','$','C','H','A','R','A','C','T','E',
   'R','_','S','E','T','S',0,2,1,41,0,7,0,6,0,23,0,23,'R','D','B',
   '$','B','Y','T','E','S','_','P','E','R','_','C','H','A','R',
   'A','C','T','E','R',1,41,0,0,0,8,0,23,0,17,'R','D','B','$','F',
   'U','N','C','T','I','O','N','_','N','A','M','E',1,41,0,1,0,9,
   0,23,0,15,'R','D','B','$','D','E','S','C','R','I','P','T','I',
   'O','N',1,41,0,11,0,10,0,23,0,15,'R','D','B','$','S','Y','S',
   'T','E','M','_','F','L','A','G',1,41,0,13,0,12,0,23,0,20,'R',
   'D','B','$','C','H','A','R','A','C','T','E','R','_','S','E',
   'T','_','I','D',1,41,0,2,0,14,0,23,0,24,'R','D','B','$','D',
   'E','F','A','U','L','T','_','C','O','L','L','A','T','E','_',
   'N','A','M','E',1,41,0,5,0,15,0,23,0,24,'R','D','B','$','N',
   'U','M','B','E','R','_','O','F','_','C','H','A','R','A','C',
   'T','E','R','S',1,41,0,3,0,16,0,23,0,15,'R','D','B','$','F',
   'O','R','M','_','O','F','_','U','S','E',1,41,0,4,0,17,0,23,0,
   22,'R','D','B','$','C','H','A','R','A','C','T','E','R','_','S',
   'E','T','_','N','A','M','E',-1,-1,'L'
   };	/* end of blr string for request isc_719 */

static const short
   isc_739l = 141;
static const char
   isc_739 [] = {
   4,2,4,1,1,0,7,0,4,0,2,0,41,3,0,32,0,41,3,0,32,0,12,0,2,7,'C',
   1,'J',19,'R','D','B','$','R','E','L','A','T','I','O','N','_',
   'F','I','E','L','D','S',0,'D',21,8,0,1,0,0,0,'G',58,47,23,0,
   17,'R','D','B','$','R','E','L','A','T','I','O','N','_','N','A',
   'M','E',25,0,1,0,47,23,0,14,'R','D','B','$','F','I','E','L',
   'D','_','N','A','M','E',25,0,0,0,-1,14,1,2,1,21,8,0,1,0,0,0,
   25,1,0,0,-1,14,1,1,21,8,0,0,0,0,0,25,1,0,0,-1,-1,'L'
   };	/* end of blr string for request isc_739 */

static const short
   isc_745l = 107;
static const char
   isc_745 [] = {
   4,2,4,1,1,0,7,0,4,0,1,0,41,3,0,32,0,12,0,2,7,'C',1,'J',13,'R',
   'D','B','$','R','E','L','A','T','I','O','N','S',0,'D',21,8,0,
   1,0,0,0,'G',47,23,0,17,'R','D','B','$','R','E','L','A','T','I',
   'O','N','_','N','A','M','E',25,0,0,0,-1,14,1,2,1,21,8,0,1,0,
   0,0,25,1,0,0,-1,14,1,1,21,8,0,0,0,0,0,25,1,0,0,-1,-1,'L'
   };	/* end of blr string for request isc_745 */

static const short
   isc_750l = 75;
static const char
   isc_750 [] = {
   4,2,4,0,2,0,41,0,0,0,1,8,0,12,0,15,'J',9,'R','D','B','$','F',
   'I','L','E','S',0,2,1,25,0,1,0,23,0,14,'R','D','B','$','F','I',
   'L','E','_','S','T','A','R','T',1,25,0,0,0,23,0,13,'R','D','B',
   '$','F','I','L','E','_','N','A','M','E',-1,-1,'L'
   };	/* end of blr string for request isc_750 */

static const short
   isc_754l = 152;
static const char
   isc_754 [] = {
   4,2,4,2,1,0,7,0,4,1,1,0,41,3,0,32,0,4,0,2,0,41,3,0,32,0,7,0,
   2,7,'C',1,'J',12,'R','D','B','$','D','A','T','A','B','A','S',
   'E',0,-1,2,14,0,2,1,23,0,18,'R','D','B','$','S','E','C','U',
   'R','I','T','Y','_','C','L','A','S','S',25,0,0,0,1,21,8,0,1,
   0,0,0,25,0,1,0,-1,17,0,9,13,12,2,18,0,12,1,11,10,0,1,2,1,25,
   1,0,0,23,1,18,'R','D','B','$','S','E','C','U','R','I','T','Y',
   '_','C','L','A','S','S',-1,-1,-1,14,0,1,21,8,0,0,0,0,0,25,0,
   1,0,-1,-1,'L'
   };	/* end of blr string for request isc_754 */

static const short
   isc_762l = 243;
static const char
   isc_762 [] = {
   4,2,4,3,1,0,7,0,4,2,1,0,41,3,0,32,0,4,1,4,0,41,3,0,32,0,41,3,
   0,32,0,41,3,0,32,0,7,0,4,0,1,0,41,3,0,32,0,12,0,2,7,'C',1,'J',
   13,'R','D','B','$','R','E','L','A','T','I','O','N','S',0,'G',
   47,23,0,17,'R','D','B','$','R','E','L','A','T','I','O','N','_',
   'N','A','M','E',25,0,0,0,-1,2,14,1,2,1,23,0,17,'R','D','B','$',
   'D','E','F','A','U','L','T','_','C','L','A','S','S',25,1,0,0,
   1,23,0,18,'R','D','B','$','S','E','C','U','R','I','T','Y','_',
   'C','L','A','S','S',25,1,1,0,1,23,0,14,'R','D','B','$','O','W',
   'N','E','R','_','N','A','M','E',25,1,2,0,1,21,8,0,1,0,0,0,25,
   1,3,0,-1,17,0,9,13,12,3,18,0,12,2,11,10,0,1,2,1,25,2,0,0,23,
   1,14,'R','D','B','$','O','W','N','E','R','_','N','A','M','E',
   -1,-1,-1,14,1,1,21,8,0,0,0,0,0,25,1,3,0,-1,-1,'L'
   };	/* end of blr string for request isc_762 */

static const short
   isc_774l = 215;
static const char
   isc_774 [] = {
   4,2,4,3,1,0,7,0,4,2,1,0,41,3,0,32,0,4,1,3,0,41,3,0,32,0,41,3,
   0,32,0,7,0,4,0,1,0,41,3,0,32,0,12,0,2,7,'C',1,'J',14,'R','D',
   'B','$','P','R','O','C','E','D','U','R','E','S',0,'G',47,23,
   0,18,'R','D','B','$','P','R','O','C','E','D','U','R','E','_',
   'N','A','M','E',25,0,0,0,-1,2,14,1,2,1,23,0,18,'R','D','B','$',
   'S','E','C','U','R','I','T','Y','_','C','L','A','S','S',25,1,
   0,0,1,23,0,14,'R','D','B','$','O','W','N','E','R','_','N','A',
   'M','E',25,1,1,0,1,21,8,0,1,0,0,0,25,1,2,0,-1,17,0,9,13,12,3,
   18,0,12,2,11,10,0,1,2,1,25,2,0,0,23,1,14,'R','D','B','$','O',
   'W','N','E','R','_','N','A','M','E',-1,-1,-1,14,1,1,21,8,0,0,
   0,0,0,25,1,2,0,-1,-1,'L'
   };	/* end of blr string for request isc_774 */

static const short
   isc_785l = 178;
static const char
   isc_785 [] = {
   4,2,4,3,1,0,7,0,4,2,1,0,7,0,4,1,2,0,7,0,7,0,4,0,1,0,41,3,0,32,
   0,12,0,2,7,'C',1,'J',11,'R','D','B','$','I','N','D','I','C',
   'E','S',0,'G',47,23,0,14,'R','D','B','$','I','N','D','E','X',
   '_','N','A','M','E',25,0,0,0,-1,2,14,1,2,1,21,8,0,1,0,0,0,25,
   1,0,0,1,23,0,18,'R','D','B','$','I','N','D','E','X','_','I',
   'N','A','C','T','I','V','E',25,1,1,0,-1,17,0,9,13,12,3,18,0,
   12,2,10,0,1,2,1,25,2,0,0,23,1,18,'R','D','B','$','I','N','D',
   'E','X','_','I','N','A','C','T','I','V','E',-1,-1,-1,14,1,1,
   21,8,0,0,0,0,0,25,1,0,0,-1,-1,'L'
   };	/* end of blr string for request isc_785 */

static const short
   isc_795l = 218;
static const char
   isc_795 [] = {
   4,2,4,1,2,0,41,3,0,32,0,7,0,4,0,2,0,41,0,0,12,0,7,0,12,0,2,7,
   'C',2,'J',24,'R','D','B','$','R','E','L','A','T','I','O','N',
   '_','C','O','N','S','T','R','A','I','N','T','S',0,'J',11,'R',
   'D','B','$','I','N','D','I','C','E','S',1,'G',58,47,23,0,19,
   'R','D','B','$','C','O','N','S','T','R','A','I','N','T','_',
   'T','Y','P','E',25,0,0,0,58,47,23,0,14,'R','D','B','$','I','N',
   'D','E','X','_','N','A','M','E',23,1,14,'R','D','B','$','I',
   'N','D','E','X','_','N','A','M','E',47,23,1,18,'R','D','B','$',
   'I','N','D','E','X','_','I','N','A','C','T','I','V','E',25,0,
   1,0,-1,14,1,2,1,23,1,14,'R','D','B','$','I','N','D','E','X',
   '_','N','A','M','E',25,1,0,0,1,21,8,0,1,0,0,0,25,1,1,0,-1,14,
   1,1,21,8,0,0,0,0,0,25,1,1,0,-1,-1,'L'
   };	/* end of blr string for request isc_795 */

static const short
   isc_802l = 267;
static const char
   isc_802 [] = {
   4,2,4,4,1,0,7,0,4,3,1,0,7,0,4,2,1,0,7,0,4,1,3,0,41,3,0,32,0,
   7,0,7,0,4,0,1,0,7,0,12,0,2,7,'C',1,'J',11,'R','D','B','$','I',
   'N','D','I','C','E','S',0,'G',58,47,23,0,18,'R','D','B','$',
   'I','N','D','E','X','_','I','N','A','C','T','I','V','E',25,0,
   0,0,61,23,0,15,'R','D','B','$','F','O','R','E','I','G','N','_',
   'K','E','Y',-1,2,14,1,2,1,23,0,14,'R','D','B','$','I','N','D',
   'E','X','_','N','A','M','E',25,1,0,0,1,21,8,0,1,0,0,0,25,1,1,
   0,1,23,0,18,'R','D','B','$','I','N','D','E','X','_','I','N',
   'A','C','T','I','V','E',25,1,2,0,-1,17,0,9,13,12,3,18,0,12,2,
   11,10,0,2,2,1,25,2,0,0,23,2,18,'R','D','B','$','I','N','D','E',
   'X','_','I','N','A','C','T','I','V','E',-1,12,4,11,10,0,1,2,
   1,25,4,0,0,23,1,18,'R','D','B','$','I','N','D','E','X','_','I',
   'N','A','C','T','I','V','E',-1,-1,-1,14,1,1,21,8,0,0,0,0,0,25,
   1,1,0,-1,-1,'L'
   };	/* end of blr string for request isc_802 */

static const short
   isc_815l = 178;
static const char
   isc_815 [] = {
   4,2,4,3,1,0,7,0,4,2,1,0,7,0,4,1,2,0,7,0,7,0,4,0,1,0,41,3,0,32,
   0,12,0,2,7,'C',1,'J',11,'R','D','B','$','I','N','D','I','C',
   'E','S',0,'G',47,23,0,14,'R','D','B','$','I','N','D','E','X',
   '_','N','A','M','E',25,0,0,0,-1,2,14,1,2,1,21,8,0,1,0,0,0,25,
   1,0,0,1,23,0,18,'R','D','B','$','I','N','D','E','X','_','I',
   'N','A','C','T','I','V','E',25,1,1,0,-1,17,0,9,13,12,3,18,0,
   12,2,10,0,1,2,1,25,2,0,0,23,1,18,'R','D','B','$','I','N','D',
   'E','X','_','I','N','A','C','T','I','V','E',-1,-1,-1,14,1,1,
   21,8,0,0,0,0,0,25,1,0,0,-1,-1,'L'
   };	/* end of blr string for request isc_815 */


#define gds_blob_null	isc_blob_null	/* compatibility symbols */
#define gds_status	isc_status
#define gds_status2	isc_status2
#define gds_array_length	isc_array_length
#define gds_count	isc_count
#define gds_slack	isc_slack
#define gds_utility	isc_utility	/* end of compatibility symbols */

#ifndef isc_version4
    Generate a compile-time error.
    Picking up a V3 include file after preprocessing with V4 GPRE.
#endif

/**** end of GPRE definitions ****/


#define DB			tdgbl->db_handle
#define gds_trans	tdgbl->tr_handle
#define isc_status	tdgbl->status_vector


namespace // unnamed, private
{


const int DB_VERSION_DDL4		= 40;  // ods4 db
const int DB_VERSION_DDL5		= 50;  // ods5 db
const int DB_VERSION_DDL8		= 80;  // ods8 db, IB4
const int DB_VERSION_DDL9		= 90;  // ods9 db, IB5
const int DB_VERSION_DDL10		= 100; // ods10 db, IB6, FB1, FB1.5
const int DB_VERSION_DDL11		= 110; // ods11 db, FB2
const int DB_VERSION_DDL11_1	= 111; // ods11.1 db, FB2.1
const int DB_VERSION_DDL11_2	= 112; // ods11.2 db, FB2.5

const int DB_VERSION_OLDEST_SUPPORTED = DB_VERSION_DDL8;  // IB4.0 is ods8

const int DEFERRED_ACTIVE		= 3;	// RDB$INDEX_INACTIVE setting for Foreign Keys
										// This setting is used temporarily while
										// restoring a database. This was required
										// in order to differentiate a partial
										// "inactive" state of SOME indices from
										// "inactive" state of ALL indices (gbak -i)
										// -bsriram, 11-May-1999      BUG: 10016


const int RESTORE_VERBOSE_INTERVAL	= 10000;
const int burp_msg_fac				= 12;

enum scan_attr_t
{
	NO_SKIP		= 0,	// Not in skipping and scanning mode
	BEFORE_SKIP	= 1,	// After skipping, before scanning next byte for valid attribute
	AFTER_SKIP	= 2	// After skipping and after scanning next byte for valid attribute
};

void	add_files(BurpGlobals* tdgbl, const char*);
void	bad_attribute(scan_attr_t, att_type, USHORT);
void	check_db_version(BurpGlobals* tdgbl);
void	create_database(BurpGlobals* tdgbl, const TEXT*);
void	decompress(BurpGlobals* tdgbl, UCHAR*, USHORT);
void	eat_blob(BurpGlobals* tdgbl);
void	eat_text(BurpGlobals* tdgbl);
void	eat_text2(BurpGlobals* tdgbl);
burp_rel*	find_relation(BurpGlobals* tdgbl, const TEXT*);
void	fix_security_class_name(BurpGlobals* tdgbl, TEXT* sec_class, bool is_field);
// CVC: when do these functions return false indeed???
// get_acl and get_index are the only exceptions but ironically their
// returned value is not checked by the caller!
bool	get_acl(BurpGlobals* tdgbl, const TEXT*, ISC_QUAD*, ISC_QUAD*);
void	get_array(BurpGlobals* tdgbl, burp_rel*, UCHAR*);
void	get_blob(BurpGlobals* tdgbl, const burp_fld*, UCHAR*);
void	get_blr_blob(BurpGlobals* tdgbl, ISC_QUAD&, bool);
bool	get_character_set(BurpGlobals* tdgbl);
bool	get_chk_constraint(BurpGlobals* tdgbl);
bool	get_collation(BurpGlobals* tdgbl);
rec_type	get_data(BurpGlobals* tdgbl, burp_rel*);
bool	get_exception(BurpGlobals* tdgbl);
burp_fld*	get_field(BurpGlobals* tdgbl, burp_rel*);
bool	get_field_dimensions(BurpGlobals* tdgbl);
bool	get_files(BurpGlobals* tdgbl);
bool	get_filter(BurpGlobals* tdgbl);
bool	get_function(BurpGlobals* tdgbl);
void	get_function_arg(BurpGlobals* tdgbl, bool skip_arguments);
bool	get_generator(BurpGlobals* tdgbl);
bool	get_global_field(BurpGlobals* tdgbl);
bool	get_index(BurpGlobals* tdgbl, const burp_rel*);
void	get_misc_blob(BurpGlobals* tdgbl, ISC_QUAD&, bool);
SLONG	get_numeric(BurpGlobals* tdgbl);
SINT64  get_int64(BurpGlobals* tdgbl);
bool	get_procedure(BurpGlobals* tdgbl);
bool	get_procedure_prm (BurpGlobals* tdgbl, GDS_NAME );
bool	get_ref_constraint(BurpGlobals* tdgbl);
bool	get_rel_constraint(BurpGlobals* tdgbl);
bool	get_relation(BurpGlobals* tdgbl);
bool	get_relation_data(BurpGlobals* tdgbl);
bool	get_sql_roles(BurpGlobals* tdgbl);
bool	get_mapping(BurpGlobals* tdgbl);
bool	get_security_class(BurpGlobals* tdgbl);
void	get_source_blob(BurpGlobals* tdgbl, ISC_QUAD&, bool);
USHORT	get_text(BurpGlobals* tdgbl, TEXT*, ULONG);
USHORT	get_text2(BurpGlobals* tdgbl, TEXT* text, ULONG length);
bool	get_trigger(BurpGlobals* tdgbl);
bool	get_trigger_message(BurpGlobals* tdgbl);
bool	get_trigger_old (BurpGlobals* tdgbl, burp_rel*);
bool	get_type(BurpGlobals* tdgbl);
bool	get_user_privilege(BurpGlobals* tdgbl);
bool	get_view(BurpGlobals* tdgbl, burp_rel*);
void	ignore_array(BurpGlobals* tdgbl, burp_rel*);
void	ignore_blob(BurpGlobals* tdgbl);
rec_type	ignore_data(BurpGlobals* tdgbl, burp_rel*);
void	realign(BurpGlobals* tdgbl, UCHAR*, const burp_rel*);
#ifdef sparc
USHORT	recompute_length(BurpGlobals* tdgbl, burp_rel*);
#endif
bool	restore(BurpGlobals* tdgbl, const TEXT*, const TEXT*);
void	restore_security_class(BurpGlobals* tdgbl, const TEXT*, const TEXT*);
USHORT	get_view_base_relation_count(BurpGlobals* tdgbl, const TEXT*, USHORT);
void	store_blr_gen_id(BurpGlobals* tdgbl, const TEXT*, SINT64, const ISC_QUAD*);
void	update_global_field(BurpGlobals* tdgbl);
void	update_view_dbkey_lengths(BurpGlobals* tdgbl);
void	fix_system_generators(BurpGlobals* tdgbl);
void	general_on_error();
#ifdef DEBUG
UCHAR	debug_on = 0;   // able to turn this on in the debugger
#endif

#ifdef sparc
const SSHORT old_sparcs[] =
    {0, 0, 0, 2, 0, 0, 0, 0, 2, 4, 4, 4, 8, 8, 0, 0, 8, 8, 8};
#endif

//MVOL_read returns int
static inline int get(BurpGlobals* tdgbl)
{
	if (--(tdgbl->io_cnt) >= 0)
		return *(tdgbl->io_ptr)++;

	return MVOL_read(&tdgbl->io_cnt, &tdgbl->io_ptr);
}

static inline att_type get_attribute(att_type* att, BurpGlobals* tdgbl)
{
	*att = (att_type) get(tdgbl);
	return *att;
}

static inline rec_type get_record(rec_type *rec, BurpGlobals* tdgbl)
{
	*rec = (rec_type) get(tdgbl);
	return *rec;
}

#define GET_TEXT(text)	get_text(tdgbl, (text), sizeof(text))
#define GET_TEXT2(text)	get_text2(tdgbl, (text), sizeof(text))

static inline void get_skip(BurpGlobals* tdgbl, ULONG n)
{
	MVOL_skip_block(tdgbl, n);
}

static inline UCHAR* get_block(BurpGlobals* tdgbl, UCHAR* p, ULONG n)
{
	return MVOL_read_block(tdgbl, p, n);
}

// When skipping started, scan_next_attr will be changed from NO_SKIP
// to BEFORE_SKIP. When scanning for next valid attribute after skipping,
// it will flip-flop between BEFORE_SKIP and AFTER_SKIP. When next valid
// attribute is found, it will be changed back to NO_SKIP by 'skip_scan'

static inline void skip_init(scan_attr_t* scan_next_attr)
{
	*scan_next_attr = NO_SKIP;
}

static inline void skip_scan(scan_attr_t* scan_next_attr)
{
	if (*scan_next_attr == AFTER_SKIP)
		*scan_next_attr = BEFORE_SKIP;
	else if (*scan_next_attr == BEFORE_SKIP)
		*scan_next_attr = NO_SKIP;
	//else 0; => nothing, no change in the original macro
}

// User Privilege Flags

const int USER_PRIV_USER			= 1;
const int USER_PRIV_GRANTOR			= 2;
const int USER_PRIV_PRIVILEGE		= 4;
const int USER_PRIV_GRANT_OPTION	= 8;
const int USER_PRIV_OBJECT_NAME		= 16;
const int USER_PRIV_FIELD_NAME		= 32;
const int USER_PRIV_USER_TYPE		= 64;
const int USER_PRIV_OBJECT_TYPE		= 128;

} // namespace


int RESTORE_restore (const TEXT* file_name, const TEXT* database_name)
{
   struct isc_760_struct {
          short isc_761;	/* isc_utility */
   } isc_760;
   struct isc_758_struct {
          char  isc_759 [32];	/* RDB$SECURITY_CLASS */
   } isc_758;
   struct isc_755_struct {
          char  isc_756 [32];	/* RDB$SECURITY_CLASS */
          short isc_757;	/* isc_utility */
   } isc_755;
   struct isc_772_struct {
          short isc_773;	/* isc_utility */
   } isc_772;
   struct isc_770_struct {
          char  isc_771 [32];	/* RDB$OWNER_NAME */
   } isc_770;
   struct isc_765_struct {
          char  isc_766 [32];	/* RDB$DEFAULT_CLASS */
          char  isc_767 [32];	/* RDB$SECURITY_CLASS */
          char  isc_768 [32];	/* RDB$OWNER_NAME */
          short isc_769;	/* isc_utility */
   } isc_765;
   struct isc_763_struct {
          char  isc_764 [32];	/* RDB$RELATION_NAME */
   } isc_763;
   struct isc_783_struct {
          short isc_784;	/* isc_utility */
   } isc_783;
   struct isc_781_struct {
          char  isc_782 [32];	/* RDB$OWNER_NAME */
   } isc_781;
   struct isc_777_struct {
          char  isc_778 [32];	/* RDB$SECURITY_CLASS */
          char  isc_779 [32];	/* RDB$OWNER_NAME */
          short isc_780;	/* isc_utility */
   } isc_777;
   struct isc_775_struct {
          char  isc_776 [32];	/* RDB$PROCEDURE_NAME */
   } isc_775;
   struct isc_793_struct {
          short isc_794;	/* isc_utility */
   } isc_793;
   struct isc_791_struct {
          short isc_792;	/* RDB$INDEX_INACTIVE */
   } isc_791;
   struct isc_788_struct {
          short isc_789;	/* isc_utility */
          short isc_790;	/* RDB$INDEX_INACTIVE */
   } isc_788;
   struct isc_786_struct {
          char  isc_787 [32];	/* RDB$INDEX_NAME */
   } isc_786;
   struct isc_799_struct {
          char  isc_800 [32];	/* RDB$INDEX_NAME */
          short isc_801;	/* isc_utility */
   } isc_799;
   struct isc_796_struct {
          char  isc_797 [12];	/* RDB$CONSTRAINT_TYPE */
          short isc_798;	/* RDB$INDEX_INACTIVE */
   } isc_796;
   struct isc_813_struct {
          short isc_814;	/* RDB$INDEX_INACTIVE */
   } isc_813;
   struct isc_811_struct {
          short isc_812;	/* isc_utility */
   } isc_811;
   struct isc_809_struct {
          short isc_810;	/* RDB$INDEX_INACTIVE */
   } isc_809;
   struct isc_805_struct {
          char  isc_806 [32];	/* RDB$INDEX_NAME */
          short isc_807;	/* isc_utility */
          short isc_808;	/* RDB$INDEX_INACTIVE */
   } isc_805;
   struct isc_803_struct {
          short isc_804;	/* RDB$INDEX_INACTIVE */
   } isc_803;
   struct isc_823_struct {
          short isc_824;	/* isc_utility */
   } isc_823;
   struct isc_821_struct {
          short isc_822;	/* RDB$INDEX_INACTIVE */
   } isc_821;
   struct isc_818_struct {
          short isc_819;	/* isc_utility */
          short isc_820;	/* RDB$INDEX_INACTIVE */
   } isc_818;
   struct isc_816_struct {
          char  isc_817 [32];	/* RDB$INDEX_NAME */
   } isc_816;
/**************************************
 *
 *	R E S T O R E _ r e s t o r e
 *
 **************************************
 *
 * Functional description
 *	Recreate a database from a backup.
 *
 **************************************/
	isc_req_handle  req_handle1 = 0, req_handle2 = 0, req_handle3 = 0;
	isc_req_handle	req_handle4 = 0, req_handle5 = 0;
	/*BASED_ON RDB$INDICES.RDB$INDEX_NAME index_name;*/
	char
	   index_name[32];


	BurpGlobals* tdgbl = BurpGlobals::getSpecific();

	tdgbl->io_ptr = NULL;
	tdgbl->io_cnt = 0;

	tdgbl->relations = NULL;
	tdgbl->procedures = NULL;
	tdgbl->RESTORE_format = 0;
	tdgbl->RESTORE_ods = 0;
	tdgbl->global_trans = 0;

	tdgbl->gbl_sw_transportable = tdgbl->gbl_sw_compress = false;

	if (!restore(tdgbl, file_name, database_name))
		return FINI_ERROR;

	BURP_verbose (76);
	// msg 76 creating indexes

	/*COMMIT;*/
	{
	isc_commit_transaction (isc_status, (FB_API_HANDLE*) &gds_trans);;
	/*ON_ERROR*/
	if (isc_status [1])
	   {
		// Fix for bug_no 8055:
		// don't throw away the database just because an index
		// could not be made
		long error_code;
		while (error_code = tdgbl->status_vector[1])
		{
			switch (error_code)
			{
				case isc_sort_mem_err:
				case isc_no_dup:
					strcpy(index_name, (TEXT *)tdgbl->status_vector[3]);
					BURP_print_status(false, tdgbl->status_vector);
					/*FOR (REQUEST_HANDLE req_handle3)
						IDX IN RDB$INDICES WITH IDX.RDB$INDEX_NAME EQ index_name*/
					{
                                        if (!req_handle3)
                                           isc_compile_request (NULL, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &req_handle3, (short) sizeof(isc_815), (char*) isc_815);
					isc_vtov ((const char*) index_name, (char*) isc_816.isc_817, 32);
                                        isc_start_and_send (NULL, (FB_API_HANDLE*) &req_handle3, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 32, &isc_816, (short) 0);
					while (1)
					   {
                                           isc_receive (NULL, (FB_API_HANDLE*) &req_handle3, (short) 1, (short) 4, &isc_818, (short) 0);
					   if (!isc_818.isc_819) break;

						BURP_verbose(243, index_name);
						/*MODIFY IDX USING*/
						{
							/*IDX.RDB$INDEX_INACTIVE*/
							isc_818.isc_820 = TRUE;
						/*END_MODIFY;*/
						isc_821.isc_822 = isc_818.isc_820;
                                                isc_send (NULL, (FB_API_HANDLE*) &req_handle3, (short) 2, (short) 2, &isc_821, (short) 0);
						}
						BURP_print(false, 240, index_name);
						// msg 240 Index \"%s\" failed to activate because:
						if ( error_code == isc_no_dup )
						{
							BURP_print(false, 241);
							// msg 241 The unique index has duplicate values or NULLs
							BURP_print(false, 242);
							// msg 242 Delete or Update duplicate values or NULLs, and activate index with
						}
						else
						{
							BURP_print(false, 244);
							// msg 244 Not enough disk space to create the sort file for an index
							BURP_print(false, 245);
							// msg 245 Set the TMP environment variable to a directory on a filesystem that does have enough space, and activate index with
						}
						BURP_print(false, 243, index_name);
						// msg 243 ALTER INDEX \"%s\" ACTIVE;
					/*END_FOR;*/
                                           isc_send (NULL, (FB_API_HANDLE*) &req_handle3, (short) 3, (short) 2, &isc_823, (short) 0);
					   }
					}
					// don't bring the database on-line
					tdgbl->flag_on_line = false;
					break;
				default:
					general_on_error ();
				break;
			}
			/*COMMIT*/
			{
			isc_commit_transaction (isc_status, (FB_API_HANDLE*) &gds_trans);;
			/*ON_ERROR*/
			if (isc_status [1])
			   {
				continue;
			/*END_ERROR*/
			   }
			}
		}
	/*END_ERROR;*/
	   }
	}

	// Activate the indices for foreign keys and do another commit
	if (!tdgbl->gbl_sw_deactivate_indexes)
	{

		// Block added to verbose index creation by Toni Martir
		// Always try to activate deferred indices - it helps for some broken backups,
		// and in normal cases doesn't take much time to look for such indices. AP-2008.
		/*EXEC SQL SET TRANSACTION ISOLATION LEVEL READ COMMITTED NO_AUTO_UNDO;*/
		{
		isc_start_transaction (isc_status, (FB_API_HANDLE*) &gds_trans, (short) 1, &DB, (short) 6, isc_tpb_0);
		SQLCODE = isc_sqlcode(isc_status);
		}
		if (gds_status[1])
			/*EXEC SQL SET TRANSACTION;*/
			{
			isc_start_transaction (isc_status, (FB_API_HANDLE*) &gds_trans, (short) 1, &DB, (short) 4, isc_tpb_1);
			SQLCODE = isc_sqlcode(isc_status);
			}

		// Activate first indexes that are not foreign keys
		/*FOR (REQUEST_HANDLE req_handle1) IDS IN RDB$INDICES WITH
			IDS.RDB$INDEX_INACTIVE EQ DEFERRED_ACTIVE AND
			IDS.RDB$FOREIGN_KEY MISSING*/
		{
                if (!req_handle1)
                   isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &req_handle1, (short) sizeof(isc_802), (char*) isc_802);
		isc_803.isc_804 = DEFERRED_ACTIVE;
		if (req_handle1)
		   {
                   isc_start_and_send (isc_status, (FB_API_HANDLE*) &req_handle1, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 2, &isc_803, (short) 0);
		   }
		if (!isc_status [1]) {
		while (1)
		   {
                   isc_receive (isc_status, (FB_API_HANDLE*) &req_handle1, (short) 1, (short) 36, &isc_805, (short) 0);
		   if (!isc_805.isc_807 || isc_status [1]) break;

			MISC_terminate(/*IDS.RDB$INDEX_NAME*/
				       isc_805.isc_806, index_name,
				(ULONG) MISC_symbol_length(/*IDS.RDB$INDEX_NAME*/
							   isc_805.isc_806, sizeof(/*IDS.RDB$INDEX_NAME*/
	 isc_805.isc_806)),
				sizeof(index_name));
			BURP_verbose(285, index_name);
			// activating and creating deferred index %s
			/*MODIFY IDS USING*/
			{
				/*IDS.RDB$INDEX_INACTIVE*/
				isc_805.isc_808 = FALSE;
			/*END_MODIFY;*/
			isc_813.isc_814 = isc_805.isc_808;
                        isc_send (isc_status, (FB_API_HANDLE*) &req_handle1, (short) 4, (short) 2, &isc_813, (short) 0);;
			/*ON_ERROR*/
			if (isc_status [1])
			   {
				general_on_error();
			/*END_ERROR;*/
			   }
			}

			/*SAVE*/
			{
			isc_commit_retaining (isc_status, (FB_API_HANDLE*) &gds_trans);;
			// existing ON_ERROR continues past error, beck
			/*ON_ERROR*/
			if (isc_status [1])
			   {
				BURP_print (false, 173, index_name);
				BURP_print_status(false, isc_status);
				/*MODIFY IDS USING*/
				{
					/*IDS.RDB$INDEX_INACTIVE*/
					isc_805.isc_808 = TRUE;
				/*END_MODIFY;*/
				isc_809.isc_810 = isc_805.isc_808;
                                isc_send (isc_status, (FB_API_HANDLE*) &req_handle1, (short) 2, (short) 2, &isc_809, (short) 0);;
				/*ON_ERROR*/
				if (isc_status [1])
				   {
					general_on_error ();
				/*END_ERROR;*/
				   }
				}
				tdgbl->flag_on_line = false;
			/*END_ERROR;*/
			   }
			}
		/*END_FOR;*/
                   isc_send (isc_status, (FB_API_HANDLE*) &req_handle1, (short) 3, (short) 2, &isc_811, (short) 0);
		   }
		   };
		/*ON_ERROR*/
		if (isc_status [1])
		   {
			general_on_error ();
		/*END_ERROR;*/
		   }
		}
		MISC_release_request_silent(req_handle1);
		/*COMMIT;*/
		{
		isc_commit_transaction (isc_status, (FB_API_HANDLE*) &gds_trans);;
		/*ON_ERROR*/
		if (isc_status [1])
		   {
			general_on_error ();
		/*END_ERROR;*/
		   }
		}

		/*EXEC SQL SET TRANSACTION ISOLATION LEVEL READ COMMITTED NO_AUTO_UNDO;*/
		{
		isc_start_transaction (isc_status, (FB_API_HANDLE*) &gds_trans, (short) 1, &DB, (short) 6, isc_tpb_2);
		SQLCODE = isc_sqlcode(isc_status);
		}
		if (gds_status[1])
			/*EXEC SQL SET TRANSACTION;*/
			{
			isc_start_transaction (isc_status, (FB_API_HANDLE*) &gds_trans, (short) 1, &DB, (short) 4, isc_tpb_3);
			SQLCODE = isc_sqlcode(isc_status);
			}

		// Only activate Foreign keys that have been marked for deferred
		// activation.
		// -bsriram, 11-May-1999             BUG: 10016

		// In case error happens creating FK, triggers don't let set
		// INACTIVE = TRUE for FK index. Therefore use separate
		// transaction be able to rollback when needed.
		// AP, 2005

		/*FOR (REQUEST_HANDLE req_handle1)
			CNST IN RDB$RELATION_CONSTRAINTS
			CROSS IDS IN RDB$INDICES WITH
			CNST.RDB$CONSTRAINT_TYPE EQ FOREIGN_KEY AND
			CNST.RDB$INDEX_NAME EQ IDS.RDB$INDEX_NAME AND
			IDS.RDB$INDEX_INACTIVE EQ DEFERRED_ACTIVE*/
		{
                if (!req_handle1)
                   isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &req_handle1, (short) sizeof(isc_795), (char*) isc_795);
		isc_vtov ((const char*) FOREIGN_KEY, (char*) isc_796.isc_797, 12);
		isc_796.isc_798 = DEFERRED_ACTIVE;
		if (req_handle1)
		   {
                   isc_start_and_send (isc_status, (FB_API_HANDLE*) &req_handle1, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 14, &isc_796, (short) 0);
		   }
		if (!isc_status [1]) {
		while (1)
		   {
                   isc_receive (isc_status, (FB_API_HANDLE*) &req_handle1, (short) 1, (short) 34, &isc_799, (short) 0);
		   if (!isc_799.isc_801 || isc_status [1]) break;

			MISC_terminate(/*IDS.RDB$INDEX_NAME*/
				       isc_799.isc_800, index_name,
				(ULONG) MISC_symbol_length(/*IDS.RDB$INDEX_NAME*/
							   isc_799.isc_800, sizeof(/*IDS.RDB$INDEX_NAME*/
	 isc_799.isc_800)),
				sizeof(index_name));
			BURP_verbose(285, index_name);
			// activating and creating deferred index %s

			bool fError = false;
			isc_tr_handle activateIndexTran = 0;
			ISC_STATUS_ARRAY local_status_vector;
			ISC_STATUS* local_status = local_status_vector;

			/*START_TRANSACTION activateIndexTran;*/
			{
			isc_start_transaction (NULL, (FB_API_HANDLE*) &activateIndexTran, (short) 1, &DB, (short) 4, isc_tpb_4);
			}
			/*FOR (TRANSACTION_HANDLE activateIndexTran REQUEST_HANDLE req_handle5)
				IND1 IN RDB$INDICES WITH IND1.RDB$INDEX_NAME EQ IDS.RDB$INDEX_NAME*/
			{
                        if (!req_handle5)
                           isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &req_handle5, (short) sizeof(isc_785), (char*) isc_785);
			isc_vtov ((const char*) isc_799.isc_800, (char*) isc_786.isc_787, 32);
			if (req_handle5)
			   {
                           isc_start_and_send (isc_status, (FB_API_HANDLE*) &req_handle5, (FB_API_HANDLE*) &activateIndexTran, (short) 0, (short) 32, &isc_786, (short) 0);
			   }
			if (!isc_status [1]) {
			while (1)
			   {
                           isc_receive (isc_status, (FB_API_HANDLE*) &req_handle5, (short) 1, (short) 4, &isc_788, (short) 0);
			   if (!isc_788.isc_789 || isc_status [1]) break;
				/*MODIFY IND1 USING*/
				{
						/*IND1.RDB$INDEX_INACTIVE*/
						isc_788.isc_790 = FALSE;
				/*END_MODIFY;*/
				isc_791.isc_792 = isc_788.isc_790;
                                isc_send (NULL, (FB_API_HANDLE*) &req_handle5, (short) 2, (short) 2, &isc_791, (short) 0);
				}
			/*END_FOR;*/
                           isc_send (isc_status, (FB_API_HANDLE*) &req_handle5, (short) 3, (short) 2, &isc_793, (short) 0);
			   }
			   };
			/*ON_ERROR*/
			if (isc_status [1])
			   {
				fError = true;
				memcpy(local_status, isc_status, sizeof (ISC_STATUS_ARRAY));
			/*END_ERROR;*/
			   }
			}
			MISC_release_request_silent(req_handle5);

			if (!fError)
			{
				/*COMMIT activateIndexTran;*/
				{
				isc_commit_transaction (isc_status, (FB_API_HANDLE*) &activateIndexTran);;
				/*ON_ERROR*/
				if (isc_status [1])
				   {
					fError = true;
					memcpy(local_status, isc_status, sizeof (ISC_STATUS_ARRAY));
				/*END_ERROR;*/
				   }
				}
			}
			if (fError)
			{
				/*ROLLBACK activateIndexTran;*/
				{
				isc_rollback_transaction (isc_status, (FB_API_HANDLE*) &activateIndexTran);;
				/*ON_ERROR*/
				if (isc_status [1])
				   {
					general_on_error ();
				/*END_ERROR;*/
				   }
				}
				BURP_print (false, 173, index_name);
				BURP_print_status(false, local_status);
				tdgbl->flag_on_line = false;
			}
		/*END_FOR;*/
		   }
		   };
		/*ON_ERROR*/
		if (isc_status [1])
		   {
			general_on_error ();
		/*END_ERROR;*/
		   }
		}
		MISC_release_request_silent(req_handle1);
		/*COMMIT;*/
		{
		isc_commit_transaction (isc_status, (FB_API_HANDLE*) &gds_trans);;
		/*ON_ERROR*/
		if (isc_status [1])
		   {
			general_on_error ();
		/*END_ERROR;*/
		   }
		}
	}

	if (tdgbl->global_trans)
	{
		BURP_verbose (68);
		// msg 68 committing meta data
		/*EXEC SQL COMMIT TRANSACTION tdgbl->global_trans;*/
		{
		isc_commit_transaction (isc_status, (FB_API_HANDLE*) &tdgbl->global_trans);
		SQLCODE = isc_sqlcode(isc_status);
		}
		if (gds_status[1])
			general_on_error ();
		// Check to see if there is a warning
		if (gds_status[0] == isc_arg_gds && gds_status[1] == 0 && gds_status[2] != isc_arg_end)
		{
			BURP_print_warning(gds_status);
		}
	}

	/*EXEC SQL SET TRANSACTION ISOLATION LEVEL READ COMMITTED NO_AUTO_UNDO;*/
	{
	isc_start_transaction (isc_status, (FB_API_HANDLE*) &gds_trans, (short) 1, &DB, (short) 6, isc_tpb_5);
	SQLCODE = isc_sqlcode(isc_status);
	}
	if (gds_status[1])
		/*EXEC SQL SET TRANSACTION;*/
		{
		isc_start_transaction (isc_status, (FB_API_HANDLE*) &gds_trans, (short) 1, &DB, (short) 4, isc_tpb_6);
		SQLCODE = isc_sqlcode(isc_status);
		}

	// AB: Recalculate RDB$DBKEY_LENGTH for VIEWS
	// When VIEWs are not processed in correct dependency order
	// then on create time it doesn't know anything from the
	// VIEW that's referenced.
	//
	update_view_dbkey_lengths(tdgbl);

	// Change ownership of any procedures necessary

	for (burp_prc* procedure = tdgbl->procedures; procedure; procedure = procedure->prc_next)
	{
		if (procedure->prc_owner[0])
		{
			/*FOR (REQUEST_HANDLE req_handle4)
				X IN RDB$PROCEDURES WITH X.RDB$PROCEDURE_NAME EQ procedure->prc_name*/
			{
                        if (!req_handle4)
                           isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &req_handle4, (short) sizeof(isc_774), (char*) isc_774);
			isc_vtov ((const char*) procedure->prc_name, (char*) isc_775.isc_776, 32);
			if (req_handle4)
			   {
                           isc_start_and_send (isc_status, (FB_API_HANDLE*) &req_handle4, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 32, &isc_775, (short) 0);
			   }
			if (!isc_status [1]) {
			while (1)
			   {
                           isc_receive (isc_status, (FB_API_HANDLE*) &req_handle4, (short) 1, (short) 66, &isc_777, (short) 0);
			   if (!isc_777.isc_780 || isc_status [1]) break;

				/*MODIFY X*/
				{
					strcpy (/*X.RDB$OWNER_NAME*/
						isc_777.isc_779, procedure->prc_owner);
				/*END_MODIFY;*/
				isc_ftof (isc_777.isc_779, 32, isc_781.isc_782, 32);
                                isc_send (isc_status, (FB_API_HANDLE*) &req_handle4, (short) 2, (short) 32, &isc_781, (short) 0);;
				/*ON_ERROR*/
				if (isc_status [1])
				   {
					MISC_release_request_silent(req_handle4);
					general_on_error ();
				/*END_ERROR;*/
				   }
				}

				restore_security_class(tdgbl, procedure->prc_owner, /*X.RDB$SECURITY_CLASS*/
										    isc_777.isc_778);

			/*END_FOR;*/
                           isc_send (isc_status, (FB_API_HANDLE*) &req_handle4, (short) 3, (short) 2, &isc_783, (short) 0);
			   }
			   };
			/*ON_ERROR*/
			if (isc_status [1])
			   {
				MISC_release_request_silent(req_handle4);
				general_on_error ();
			/*END_ERROR;*/
			   }
			}
		}
	}

	MISC_release_request_silent(req_handle4);

	// Change ownership of any relations necessary

	for (burp_rel* relation = tdgbl->relations; relation; relation = relation->rel_next)
	{
		if (relation->rel_owner[0])
		{
			/*FOR (REQUEST_HANDLE req_handle2)
				X IN RDB$RELATIONS WITH X.RDB$RELATION_NAME EQ relation->rel_name*/
			{
                        if (!req_handle2)
                           isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &req_handle2, (short) sizeof(isc_762), (char*) isc_762);
			isc_vtov ((const char*) relation->rel_name, (char*) isc_763.isc_764, 32);
			if (req_handle2)
			   {
                           isc_start_and_send (isc_status, (FB_API_HANDLE*) &req_handle2, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 32, &isc_763, (short) 0);
			   }
			if (!isc_status [1]) {
			while (1)
			   {
                           isc_receive (isc_status, (FB_API_HANDLE*) &req_handle2, (short) 1, (short) 98, &isc_765, (short) 0);
			   if (!isc_765.isc_769 || isc_status [1]) break;
				/*MODIFY X*/
				{
					strcpy (/*X.RDB$OWNER_NAME*/
						isc_765.isc_768, relation->rel_owner);
				/*END_MODIFY;*/
				isc_ftof (isc_765.isc_768, 32, isc_770.isc_771, 32);
                                isc_send (isc_status, (FB_API_HANDLE*) &req_handle2, (short) 2, (short) 32, &isc_770, (short) 0);;
				/*ON_ERROR*/
				if (isc_status [1])
				   {
					MISC_release_request_silent(req_handle2);
					general_on_error ();
				/*END_ERROR;*/
				   }
				}

				restore_security_class(tdgbl, relation->rel_owner, /*X.RDB$SECURITY_CLASS*/
										   isc_765.isc_767);
				restore_security_class(tdgbl, relation->rel_owner, /*X.RDB$DEFAULT_CLASS*/
										   isc_765.isc_766);

			/*END_FOR;*/
                           isc_send (isc_status, (FB_API_HANDLE*) &req_handle2, (short) 3, (short) 2, &isc_772, (short) 0);
			   }
			   };
			/*ON_ERROR*/
			if (isc_status [1])
			   {
				MISC_release_request_silent(req_handle2);
				general_on_error ();
			/*END_ERROR;*/
			   }
			}
		}
	}

	MISC_release_request_silent(req_handle2);

	// Now that changing ownership of tables is over, it is safe to
	// update the database security class in RDB$DATABASE

	if (tdgbl->database_security_class[0]) // Do it only if it's not NULL
	{
		/*FOR (REQUEST_HANDLE req_handle1)
		X IN RDB$DATABASE*/
		{
                if (!req_handle1)
                   isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &req_handle1, (short) sizeof(isc_754), (char*) isc_754);
		if (req_handle1)
		   {
                   isc_start_request (isc_status, (FB_API_HANDLE*) &req_handle1, (FB_API_HANDLE*) &gds_trans, (short) 0);
		   }
		if (!isc_status [1]) {
		while (1)
		   {
                   isc_receive (isc_status, (FB_API_HANDLE*) &req_handle1, (short) 0, (short) 34, &isc_755, (short) 0);
		   if (!isc_755.isc_757 || isc_status [1]) break;
			/*MODIFY X USING*/
			{
				strncpy(/*X.RDB$SECURITY_CLASS*/
					isc_755.isc_756, tdgbl->database_security_class,
					sizeof(/*X.RDB$SECURITY_CLASS*/
					       isc_755.isc_756));
			/*END_MODIFY;*/
			isc_ftof (isc_755.isc_756, 32, isc_758.isc_759, 32);
                        isc_send (isc_status, (FB_API_HANDLE*) &req_handle1, (short) 1, (short) 32, &isc_758, (short) 0);;
			/*ON_ERROR*/
			if (isc_status [1])
			   {
				MISC_release_request_silent(req_handle1);
				general_on_error ();
			/*END_ERROR;*/
			   }
			}
		/*END_FOR;*/
                   isc_send (isc_status, (FB_API_HANDLE*) &req_handle1, (short) 2, (short) 2, &isc_760, (short) 0);
		   }
		   };
		/*ON_ERROR*/
		if (isc_status [1])
		   {
			MISC_release_request_silent(req_handle1);
			general_on_error ();
		/*END_ERROR;*/
		   }
		}

		MISC_release_request_silent(req_handle1);
	}

	// Fix values of system generators.
	fix_system_generators(tdgbl);

	/*COMMIT;*/
	{
	isc_commit_transaction (isc_status, (FB_API_HANDLE*) &gds_trans);;
	/*ON_ERROR*/
	if (isc_status [1])
	   {
		general_on_error ();
	/*END_ERROR;*/
	   }
	}

	// Check to see if there is a warning
	if (gds_status[0] == isc_arg_gds && gds_status[1] == 0 && gds_status[2] != isc_arg_end)
	{
		BURP_print_warning(gds_status);
	}

	BURP_verbose (88);
	// msg 88 finishing, closing, and going home

	//FB_UINT64 cumul_count =
	MVOL_fini_read();

	if (tdgbl->gbl_stat_flags)
		BURP_verbose(369);
	// msg 369 total statistics

	// Close database before we attach to it again.
	/*FINISH*/
	{
	if (DB)
	   isc_detach_database (isc_status, &DB);;
	/*ON_ERROR*/
	if (isc_status [1])
	   {
		general_on_error ();
	/*END_ERROR;*/
	   }
	}

	// attach database again to put it online

	Firebird::ClumpletWriter dpb(Firebird::ClumpletReader::Tagged, MAX_DPB_SIZE, isc_dpb_version1);
	tdgbl->uSvc->getAddressPath(dpb);

	if (tdgbl->flag_on_line)
	{
		dpb.insertTag(isc_dpb_online);
	}

	if (tdgbl->gbl_sw_user)
	{
		dpb.insertString(isc_dpb_user_name, tdgbl->gbl_sw_user, strlen(tdgbl->gbl_sw_user));
	}
	if (tdgbl->gbl_sw_password)
	{
		dpb.insertString(tdgbl->uSvc->isService() ? isc_dpb_password_enc : isc_dpb_password,
							 tdgbl->gbl_sw_password, strlen(tdgbl->gbl_sw_password));
	}
	if (tdgbl->gbl_sw_tr_user)
	{
		dpb.insertString(isc_dpb_trusted_auth, tdgbl->gbl_sw_tr_user, strlen(tdgbl->gbl_sw_tr_user));
	}

	dpb.insertByte(isc_dpb_no_db_triggers, 1);

	// set forced writes to the value which was in the header
	dpb.insertByte(isc_dpb_force_write, tdgbl->hdr_forced_writes ? 1 : 0);

	FB_API_HANDLE db_handle = 0;
	if (isc_attach_database(tdgbl->status_vector, 0, database_name, &db_handle,
							dpb.getBufferLength(), reinterpret_cast<const SCHAR*>(dpb.getBuffer())))
	{
		general_on_error();
	}
	if (isc_detach_database (tdgbl->status_vector, &db_handle))
		general_on_error();

	if (!tdgbl->flag_on_line)
	{
		BURP_print(false, 246);
		// msg 246 Database is not online due to failure to activate one or more indices.
		BURP_print(false, 247);
		// msg 247 Run gfix -online to bring database online without active indices.
		return FINI_DB_NOT_ONLINE;
	}

	// If the database is to be restored ReadOnly, set it to read_only now!
	if (tdgbl->gbl_sw_mode && tdgbl->gbl_sw_mode_val)
	{
		BURP_verbose (280);
		// msg 280: setting database to read-only access

		dpb.reset(isc_dpb_version1);
		if (tdgbl->gbl_sw_user)
		{
			dpb.insertString(isc_dpb_user_name, tdgbl->gbl_sw_user, strlen(tdgbl->gbl_sw_user));
		}
		if (tdgbl->gbl_sw_password)
		{
			dpb.insertString(tdgbl->uSvc->isService() ? isc_dpb_password_enc : isc_dpb_password,
							 tdgbl->gbl_sw_password, strlen(tdgbl->gbl_sw_password));
		}
		if (tdgbl->gbl_sw_tr_user)
		{
			dpb.insertString(isc_dpb_trusted_auth, tdgbl->gbl_sw_tr_user, strlen(tdgbl->gbl_sw_tr_user));
		}

		dpb.insertByte(isc_dpb_set_db_readonly, 1);
		dpb.insertByte(isc_dpb_no_db_triggers, 1);

		if (isc_attach_database(tdgbl->status_vector, 0, database_name, &db_handle,
								dpb.getBufferLength(), reinterpret_cast<const SCHAR*>(dpb.getBuffer())))
		{
			general_on_error();
		}
		if (isc_detach_database (tdgbl->status_vector, &db_handle))
			general_on_error();

	}

	return FINI_OK;
}

namespace // unnamed, private
{

void add_files(BurpGlobals* tdgbl, const char* file_name)
{
   struct isc_751_struct {
          char  isc_752 [256];	/* RDB$FILE_NAME */
          ISC_LONG isc_753;	/* RDB$FILE_START */
   } isc_751;
/**************************************
 *
 *	a d d _ f i l e s
 *
 **************************************
 *
 * Functional description
 *	This should be a multi-file database.
 *	Store files and starting
 *	addresses & commit this much.
 *
 **************************************/
	isc_req_handle  req_handle1 = 0;

	// store the RDB$FILES records

	SLONG start = 201; // Magic number, can be taken from some constant?
	SLONG count = 0;

	for (burp_fil* file = tdgbl->gbl_sw_files; file; file = file->fil_next)
	{
		if (file->fil_name != file_name)
		{
			count++;
			/*STORE (REQUEST_HANDLE req_handle1)
				X IN RDB$FILES*/
			{
			
                        if (!req_handle1)
                           isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &req_handle1, (short) sizeof(isc_750), (char*) isc_750);
			if (req_handle1)
			   {
				strcpy (/*X.RDB$FILE_NAME*/
					isc_751.isc_752, file->fil_name.c_str());
				/*X.RDB$FILE_START*/
				isc_751.isc_753 = start;
			/*END_STORE;*/
			   
                           isc_start_and_send (isc_status, (FB_API_HANDLE*) &req_handle1, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 260, &isc_751, (short) 0);
			   };
			/*ON_ERROR*/
			if (isc_status [1])
			   {
				general_on_error ();
			/*END_ERROR;*/
			   }
			}
				MISC_release_request_silent(req_handle1);
			BURP_verbose (57, SafeArg() << file->fil_name.c_str() << start);
			// msg 57 adding file %s, starting at page %ld
		}
		else if (((SLONG) file->fil_length) >= start - 1)
			file->fil_length -= start - 1;
		else
		{
			BURP_print (false, 96, SafeArg() << file->fil_length << (start - 1));
			// msg 96  length given for initial file (%ld) is less than minimum (%ld)
			file->fil_length = 0;
		}

		start += file->fil_length;
	}

	if (count)
	{
		BURP_verbose (70);
		// msg 70 committing secondary files
		/*COMMIT*/
		{
		isc_commit_transaction (isc_status, (FB_API_HANDLE*) &gds_trans);;
		// existing ON_ERROR continues past error, beck
		/*ON_ERROR*/
		if (isc_status [1])
		   {
			BURP_print (false, 174);
			// msg 174 cannot commit files
			BURP_print_status (false, tdgbl->status_vector);
			/*ROLLBACK;*/
			{
			isc_rollback_transaction (isc_status, (FB_API_HANDLE*) &gds_trans);;
			/*ON_ERROR*/
			if (isc_status [1])
			   {
				general_on_error ();
			/*END_ERROR;*/
			   }
			}
		/*END_ERROR;*/
		   }
		}

		/*EXEC SQL SET TRANSACTION NO_AUTO_UNDO;*/
		{
		isc_start_transaction (isc_status, (FB_API_HANDLE*) &gds_trans, (short) 1, &DB, (short) 5, isc_tpb_7);
		SQLCODE = isc_sqlcode(isc_status);
		}
		if (gds_status[1])
			/*EXEC SQL SET TRANSACTION;*/
			{
			isc_start_transaction (isc_status, (FB_API_HANDLE*) &gds_trans, (short) 1, &DB, (short) 4, isc_tpb_8);
			SQLCODE = isc_sqlcode(isc_status);
			}
	}
}

void bad_attribute(scan_attr_t scan_next_attr, att_type bad_attr, USHORT type)
{
/**************************************
 *
 *	b a d _ a t t r i b u t e
 *
 **************************************
 *
 * Functional description
 *	We ran into an unsupported attribute.
 *	but it isn't the end of the world.
 *	We will try to skip some bad data and
 *	look for next valid attribute to continue the process.
 *
 **************************************/
	BurpGlobals* tdgbl = BurpGlobals::getSpecific();

	SLONG skip_count = 0;

	if (!tdgbl->gbl_sw_skip_count)
	{
		static const SafeArg dummy;
		TEXT t_name[128];
		fb_msg_format(NULL, burp_msg_fac, type, sizeof(t_name), t_name, dummy);
		BURP_print (false, 80, SafeArg() << t_name << int(bad_attr));
		// msg 80  don't recognize %s attribute %ld -- continuing
		int skip_l = get(tdgbl);
		if (skip_l)
			get_skip(tdgbl, skip_l);
	}
	else
	{
		if (scan_next_attr == NO_SKIP)
		{
			skip_count = tdgbl->gbl_sw_skip_count;
			get_skip(tdgbl, skip_count);
			BURP_print (false, 203, SafeArg() << skip_count << int(bad_attr));
			// msg 203: skipped %d bytes after reading a bad attribute %d
		}
		else
		{
			++skip_count;
			BURP_print (false, 205, SafeArg() << skip_count << int(bad_attr));
			// msg 205: skipped %d bytes looking for next valid attribute, encountered attribute %d
		}
		scan_next_attr = AFTER_SKIP;
	}
}

void check_db_version(BurpGlobals* tdgbl)
{
   struct isc_743_struct {
          short isc_744;	/* isc_utility */
   } isc_743;
   struct isc_740_struct {
          char  isc_741 [32];	/* RDB$FIELD_NAME */
          char  isc_742 [32];	/* RDB$RELATION_NAME */
   } isc_740;
   struct isc_748_struct {
          short isc_749;	/* isc_utility */
   } isc_748;
   struct isc_746_struct {
          char  isc_747 [32];	/* RDB$RELATION_NAME */
   } isc_746;
/**************************************
 *
 *	c h e c k _ d b _ v e r s i o n
 *
 **************************************
 *
 * Functional description
 *	Find the ODS version number of the database.
 *
 **************************************/
	struct rel_field_t
	{
		const char* rel;
		const char* fld;
		int ods_version;
	};

	tdgbl->RESTORE_ods = DB_VERSION_DDL4;

	const rel_field_t relations[] =
	{
		{"RDB$TRIGGERS",	0,	DB_VERSION_DDL5}, // IB3.3
		{"RDB$PROCEDURES",	0,	DB_VERSION_DDL8}, // IB4
		{"RDB$ROLES",		0,	DB_VERSION_DDL9}, // IB5
		{0, 0, 0}
	};

	isc_req_handle req_handle = 0;
	for (const rel_field_t* rel = relations; rel->rel; ++rel)
	{
		/*FOR (REQUEST_HANDLE req_handle)
			FIRST 1 X IN RDB$RELATIONS
			WITH X.RDB$RELATION_NAME = rel->rel*/
		{
                if (!req_handle)
                   isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &req_handle, (short) sizeof(isc_745), (char*) isc_745);
		isc_vtov ((const char*) rel->rel, (char*) isc_746.isc_747, 32);
		if (req_handle)
		   {
                   isc_start_and_send (isc_status, (FB_API_HANDLE*) &req_handle, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 32, &isc_746, (short) 0);
		   }
		if (!isc_status [1]) {
		while (1)
		   {
                   isc_receive (isc_status, (FB_API_HANDLE*) &req_handle, (short) 1, (short) 2, &isc_748, (short) 0);
		   if (!isc_748.isc_749 || isc_status [1]) break;
			tdgbl->RESTORE_ods = rel->ods_version;
		/*END_FOR;*/
		   }
		   };
		/*ON_ERROR*/
		if (isc_status [1])
		   {
			general_on_error ();
		/*END_ERROR;*/
		   }
		}
	}
	MISC_release_request_silent(req_handle);

	if (tdgbl->RESTORE_ods < DB_VERSION_DDL8)
		return;

	const rel_field_t rel_fields[] =
	{
		{"RDB$FIELDS",					"RDB$FIELD_PRECISION",	DB_VERSION_DDL10},		// FB1, FB1.5
		{"RDB$ROLES",					"RDB$DESCRIPTION",		DB_VERSION_DDL11},		// FB2
		{"RDB$RELATIONS",				"RDB$RELATION_TYPE",	DB_VERSION_DDL11_1},	// FB2.1
		{"RDB$PROCEDURE_PARAMETERS",	"RDB$FIELD_NAME",		DB_VERSION_DDL11_2},	// FB2.5
		{0, 0, 0}
	};

	isc_req_handle req_handle2 = 0;
	for (const rel_field_t* rf = rel_fields; rf->rel; ++rf)
	{
		/*FOR (REQUEST_HANDLE req_handle2)
			FIRST 1 X2 IN RDB$RELATION_FIELDS
			WITH X2.RDB$RELATION_NAME = rf->rel
			AND X2.RDB$FIELD_NAME = rf->fld*/
		{
                if (!req_handle2)
                   isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &req_handle2, (short) sizeof(isc_739), (char*) isc_739);
		isc_vtov ((const char*) rf->fld, (char*) isc_740.isc_741, 32);
		isc_vtov ((const char*) rf->rel, (char*) isc_740.isc_742, 32);
		if (req_handle2)
		   {
                   isc_start_and_send (isc_status, (FB_API_HANDLE*) &req_handle2, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 64, &isc_740, (short) 0);
		   }
		if (!isc_status [1]) {
		while (1)
		   {
                   isc_receive (isc_status, (FB_API_HANDLE*) &req_handle2, (short) 1, (short) 2, &isc_743, (short) 0);
		   if (!isc_743.isc_744 || isc_status [1]) break;
			tdgbl->RESTORE_ods = rf->ods_version;
		/*END_FOR;*/
		   }
		   };
		/*ON_ERROR*/
		if (isc_status [1])
		   {
			general_on_error ();
		/*END_ERROR;*/
		   }
		}
	}
	MISC_release_request_silent(req_handle2);
}

void create_database(BurpGlobals* tdgbl, const TEXT* file_name)
{
/**************************************
 *
 *	c r e a t e _ d a t a b a s e
 *
 **************************************
 *
 * Functional description
 *	create the new database, looking
 *	to see if there are any interesting
 *	things to do.
 *
 **************************************/

	// Get (physical) database record

	ULONG page_size = DEFAULT_PAGE_SIZE;
	// sweep_interval = -1;
	// sweep_interval = 0xFFFFFFFF;
	ULONG sweep_interval = MAX_ULONG;
	bool no_reserve = false;
	bool db_read_only = false, SQL_dialect_flag = false;
	bool forced_writes = true; // turned on by default
	ULONG page_buffers = 0;
	USHORT SQL_dialect = 0;

	att_type attribute;
	rec_type record;
	if (get_record(&record, tdgbl) == rec_physical_db)
	{
		while (get_attribute(&attribute, tdgbl) != att_end)
		{
			switch (attribute)
			{
			case att_SQL_dialect:
				SQL_dialect_flag = true;
				SQL_dialect = (USHORT) get_numeric(tdgbl);
				break;

			case att_page_size:
				page_size = get_numeric(tdgbl);
				break;

			case att_sweep_interval:
				sweep_interval = get_numeric(tdgbl);
				break;

			case att_forced_writes:
				forced_writes = get_numeric(tdgbl) != FALSE;
				break;

			case att_no_reserve:
				no_reserve = get_numeric(tdgbl) != FALSE;
				break;

			case att_db_read_only:
				db_read_only = get_numeric(tdgbl) != FALSE;
				break;

			case att_page_buffers:
				page_buffers = get_numeric(tdgbl);
				break;

			default:
				{
					const SSHORT l = get(tdgbl);
					if (l) {
						get_skip(tdgbl, l);
					}
					break;
				}
			}
		}
		get_record(&record, tdgbl);
	}

	if (record != rec_database)
		BURP_error_redirect (NULL, 32);
		// msg 32 Expected database description record

	if (tdgbl->gbl_sw_page_size)
	{
		if (tdgbl->gbl_sw_page_size < page_size)
		{
			BURP_print (false, 110, SafeArg() << page_size << tdgbl->gbl_sw_page_size);
			// msg 110 Reducing the database page size from %ld bytes to %ld bytes
		}
		page_size = tdgbl->gbl_sw_page_size;
	}

	tdgbl->hdr_forced_writes = forced_writes;

	if (tdgbl->gbl_sw_no_reserve)
		no_reserve = tdgbl->gbl_sw_no_reserve;

	// Override attribute setting with user requirement
	if (tdgbl->gbl_sw_mode)
		db_read_only = tdgbl->gbl_sw_mode_val;
	else
	{
		// No access mode specified by user. Use attribute settings. Since the
		// database is set to readOnly only after making it Online in
		// RESTORE_restore(), pass on this information through Global structures
		tdgbl->gbl_sw_mode = true;
		tdgbl->gbl_sw_mode_val = db_read_only;
	}

	if (tdgbl->gbl_sw_page_buffers)
		page_buffers = tdgbl->gbl_sw_page_buffers;

	Firebird::ClumpletWriter dpb(Firebird::ClumpletReader::Tagged, MAX_DPB_SIZE, isc_dpb_version1);
	tdgbl->uSvc->getAddressPath(dpb);
	dpb.insertInt(isc_dpb_page_size, page_size & 0xff00);
	dpb.insertString(isc_dpb_gbak_attach, GDS_VERSION, strlen(GDS_VERSION));

	if (sweep_interval != MAX_ULONG)
	{
		dpb.insertInt(isc_dpb_sweep_interval, sweep_interval);
	}

	// If the database is to be restored "read_only", fillup the data pages
	if (no_reserve || db_read_only)
	{
		dpb.insertByte(isc_dpb_no_reserve, 1);
	}
	if (tdgbl->gbl_sw_user)
	{
		dpb.insertString(isc_dpb_user_name, tdgbl->gbl_sw_user, strlen(tdgbl->gbl_sw_user));
	}
	if (tdgbl->gbl_sw_password)
	{
		dpb.insertString(tdgbl->uSvc->isService() ? isc_dpb_password_enc : isc_dpb_password,
							 tdgbl->gbl_sw_password, strlen(tdgbl->gbl_sw_password));
	}
	if (tdgbl->gbl_sw_tr_user)
	{
		dpb.insertString(isc_dpb_trusted_auth, tdgbl->gbl_sw_tr_user, strlen(tdgbl->gbl_sw_tr_user));
	}
	if (page_buffers)
	{
		dpb.insertInt(isc_dpb_set_page_buffers, page_buffers);
	}

	// Turn off sync writes during restore
	dpb.insertByte(isc_dpb_force_write, 0);

	// which SQL dialect that this database speaks
	// When we restore backup files that came from prior
	// to V6, we force the SQL database dialect to 1

	dpb.insertByte(isc_dpb_sql_dialect, SQL_dialect_flag ? SQL_dialect : SQL_DIALECT_V5);

	// start database up shut down,
	// use single-user mode to avoid conflicts during restore process
	dpb.insertByte(isc_dpb_shutdown, isc_dpb_shut_attachment | isc_dpb_shut_single);
	dpb.insertInt(isc_dpb_shutdown_delay, 0);
	dpb.insertInt(isc_dpb_overwrite, tdgbl->gbl_sw_overwrite);

	dpb.insertByte(isc_dpb_no_db_triggers, 1);

	ISC_STATUS_ARRAY status_vector;

	if (tdgbl->gbl_sw_fix_fss_metadata)
	{
		dpb.insertString(isc_dpb_lc_ctype, tdgbl->gbl_sw_fix_fss_metadata,
			strlen(tdgbl->gbl_sw_fix_fss_metadata));
	}

	if (isc_create_database(status_vector, 0, file_name, &DB,
							dpb.getBufferLength(), reinterpret_cast<const SCHAR*>(dpb.getBuffer()),
							0))
	{
		BURP_error_redirect (status_vector, 33, SafeArg() << file_name);
		// msg 33 failed to create database %s
	}

	if (tdgbl->gbl_sw_version && !tdgbl->uSvc->isService())
	{
		BURP_print(true, 139, file_name);
		// msg 139 Version(s) for database "%s"
		isc_version(&DB, BURP_output_version, (void*)"\t%s\n");
	}

	BURP_verbose (74, SafeArg() << file_name << page_size);
	// msg 74 created database %s, page_size %ld bytes
}

void decompress(BurpGlobals*	tdgbl,
				UCHAR*			buffer,
				USHORT			length)
{
/**************************************
 *
 *	d e c o m p r e s s
 *
 **************************************
 *
 * Functional description
 *	Get a number of compressed bytes.
 *
 **************************************/
	UCHAR* p = buffer;
	const UCHAR* const end = p + length;

	while (p < end)
	{
		// This change was made to restore National Semi-Conductor's corrupted
		// gbak file and it is in the code base now.  -Andrew

		// so count really only to 255
		SSHORT count = (SCHAR) get(tdgbl);
		if (count > 0)
		{
			if (end - p < count)
			{
				BURP_print (false, 202, SafeArg() << count << (end - p));
				// msg 202: adjusting a decompression length error: invalid length  %d was adjusted to %d
				count = end - p;
			}
			p = get_block(tdgbl, p, count);
		}
		else if (count < 0)
		{
			if (end + count < p)
			{
				BURP_print(false, 202, SafeArg() << count << (p - end));
				// msg 202: adjusting a decompression length error: invalid length %d was adjusted to %d
				count = p - end;
			}
			const UCHAR c = get(tdgbl);
			memset (p, c, -count);
			p += -count;
		}
	}

	if (p > end) {
		BURP_error_redirect (NULL, 34);
		// msg 34 RESTORE: decompression length error
	}
}

void eat_blob(BurpGlobals* tdgbl)
{
/**************************************
 *
 *	e a t _ b l o b
 *
 **************************************
 *
 * Functional description
 *	Discard a blob from backup file
 *
 **************************************/

	const SLONG length = get_numeric(tdgbl);

	get_skip(tdgbl, length);
}

// *****************************
// e a t _ t e x t
// *****************************
// Discard a text field from the backup file.
void eat_text(BurpGlobals* tdgbl)
{
	const ULONG l = get(tdgbl);
	if (l)
		MVOL_skip_block(tdgbl, l);
}

// *****************************
// e a t _ t e x t 2
// *****************************
// Discard a text field from the backup file, using USHORT length indicator.
void eat_text2(BurpGlobals* tdgbl)
{
	UCHAR lenstr[sizeof(USHORT)] = "";
	get_block(tdgbl, lenstr, sizeof(lenstr));
	USHORT len = (USHORT) gds__vax_integer(lenstr, sizeof(lenstr));
	if (len)
		MVOL_skip_block(tdgbl, len);
}

burp_rel* find_relation(BurpGlobals* tdgbl, const TEXT* name)
{
/**************************************
 *
 *	f i n d _ r e l a t i o n
 *
 **************************************
 *
 * Functional description
 *	Given a relation name, find the relation block.  If there isn't
 *	one, produce a fatal error.
 *
 **************************************/

	// Why isn't strcmp used here?
	for (burp_rel* relation = tdgbl->relations; relation; relation = relation->rel_next)
	{
		for (const TEXT* p = relation->rel_name, *q = name; *p == *q; p++, q++) {
			if (!*p)
				return relation;
		}
	}

	BURP_error_redirect (NULL, 35, SafeArg() << name);
	// msg 35 can't find relation %s

	return NULL;
}

void fix_security_class_name(BurpGlobals* tdgbl, TEXT* sec_class, bool is_field)
{
/**************************************
 *
 *	f i x _ s e c u r i t y _ c l a s s _ n a m e
 *
 **************************************
 *
 * Functional description
 *	Reassign a proper (unique) name for auto-generated
 *  security classes.
 *
 **************************************/

	const char* const prefix = is_field ? SQL_FLD_SECCLASS_PREFIX : SQL_SECCLASS_PREFIX;
	const int prefix_length = is_field ? SQL_FLD_SECCLASS_PREFIX_LEN : SQL_SECCLASS_PREFIX_LEN;

	if (strncmp(sec_class, prefix, prefix_length))
		return;

	if (tdgbl->RESTORE_ods < DB_VERSION_DDL11_2)
		return;

	ISC_STATUS_ARRAY status_vector;

	isc_req_handle& handle = tdgbl->handles_fix_security_class_name_req_handle1;

	if (!handle)
	{
		UCHAR blr_buffer[BUFFER_TINY];
		UCHAR* blr = blr_buffer;

		add_byte(blr, blr_version5);
		add_byte(blr, blr_begin);

		add_byte(blr, blr_message);
		add_byte(blr, 0);
		add_word(blr, 1);

		add_byte(blr, blr_int64);
		add_byte(blr, 0);

		add_byte(blr, blr_send);
		add_byte(blr, 0);

		add_byte(blr, blr_begin);
		add_byte(blr, blr_assignment);

		add_byte(blr, blr_gen_id);
		add_string(blr, SQL_SECCLASS_GENERATOR);

		add_byte(blr, blr_literal);
		add_byte(blr, blr_int64);
		add_byte(blr, 0);
		add_int64(blr, 1);

		add_byte(blr, blr_parameter);
		add_byte(blr, 0);
		add_word(blr, 0);

		add_byte(blr, blr_end);
		add_byte(blr, blr_end);
		add_byte(blr, blr_eoc);

		const USHORT blr_length = blr - blr_buffer;
		fb_assert(blr_length <= sizeof(blr_buffer));

		if (isc_compile_request(status_vector, &DB, &handle,
							    blr_length, (const SCHAR*) blr_buffer))
		{
			BURP_error_redirect(status_vector, 316);
			// msg 316 Failed while fixing the security class name
		}
	}

	if (isc_start_request(status_vector, &handle, &gds_trans, 0))
	{
		BURP_error_redirect(status_vector, 316);
		// msg 316 Failed while fixing the security class name
	}

	SINT64 id = 0;

	if (isc_receive(status_vector, &handle, 0, sizeof(SINT64), &id, 0))
	{
		BURP_error_redirect(status_vector, 316);
		// msg 316 Failed while fixing the security class name
	}

	fb_assert(id);

	snprintf(sec_class, MAX_SQL_IDENTIFIER_SIZE, "%s%" SQUADFORMAT, prefix, id);
}

void general_on_error()
{
/**************************************
 *
 *	g e n e r a l _ o n _ e r r o r
 *
 **************************************
 *
 * Functional description
 *	Handle any general ON_ERROR clause during restore.
 *
 **************************************/
	BurpGlobals* tdgbl = BurpGlobals::getSpecific();

	if (isc_status[1] == isc_malformed_string)
	{
		Firebird::Arg::StatusVector oldVector(isc_status);
		Firebird::Arg::Gds newVector(isc_gbak_invalid_metadata);
		newVector.append(oldVector);
		newVector.copyTo(isc_status);
	}
	BURP_print_status (true, isc_status);

	BURP_abort ();
}

bool get_acl(BurpGlobals*	tdgbl,
			 const TEXT*	owner_nm,
			 ISC_QUAD*		blob_id,
			 ISC_QUAD*		new_blob_id)
{
/**************************************
 *
 *	g e t _ a c l
 *
 **************************************
 *
 * Functional description
 *
 *	open the blob that contains the ACL list
 *	get the ACL list of a relation
 *	replace the owner of the relation in the ACL list with
 *	  the creator of the relation
 *	create a new blob
 *	store the new ACL list in the new blob
 *
 **************************************/

	static const UCHAR blr_items[] =
	{
		isc_info_blob_max_segment,
		isc_info_blob_total_length,
		isc_info_blob_num_segments
	};

	// If the blob is null, don't store it.  It will be restored as null.

	if (!blob_id->gds_quad_high && !blob_id->gds_quad_low)
		return false;

	// Open the blob and get it's vital statistics

	ISC_STATUS_ARRAY status_vector;
	UserBlob blob(status_vector);

	if (! blob.open(DB, gds_trans, *blob_id))
	{
		// msg 24 isc_open_blob failed
		BURP_error_redirect (status_vector, 24);
	}

	UCHAR blob_info[32];
	if (!blob.getInfo(sizeof(blr_items), blr_items, sizeof(blob_info), blob_info))
	{
		// msg 20 isc_blob_info failed
		BURP_error_redirect (status_vector, 20);
	}

	ULONG length = 0;
	UCHAR item;
	USHORT max_segment;
	ULONG num_segments;
	const UCHAR* p = blob_info;

	while ((item = *p++) != isc_info_end)
	{
		const USHORT l = (USHORT) gds__vax_integer (p, 2);
		p += 2;
		const SLONG n = gds__vax_integer (p, l);
		p += l;
		switch (item)
		{
		case isc_info_blob_max_segment:
			max_segment = (USHORT) n;
			break;

		case isc_info_blob_total_length:
			length = n;
			break;

		case isc_info_blob_num_segments:
			num_segments = n;

			// we assume that the ACL list was written out as
			// in one big segment

			if (num_segments > 1) {
				// CVC: I can't see the effect of assert(true)
				fb_assert (num_segments > 1);
			}
			break;

		default:
			// msg 79 don't understand blob info item %ld
			BURP_print (false, 79, SafeArg() << int(item));
			// CVC: do you return, without closing the blob, dear function???
			if (!blob.close())
			{
				BURP_error_redirect (status_vector, 23);
				// msg 23 isc_close_blob failed
			}
			return false;
		}
	}

	if (!length)
	{
		if (!blob.close())
		{
			BURP_error_redirect (status_vector, 23);
			// msg 23 isc_close_blob failed
		}
		return false;
	}

	// Rdb sometimes gets the length messed up

	if (length < max_segment)
		length = max_segment;

	fb_assert(length <= ULONG(MAX_SLONG));

	// Allocate a buffer large enough for the largest segment and start grinding.

	BlobBuffer static_buffer;
	UCHAR* buffer = static_buffer.getBuffer(length);

	size_t return_length = 0;
	if (!blob.getData(length, buffer, return_length))
	{
		// msg 22 gds_$get_segment failed
		BURP_error_redirect (status_vector, 22);
	}
	// protect ourselves
	length = return_length;

	if (!blob.close())
	{
		// msg 23 isc_close_blob failed
		BURP_error_redirect (status_vector, 23);
	}

	const UCHAR* from = buffer + 3; // skip ACL_version, ACL_id_list, and id_person
	const SLONG id_person_len = (SLONG) *from;

	const UCHAR* c_1 = (UCHAR*) owner_nm;
	const size_t owner_nm_len = strlen(owner_nm);
	fb_assert(owner_nm_len <= size_t(MAX_UCHAR));

	// If some day, ACLs become bigger than MAX_SLONG, we should review this code.
	const SLONG bufSize = SLONG(length) - id_person_len + SLONG(owner_nm_len);
	fb_assert(bufSize > 0);
	BlobBuffer new_static_buffer;
	UCHAR* const new_buffer = new_static_buffer.getBuffer(bufSize);

	from = buffer;
	UCHAR* to = new_buffer;
	*to++ = *from++; // copy ACL_verion
	*to++ = *from++; // copy ACL_id_list
	*to++ = *from++; // copy id_person
	*to++ = UCHAR(owner_nm_len);

	size_t new_len = 4; //new_len + 4; Previously, new_len was set to zero at the top
	// from = buffer + id_person_len + 4; redundant, see 2nd loop below.
	for (ULONG cnt = 0; cnt < owner_nm_len; cnt++)
	{
		*to++ = *c_1++;
		new_len++;
	}

	const UCHAR* const end_buffer = buffer + length;
	for (from = buffer + id_person_len + 4; from < end_buffer; from++)
	{
		*to++ = *from;
		new_len++;
	}

	if (!blob.create(DB, gds_trans, *new_blob_id))
	{
		// msg 37 isc_create_blob failed
		BURP_error_redirect (status_vector, 37);
	}

	if (!blob.putData(new_len, new_buffer))
	{
		// msg 38 isc_put_segment failed
		BURP_error_redirect (status_vector, 38);
	}

	if (!blob.close())
	{
		// msg 23 isc_close_blob failed
		BURP_error_redirect (status_vector, 23);
	}

	return true;
}

void get_array(BurpGlobals* tdgbl, burp_rel* relation, UCHAR* record_buffer)
{
/**************************************
 *
 *	g e t _ a r r a y
 *
 **************************************
 *
 * Functional description
 *	Read array data from input file to nice,
 *	shiney, new array.
 *
 **************************************/
	burp_fld*		field = NULL;
	ISC_STATUS_ARRAY	status_vector;
	USHORT		count, field_number, field_length = 0;
	UCHAR*		buffer = NULL;
	UCHAR*		p = NULL;
	UCHAR		blr_buffer[200]; // enough for a sdl with 16 dimensions
	lstring		xdr_slice;

	// don't free something you don't allocate
	lstring xdr_buffer;
	xdr_buffer.lstr_allocated = 0;
	xdr_buffer.lstr_address = NULL;

	// Pick up attributes
	SLONG		fld_ranges[2 * MAX_DIMENSION];
	SLONG       slice_length = 0;
	SLONG       *range;
	const SLONG* end_ranges;
	scan_attr_t scan_next_attr;
	skip_init(&scan_next_attr);
	att_type	attribute;
	while (skip_scan(&scan_next_attr), get_attribute(&attribute, tdgbl) != att_blob_data)
	{
		switch (attribute)
		{
		case att_blob_field_number:
			field_number = (USHORT) get_numeric(tdgbl);
			for (field = relation->rel_fields; field; field = field->fld_next) {
				if (field->fld_number == field_number)
					break;
			}
			if (!field) {
				BURP_error_redirect (NULL, 36);
				// msg 36 Can't find field for blob
			}

			field_length = field->fld_length;
			if (field->fld_type == blr_varying)
				field_length += sizeof(USHORT);
			slice_length = field_length;
			//
			// Copy the ranges onto a buffer and let the program
			// mess with the copy rather than the original
			//
			memcpy(fld_ranges, field->fld_ranges, sizeof(fld_ranges));
			break;

		case att_array_dimensions:
			field->fld_dimensions = (SSHORT) get_numeric(tdgbl);
			end_ranges = fld_ranges + 2 * field->fld_dimensions;
			for (range = fld_ranges; range < end_ranges; range += 2)
			{
				if (get_attribute(&attribute, tdgbl) != att_array_range_low)
					bad_attribute (scan_next_attr, attribute, 58);
					// msg 58 array
				else
					range[0] = get_numeric(tdgbl);
				if (get_attribute(&attribute, tdgbl) != att_array_range_high)
					bad_attribute (scan_next_attr, attribute, 58);
					// msg 58 array
				else
					range[1] = get_numeric(tdgbl);
				slice_length *= (range[1] - range[0] + 1);
			}
			break;

		default:
			bad_attribute (scan_next_attr, attribute, 58);
			// msg 58 array
			break;
		}
	}

	SLONG return_length = get(tdgbl);
	return_length |= get(tdgbl) << 8;
	return_length |= get(tdgbl) << 16;
	return_length |= get(tdgbl) << 24;

	ISC_QUAD* blob_id = (ISC_QUAD*) ((UCHAR*) record_buffer + field->fld_offset);

	SLONG last_element_dim[MAX_DIMENSION];
	if (return_length != slice_length)
	{
		int upper, lower;
		//
		// Ugh!  The full array wasn't returned and versions of gbak prior to
		// V3.2I don't explicitly signal this.  We must recompute the top
		// element to restore.
		//
		// Double Ugh!  gbak (Versions prior to 5.0) while backing up calculates
		// the top dimensions incorrectly So whatever was written as top dimensions
		// is useless. 5.0 gbak has written correct dimensions, but what the heck
		// we'll calculate it again
		//

		int elements_remaining = return_length / field_length;
		//
		// Backup (versions prior to 5.0) has surely written wrong dimensions.
		// Ignore whatever is read in fld_ranges and calculate the dimensions
		// of the last element. field->fld_ranges has the max dimensions.
		// last_element_dim holds only the upper bounds of each dimension.
		//
		for (int i1 = 0, i3 = 0; i1 < field->fld_dimensions; i1++)
		{
			int divisor = 1;
			for (int i2 = (2 * (i1 + 1) + 1); i2 <= field->fld_dimensions * 2; i2 += 2)
				divisor *= (field->fld_ranges[i2] - field->fld_ranges[i2 - 1] + 1);
			last_element_dim[i1] = (elements_remaining - 1) / divisor + field->fld_ranges[i3];
			elements_remaining  -= (last_element_dim[i1] - field->fld_ranges[i3]) * divisor;
			i3 += 2;
		}

		int current_dim;
#ifdef DEBUG
		fprintf(stderr, "\nLast element upper bounds read from backup file:\n");
		for (current_dim = 1; current_dim < field->fld_dimensions * 2; current_dim += 2)
			fprintf(stderr, "%ld ", fld_ranges[current_dim]);
		fprintf(stderr, "\nCalculated Last element upper bounds :\n");
		for (current_dim = 0; current_dim < field->fld_dimensions; current_dim++)
			fprintf(stderr, "%ld ", last_element_dim[current_dim]);
		fprintf(stderr, "return_length = %ld\n", return_length);
		fprintf(stderr, "elements_returned = %ld\n", return_length / field_length);
		fprintf(stderr, "Max dims[");
		for (current_dim = 1; current_dim < field->fld_dimensions * 2; current_dim += 2)
			fprintf(stderr, "%ld ", field->fld_ranges[current_dim]);
		fprintf(stderr, "]");
#endif
		int data_at = 0;
		//
		// We have an irregurlar shaped slice to write. The following for loop
		// chops the array into writable rectangular/square slice and sends it
		// to the engine. When the loop cycles through all dimensions, we would
		// have written the whole of the irregular slice.
		//
		for (current_dim = 0; current_dim < field->fld_dimensions; current_dim++)
		{
			UCHAR* blr = blr_buffer;
			bool dont_write = false;

			// build the sdl

			add_byte(blr, isc_sdl_version1);

			add_byte(blr, isc_sdl_struct);
			add_byte(blr, 1);

			switch (field->fld_type)
			{
			case blr_text:
			case blr_varying:
				if (field->fld_type == blr_text)
					add_byte(blr, blr_text2);
				else
					add_byte(blr, blr_varying2);
				add_word(blr, field->fld_character_set_id);
				add_word(blr, field->fld_length);
				break;
			case blr_short:
			case blr_long:
			case blr_quad:
			case blr_int64:
				add_byte(blr, field->fld_type);
				add_byte(blr, field->fld_scale);
				break;
			default:
				add_byte(blr, field->fld_type);
			}

			add_byte(blr, isc_sdl_relation);
			add_string(blr, relation->rel_name);
			add_byte(blr, isc_sdl_field);
			add_string(blr, field->fld_name);

			// each element spec starts here

#ifdef DEBUG
			fprintf(stderr, "\nBounds written[");
#endif
			int elements_written = 1;
			end_ranges = field->fld_ranges + 2 * field->fld_dimensions;
			//
			// Here is the important work. Calculate the the bounds to be written
			// so that the resulting slice is a rectangular/square slice.
			// For a 2 dimensional array of size 1..N, 1..M, which is partially
			// filled, we have already calculated the dims of last element. Say
			// if this was x,y (x is row, y is column) then we do
			//    isc_put_slice(1..x-1, 1..M);
			//    isc_put_slice(x..x, 1..y);
			// similarly for a 3D array [N,M,K] whose last element dims are (x,y,z)
			//    isc_put_slice(1..x-1, 1..M, 1..K);
			//    isc_put_slice(x..x, 1..y-1, 1..K);
			//    isc_put_slice(x..x, y..y, 1..z);
			// This is applicable for any number of dimensions.
			// Special cases:
			// for example in case of a 2D array (10,10) and if the last element
			// dims were (1,2), we would just do a isc_put_slice(1..1, 1..2).
			// This is applied for any number of dimensions.
			//
			for (range = field->fld_ranges, count = 0; range < end_ranges; range += 2, count++)
			{
				add_byte(blr, isc_sdl_do2);
				add_byte(blr, count);
				//
				// Normally we loop through all dimensions chopping off slices
				// and writing them. This works fine but this also means that
				// we blindly put slices without actually figuring out if we
				// really need to do so. For eg: if we have a 2D array of
				// size [10,4] and the last element dims are [6,4] then all
				// we need to do is is to put one slice as
				//   isc_put_slice(1..6,1..4)
				// rather than looping through the dimensions and putting
				//   isc_put_slice(1..5,1..4)
				//   isc_put_slice(6..6,1..4)
				// we could extend this logic to any no of dims. The following
				// if condition figures out such cases. This combined with
				// the Special case should optimize the no of isc_put_slice
				// we perform.
				//
				if (current_dim + 1 == field->fld_dimensions - 1 &&
					field->fld_dimensions - count == 2 && last_element_dim[count + 1]  == range[3])
				{
					add_byte(blr, isc_sdl_long_integer);
					add_long(blr, range[0]);
					lower = range[0];
					add_byte(blr, isc_sdl_long_integer);
					add_long(blr, last_element_dim[count]);
					upper = last_element_dim[count];
					elements_written *= (upper - lower + 1);
					range += 2;
					count++;
					add_byte(blr, isc_sdl_do2);
					add_byte(blr, count);
					add_byte(blr, isc_sdl_long_integer);
					add_long(blr, range[0]);
					lower = range[0];
					add_byte(blr, isc_sdl_long_integer);
					add_long(blr, last_element_dim[count]);
					upper = last_element_dim[count];
					elements_written *= (upper - lower + 1);
					++current_dim;
					break;
				}
				if (current_dim == count)
				{
					add_byte(blr, isc_sdl_long_integer);
					add_long(blr, range[0]);
					lower = range[0];
					add_byte(blr, isc_sdl_long_integer);
					upper = (current_dim == field->fld_dimensions - 1) ?
						last_element_dim[count] : (last_element_dim[count] - 1);
					if (upper < range[0])
					{
						// see Special Case above

						dont_write = true;
						break;
					}
					add_long(blr, upper);
				}
				else if (current_dim < count)
				{
					add_byte(blr, isc_sdl_long_integer);
					add_long(blr, range[0]);
					add_byte(blr, isc_sdl_long_integer);
					add_long(blr, range[1]);
					upper = range[1];
					lower = range[0];
				}
				else if (current_dim > count)
				{
					add_byte(blr, isc_sdl_long_integer);
					add_long(blr, last_element_dim[count]);
					add_byte(blr, isc_sdl_long_integer);
					add_long(blr, last_element_dim[count]);
					upper = lower = last_element_dim[count];
				}
				elements_written *= (upper - lower + 1);
#ifdef DEBUG
				fprintf(stderr, "%d..%d ", lower, upper);
#endif
			}
			if (dont_write)
				continue;
#ifdef DEBUG
			fprintf(stderr, "]");
			fprintf(stderr, "\n Elements Written=%d  ", elements_written);
#endif

			add_byte(blr, isc_sdl_element);
			add_byte(blr, 1);
			add_byte(blr, isc_sdl_scalar);
			add_byte(blr, 0);
			add_byte(blr, field->fld_dimensions);

			for (count = 0; count < field->fld_dimensions; count++)
			{
				add_byte(blr, isc_sdl_variable);
				add_byte(blr, count);
			}

			add_byte(blr, isc_sdl_eoc);

#ifdef DEBUG
			if (debug_on)
				PRETTY_print_sdl (blr_buffer, NULL, NULL, 0);
#endif

			const USHORT blr_length = blr - blr_buffer;

			if (data_at == 0)
			{
				buffer = BURP_alloc (return_length);
				SLONG lcount;
				if (tdgbl->gbl_sw_transportable)
				{
					if (get_attribute(&attribute, tdgbl) != att_xdr_array)
						// msg 55 Expected XDR record length
						BURP_error_redirect (NULL, 55);
					else
					{
						lcount = get(tdgbl);
						lcount |= get(tdgbl) << 8;
						lcount |= get(tdgbl) << 16;
						lcount |= get(tdgbl) << 24;
						xdr_buffer.lstr_length = xdr_buffer.lstr_allocated = lcount;
						xdr_buffer.lstr_address = BURP_alloc(lcount);
						xdr_slice.lstr_allocated = xdr_slice.lstr_length = return_length;
						xdr_slice.lstr_address = buffer;
						p = xdr_buffer.lstr_address;
					}
				}
				else
				{
					p = buffer;
					lcount = return_length;
				}

				if (lcount)
					get_block(tdgbl, p, lcount);

				if (tdgbl->gbl_sw_transportable)
					CAN_slice (&xdr_buffer, &xdr_slice, FALSE, /*blr_length,*/ blr_buffer);
			}

			if (isc_put_slice(status_vector, &DB, &gds_trans,
							  blob_id, blr_length, reinterpret_cast<const char*>(blr_buffer),
							  0,	// param length for subset of an array handling
							  NULL,	// param for subset of an array handling
							  elements_written * field->fld_length, buffer + data_at))
			{
				BURP_print (false, 81, field->fld_name);
				// msg 81 error accessing blob field %s -- continuing
				BURP_print_status (true, status_vector);
#ifdef DEBUG
				PRETTY_print_sdl (blr_buffer, NULL, NULL, 0);
#endif
				return;
			}
			data_at += elements_written * field->fld_length;
#ifdef DEBUG
			fprintf(stderr, "next data_at = %d\n", data_at);
#endif
		}
	}
	else
	{
		// This is the regular case we've got the entire array
		UCHAR* blr = blr_buffer;

		// build the sdl

		add_byte(blr, isc_sdl_version1);

		add_byte(blr, isc_sdl_struct);
		add_byte(blr, 1);

		switch (field->fld_type)
		{
		case blr_text:
		case blr_varying:
			if (field->fld_type == blr_text)
				add_byte(blr, blr_text2);
			else
				add_byte(blr, blr_varying2);
			add_word(blr, field->fld_character_set_id);
			add_word(blr, field->fld_length);
			break;
		case blr_short:
		case blr_long:
		case blr_quad:
		case blr_int64:
			add_byte(blr, field->fld_type);
			add_byte(blr, field->fld_scale);
			break;
		default:
			add_byte(blr, field->fld_type);
		}

		add_byte(blr, isc_sdl_relation);
		add_string(blr, relation->rel_name);
		add_byte(blr, isc_sdl_field);
		add_string(blr, field->fld_name);

		// each element spec starts here

		for (range = fld_ranges, count = 0; range < end_ranges; range += 2, count++)
		{
			add_byte(blr, isc_sdl_do2);
			add_byte(blr, count);
			add_byte(blr, isc_sdl_long_integer);
			add_long(blr, range[0]);
			add_byte(blr, isc_sdl_long_integer);
			add_long(blr, range[1]);
		}

		add_byte(blr, isc_sdl_element);
		add_byte(blr, 1);
		add_byte(blr, isc_sdl_scalar);
		add_byte(blr, 0);
		add_byte(blr, field->fld_dimensions);

		for (count = 0; count < field->fld_dimensions; count++)
		{
			add_byte(blr, isc_sdl_variable);
			add_byte(blr, count);
		}

		add_byte(blr, isc_sdl_eoc);

#ifdef DEBUG
		if (debug_on)
			PRETTY_print_sdl (blr_buffer, NULL, NULL, 0);
#endif

		const USHORT blr_length = blr - blr_buffer;

		buffer = BURP_alloc (return_length);
		SLONG lcount;
		if (tdgbl->gbl_sw_transportable)
		{
			if (get_attribute(&attribute, tdgbl) != att_xdr_array)
				BURP_error_redirect (NULL, 55);
				// msg 55 Expected XDR record length
			else
			{
				xdr_buffer.lstr_allocated = get(tdgbl);
				xdr_buffer.lstr_allocated |= get(tdgbl) << 8;
				xdr_buffer.lstr_allocated |= get(tdgbl) << 16;
				xdr_buffer.lstr_allocated |= get(tdgbl) << 24;
				lcount = xdr_buffer.lstr_length = xdr_buffer.lstr_allocated;
				xdr_buffer.lstr_address = BURP_alloc (xdr_buffer.lstr_allocated);
				xdr_slice.lstr_allocated = xdr_slice.lstr_length = return_length;
				xdr_slice.lstr_address = buffer;
				p = xdr_buffer.lstr_address;
			}
		}
		else
		{
			p = buffer;
			lcount = return_length;
		}

		if (lcount)
			get_block(tdgbl, p, lcount);

		if (tdgbl->gbl_sw_transportable)
			CAN_slice (&xdr_buffer, &xdr_slice, FALSE, /*blr_length,*/ blr_buffer);


		if (isc_put_slice(status_vector, &DB, &gds_trans,
						  blob_id, blr_length,
						  reinterpret_cast<const char*>(blr_buffer),
						  0,	  // param length for subset of an array handling
						  NULL,  // param for subset of an array handling
						  return_length, buffer))
		{
			BURP_print (false, 81, field->fld_name);
			// msg 81 error accessing blob field %s -- continuing
			BURP_print_status (false, status_vector);
#ifdef DEBUG
			PRETTY_print_sdl (blr_buffer, NULL, NULL, 0);
#endif
			return;
		}
	}

	BURP_free (buffer);
	if (tdgbl->gbl_sw_transportable && xdr_buffer.lstr_allocated)
		BURP_free (xdr_buffer.lstr_address);
}

void get_blob(BurpGlobals* tdgbl, const burp_fld* fields, UCHAR* record_buffer)
{
/**************************************
 *
 *	g e t _ b l o b
 *
 **************************************
 *
 * Functional description
 *	Read blob attributes and copy data from input file to nice,
 *	shiny, new blob.
 *
 **************************************/

	// Pick up attributes

	ULONG segments = 0;
	USHORT field_number = MAX_USHORT;
	USHORT max_segment = 0;
	UCHAR blob_type = 0;

	att_type	attribute;
	scan_attr_t	scan_next_attr;
	skip_init(&scan_next_attr);
	while (skip_scan(&scan_next_attr), get_attribute(&attribute, tdgbl) != att_blob_data)
	{
		switch (attribute)
		{
		case att_blob_field_number:
			field_number = (USHORT) get_numeric(tdgbl);
			break;

		case att_blob_max_segment:
			max_segment = (USHORT) get_numeric(tdgbl);
			break;

		case att_blob_number_segments:
			segments = get_numeric(tdgbl);
			break;

		case att_blob_type:
			blob_type = (UCHAR) get_numeric(tdgbl);
			break;

		default:
			bad_attribute(scan_next_attr, attribute, 64);
			// msg 64 blob
			break;
		}
	}

	// Find the field associated with the blob
	const burp_fld* field;
	for (field = fields; field; field = field->fld_next) {
		if (field->fld_number == field_number)
			break;
	}

	if (!field) {
		BURP_error_redirect (NULL, 36);
		// msg 36 Can't find field for blob
	}

	// Create new blob

	ISC_QUAD* blob_id = (ISC_QUAD*) ((UCHAR*) record_buffer + field->fld_offset);
	ISC_STATUS_ARRAY status_vector;
	UserBlob blob(status_vector);
	const UCHAR blob_desc[] = {isc_bpb_version1, isc_bpb_type, 1, blob_type};

	if (!blob.create(DB, gds_trans, *blob_id, sizeof(blob_desc), blob_desc))
	{
		BURP_error_redirect (status_vector, 37);
		// msg 37 isc_create_blob failed
	}

	// Allocate blob buffer if static buffer is too short
	BlobBuffer static_buffer;
	UCHAR* const buffer = static_buffer.getBuffer(max_segment);

	// Eat up blob segments

	for (; segments > 0; --segments )
	{
		USHORT length = get(tdgbl);
		length |= get(tdgbl) << 8;
		if (length)
		{
			get_block(tdgbl, buffer, length);
		}
		if (!blob.putSegment(length, buffer))
		{
			BURP_error_redirect (status_vector, 38);
			// msg 38 isc_put_segment failed
		}
	}

	if (!blob.close())
		BURP_error_redirect (status_vector, 23);
		// msg 23 isc_close_blob failed
}


void get_blr_blob(BurpGlobals* tdgbl, ISC_QUAD& blob_id, bool glb_trans)
{
/**************************************
 *
 *	g e t _ b l r _ b l o b
 *
 **************************************
 *
 * Functional description
 *	Read blob attributes and copy data from input file to nice,
 *	shiney, new blob.
 *
 **************************************/

	size_t length = get_numeric(tdgbl);

	// Create new blob

	isc_tr_handle local_trans;
	if (glb_trans && tdgbl->global_trans)
		local_trans = tdgbl->global_trans;
	else
		local_trans = gds_trans;

	ISC_STATUS_ARRAY	status_vector;
	UserBlob blob(status_vector);
	if (!blob.create(DB, local_trans, blob_id))
	{
		BURP_error_redirect (status_vector, 37);
		// msg 37 isc_create_blob failed
	}

	BlobBuffer static_buffer;
	UCHAR* const buffer = static_buffer.getBuffer(length + 1);

	if (length)
	{
		UCHAR* p = get_block(tdgbl, buffer, length);
		// Make sure it has an eoc
		if (p[-1] != blr_eoc) {
			p[0] = blr_eoc;
			length++;
		}
	}

	if (!blob.putData(length, buffer))
	{
		BURP_error_redirect (status_vector, 38);
		// msg 38 isc_put_segment failed
	}

	if (!blob.close())
		BURP_error_redirect (status_vector, 23);
		// msg 23 isc_close_blob failed
}

bool get_character_set(BurpGlobals* tdgbl)
{
   struct isc_720_struct {
          char  isc_721 [32];	/* RDB$FUNCTION_NAME */
          ISC_QUAD isc_722;	/* RDB$DESCRIPTION */
          char  isc_723 [32];	/* RDB$DEFAULT_COLLATE_NAME */
          char  isc_724 [32];	/* RDB$FORM_OF_USE */
          char  isc_725 [32];	/* RDB$CHARACTER_SET_NAME */
          ISC_LONG isc_726;	/* RDB$NUMBER_OF_CHARACTERS */
          short isc_727;	/* gds__null_flag */
          short isc_728;	/* RDB$BYTES_PER_CHARACTER */
          short isc_729;	/* gds__null_flag */
          short isc_730;	/* gds__null_flag */
          short isc_731;	/* gds__null_flag */
          short isc_732;	/* RDB$SYSTEM_FLAG */
          short isc_733;	/* gds__null_flag */
          short isc_734;	/* RDB$CHARACTER_SET_ID */
          short isc_735;	/* gds__null_flag */
          short isc_736;	/* gds__null_flag */
          short isc_737;	/* gds__null_flag */
          short isc_738;	/* gds__null_flag */
   } isc_720;
/**************************************
 *
 *	g e t _ c h a r a c t e r _ s e t
 *
 **************************************
 *
 * Functional description
 *	Restore data for user defined character sets
 *
 **************************************/
	class AbortException
	{
	};

	att_type		attribute;
	scan_attr_t		scan_next_attr;

	try
	{
		/*STORE (REQUEST_HANDLE tdgbl->handles_get_character_sets_req_handle1)
			X IN RDB$CHARACTER_SETS*/
		{
		
                if (!tdgbl->handles_get_character_sets_req_handle1)
                   isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &tdgbl->handles_get_character_sets_req_handle1, (short) sizeof(isc_719), (char*) isc_719);
		if (tdgbl->handles_get_character_sets_req_handle1)
		   {
		   isc_720.isc_722 = isc_blob_null;
			/*X.RDB$CHARACTER_SET_NAME.NULL*/
			isc_720.isc_738 = TRUE;
			/*X.RDB$FORM_OF_USE.NULL*/
			isc_720.isc_737 = TRUE;
			/*X.RDB$NUMBER_OF_CHARACTERS.NULL*/
			isc_720.isc_736 = TRUE;
			/*X.RDB$DEFAULT_COLLATE_NAME.NULL*/
			isc_720.isc_735 = TRUE;
			/*X.RDB$CHARACTER_SET_ID.NULL*/
			isc_720.isc_733 = TRUE;
			/*X.RDB$SYSTEM_FLAG*/
			isc_720.isc_732 = 0;
			/*X.RDB$SYSTEM_FLAG.NULL*/
			isc_720.isc_731 = FALSE;
			/*X.RDB$DESCRIPTION.NULL*/
			isc_720.isc_730 = TRUE;
			/*X.RDB$FUNCTION_NAME.NULL*/
			isc_720.isc_729 = TRUE;
			/*X.RDB$BYTES_PER_CHARACTER.NULL*/
			isc_720.isc_727 = TRUE;

			skip_init(&scan_next_attr);
			while (skip_scan(&scan_next_attr), get_attribute(&attribute, tdgbl) != att_end)
			{
				switch (attribute)
				{
				case att_charset_name:
					/*X.RDB$CHARACTER_SET_NAME.NULL*/
					isc_720.isc_738 = FALSE;
					GET_TEXT(/*X.RDB$CHARACTER_SET_NAME*/
						 isc_720.isc_725);
					BURP_verbose (msgVerbose_restore_charset, /*X.RDB$CHARACTER_SET_NAME*/
										  isc_720.isc_725);
					break;

				case att_charset_form:
					/*X.RDB$FORM_OF_USE.NULL*/
					isc_720.isc_737 = FALSE;
					GET_TEXT(/*X.RDB$FORM_OF_USE*/
						 isc_720.isc_724);
					break;

				case att_charset_numchar:
					/*X.RDB$NUMBER_OF_CHARACTERS.NULL*/
					isc_720.isc_736 = FALSE;
					/*X.RDB$NUMBER_OF_CHARACTERS*/
					isc_720.isc_726 = (USHORT) get_numeric(tdgbl);
					break;

				case att_charset_coll:
					/*X.RDB$DEFAULT_COLLATE_NAME.NULL*/
					isc_720.isc_735 = FALSE;
					GET_TEXT(/*X.RDB$DEFAULT_COLLATE_NAME*/
						 isc_720.isc_723);
					break;

				case att_charset_id:
					/*X.RDB$CHARACTER_SET_ID.NULL*/
					isc_720.isc_733 = FALSE;
					/*X.RDB$CHARACTER_SET_ID*/
					isc_720.isc_734 = (USHORT) get_numeric(tdgbl);
					break;

				case att_charset_sysflag:
					/*X.RDB$SYSTEM_FLAG.NULL*/
					isc_720.isc_731 = FALSE;
					/*X.RDB$SYSTEM_FLAG*/
					isc_720.isc_732 = (USHORT) get_numeric(tdgbl);
					break;

				case att_charset_description:
					/*X.RDB$DESCRIPTION.NULL*/
					isc_720.isc_730 = FALSE;
					get_source_blob (tdgbl, /*X.RDB$DESCRIPTION*/
								isc_720.isc_722, false);
					break;

				case att_charset_funct:
					/*X.RDB$FUNCTION_NAME.NULL*/
					isc_720.isc_729 = FALSE;
					GET_TEXT(/*X.RDB$FUNCTION_NAME*/
						 isc_720.isc_721);
					break;

				case att_charset_bytes_char:
					/*X.RDB$BYTES_PER_CHARACTER.NULL*/
					isc_720.isc_727 = FALSE;
					/*X.RDB$BYTES_PER_CHARACTER*/
					isc_720.isc_728 = (USHORT) get_numeric(tdgbl);
					break;

				default:
					bad_attribute (scan_next_attr, attribute, msgErr_restore_charset);
					// 213 character set
					break;
				}
			}

			if (/*X.RDB$CHARACTER_SET_ID.NULL*/
			    isc_720.isc_733 && !/*X.RDB$DEFAULT_COLLATE_NAME.NULL*/
     isc_720.isc_735 &&
				!/*X.RDB$CHARACTER_SET_NAME.NULL*/
				 isc_720.isc_738)
			{
				tdgbl->defaultCollations.add(
					Firebird::Pair<Firebird::NonPooled<Firebird::MetaName, Firebird::MetaName> >(
						/*X.RDB$CHARACTER_SET_NAME*/
						isc_720.isc_725, /*X.RDB$DEFAULT_COLLATE_NAME*/
  isc_720.isc_723));
				throw AbortException();	// prevent the STORE
			}

		/*END_STORE;*/
		   
                   isc_start_and_send (isc_status, (FB_API_HANDLE*) &tdgbl->handles_get_character_sets_req_handle1, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 164, &isc_720, (short) 0);
		   };
		/*ON_ERROR*/
		if (isc_status [1])
		   {
			general_on_error ();
		/*END_ERROR;*/
		   }
		}
	}
	catch (const AbortException&)
	{
	}

	return true;
}

bool get_chk_constraint(BurpGlobals* tdgbl)
{
   struct isc_714_struct {
          char  isc_715 [32];	/* RDB$TRIGGER_NAME */
          char  isc_716 [32];	/* RDB$CONSTRAINT_NAME */
          short isc_717;	/* gds__null_flag */
          short isc_718;	/* gds__null_flag */
   } isc_714;
/**************************************
 *
 *	g e t _ c h k _ c o n s t r a i n t
 *
 **************************************
 *
 * Functional description
 *	Restore data for check constraints.
 *
 **************************************/
	att_type		attribute;
	scan_attr_t		scan_next_attr;

	/*STORE (REQUEST_HANDLE tdgbl->handles_get_chk_constraint_req_handle1)
		X IN RDB$CHECK_CONSTRAINTS*/
	{
	
        if (!tdgbl->handles_get_chk_constraint_req_handle1)
           isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &tdgbl->handles_get_chk_constraint_req_handle1, (short) sizeof(isc_713), (char*) isc_713);
	if (tdgbl->handles_get_chk_constraint_req_handle1)
	   {
		/*X.RDB$CONSTRAINT_NAME.NULL*/
		isc_714.isc_718 = TRUE;
		/*X.RDB$TRIGGER_NAME.NULL*/
		isc_714.isc_717 = TRUE;

		skip_init(&scan_next_attr);
		while (skip_scan(&scan_next_attr), get_attribute(&attribute, tdgbl) != att_end)
		{
			switch (attribute)
			{
			case att_chk_constraint_name:
				/*X.RDB$CONSTRAINT_NAME.NULL*/
				isc_714.isc_718 = FALSE;
				GET_TEXT(/*X.RDB$CONSTRAINT_NAME*/
					 isc_714.isc_716);
				break;

			case att_chk_trigger_name:
				/*X.RDB$TRIGGER_NAME.NULL*/
				isc_714.isc_717 = FALSE;
				GET_TEXT(/*X.RDB$TRIGGER_NAME*/
					 isc_714.isc_715);
				break;

			default:
				bad_attribute (scan_next_attr, attribute, 286);
				// msg 286 check constraint
				break;
			}
		}
	/*END_STORE;*/
	   
           isc_start_and_send (isc_status, (FB_API_HANDLE*) &tdgbl->handles_get_chk_constraint_req_handle1, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 68, &isc_714, (short) 0);
	   };
	/*ON_ERROR*/
	if (isc_status [1])
	   {
		general_on_error ();
	/*END_ERROR;*/
	   }
	}

	return true;
}

bool get_collation(BurpGlobals* tdgbl)
{
   struct isc_674_struct {
          ISC_QUAD isc_675;	/* RDB$SPECIFIC_ATTRIBUTES */
          char  isc_676 [32];	/* RDB$BASE_COLLATION_NAME */
          char  isc_677 [32];	/* RDB$FUNCTION_NAME */
          ISC_QUAD isc_678;	/* RDB$DESCRIPTION */
          char  isc_679 [32];	/* RDB$COLLATION_NAME */
          short isc_680;	/* gds__null_flag */
          short isc_681;	/* gds__null_flag */
          short isc_682;	/* gds__null_flag */
          short isc_683;	/* gds__null_flag */
          short isc_684;	/* gds__null_flag */
          short isc_685;	/* RDB$SYSTEM_FLAG */
          short isc_686;	/* gds__null_flag */
          short isc_687;	/* RDB$COLLATION_ATTRIBUTES */
          short isc_688;	/* gds__null_flag */
          short isc_689;	/* RDB$CHARACTER_SET_ID */
          short isc_690;	/* gds__null_flag */
          short isc_691;	/* RDB$COLLATION_ID */
          short isc_692;	/* gds__null_flag */
   } isc_674;
   struct isc_694_struct {
          ISC_QUAD isc_695;	/* RDB$SPECIFIC_ATTRIBUTES */
          char  isc_696 [32];	/* RDB$BASE_COLLATION_NAME */
          char  isc_697 [32];	/* RDB$FUNCTION_NAME */
          ISC_QUAD isc_698;	/* RDB$DESCRIPTION */
          char  isc_699 [32];	/* RDB$COLLATION_NAME */
          short isc_700;	/* gds__null_flag */
          short isc_701;	/* gds__null_flag */
          short isc_702;	/* gds__null_flag */
          short isc_703;	/* gds__null_flag */
          short isc_704;	/* gds__null_flag */
          short isc_705;	/* RDB$SYSTEM_FLAG */
          short isc_706;	/* gds__null_flag */
          short isc_707;	/* RDB$COLLATION_ATTRIBUTES */
          short isc_708;	/* gds__null_flag */
          short isc_709;	/* RDB$CHARACTER_SET_ID */
          short isc_710;	/* gds__null_flag */
          short isc_711;	/* RDB$COLLATION_ID */
          short isc_712;	/* gds__null_flag */
   } isc_694;
/**************************************
 *
 *	g e t _ c o l l a t i o n
 *
 **************************************
 *
 * Functional description
 *	Restore data for user defined collations
 *
 **************************************/
	att_type		attribute;
	scan_attr_t		scan_next_attr;

	if (tdgbl->RESTORE_ods >= DB_VERSION_DDL11)
	{
		/*STORE (REQUEST_HANDLE tdgbl->handles_get_collation_req_handle1)
			X IN RDB$COLLATIONS*/
		{
		
                if (!tdgbl->handles_get_collation_req_handle1)
                   isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &tdgbl->handles_get_collation_req_handle1, (short) sizeof(isc_693), (char*) isc_693);
		if (tdgbl->handles_get_collation_req_handle1)
		   {
		   isc_694.isc_695 = isc_blob_null;
		   isc_694.isc_698 = isc_blob_null;
			/*X.RDB$COLLATION_NAME.NULL*/
			isc_694.isc_712 = TRUE;
			/*X.RDB$COLLATION_ID.NULL*/
			isc_694.isc_710 = TRUE;
			/*X.RDB$CHARACTER_SET_ID.NULL*/
			isc_694.isc_708 = TRUE;
			/*X.RDB$COLLATION_ATTRIBUTES.NULL*/
			isc_694.isc_706 = TRUE;
			/*X.RDB$SYSTEM_FLAG*/
			isc_694.isc_705 = 0;
			/*X.RDB$SYSTEM_FLAG.NULL*/
			isc_694.isc_704 = FALSE;
			/*X.RDB$DESCRIPTION.NULL*/
			isc_694.isc_703 = TRUE;
			/*X.RDB$FUNCTION_NAME.NULL*/
			isc_694.isc_702 = TRUE;
			/*X.RDB$BASE_COLLATION_NAME.NULL*/
			isc_694.isc_701 = TRUE;
			/*X.RDB$SPECIFIC_ATTRIBUTES.NULL*/
			isc_694.isc_700 = TRUE;

			skip_init(&scan_next_attr);
			while (skip_scan(&scan_next_attr), get_attribute(&attribute, tdgbl) != att_end)
			{
				switch (attribute)
				{

				case att_coll_name:
					/*X.RDB$COLLATION_NAME.NULL*/
					isc_694.isc_712 = FALSE;
					GET_TEXT(/*X.RDB$COLLATION_NAME*/
						 isc_694.isc_699);
					BURP_verbose(msgVerbose_restore_collation, /*X.RDB$COLLATION_NAME*/
										   isc_694.isc_699);
					break;

				case att_coll_id:
					/*X.RDB$COLLATION_ID.NULL*/
					isc_694.isc_710 = FALSE;
					/*X.RDB$COLLATION_ID*/
					isc_694.isc_711 = (USHORT) get_numeric(tdgbl);
					break;

				case att_coll_cs_id:
					/*X.RDB$CHARACTER_SET_ID.NULL*/
					isc_694.isc_708 = FALSE;
					/*X.RDB$CHARACTER_SET_ID*/
					isc_694.isc_709 = (USHORT) get_numeric(tdgbl);
					break;

				case att_coll_attr:
					/*X.RDB$COLLATION_ATTRIBUTES.NULL*/
					isc_694.isc_706 = FALSE;
					/*X.RDB$COLLATION_ATTRIBUTES*/
					isc_694.isc_707 = (USHORT) get_numeric(tdgbl);
					break;

				case att_coll_subtype:	// No longer used: 93-11-15 DBS
					// still present to handle V4 R&D gbak files
					get_numeric(tdgbl);
					break;

				case att_coll_sysflag:
					/*X.RDB$SYSTEM_FLAG.NULL*/
					isc_694.isc_704 = FALSE;
					/*X.RDB$SYSTEM_FLAG*/
					isc_694.isc_705 = (USHORT) get_numeric(tdgbl);
					break;

				case att_coll_description:
					/*X.RDB$DESCRIPTION.NULL*/
					isc_694.isc_703 = FALSE;
					get_source_blob (tdgbl, /*X.RDB$DESCRIPTION*/
								isc_694.isc_698, false);
					break;

				case att_coll_funct:
					/*X.RDB$FUNCTION_NAME.NULL*/
					isc_694.isc_702 = FALSE;
					GET_TEXT(/*X.RDB$FUNCTION_NAME*/
						 isc_694.isc_697);
					break;

				case att_coll_base_collation_name:
					if (tdgbl->RESTORE_format >= 7)
					{
						/*X.RDB$BASE_COLLATION_NAME.NULL*/
						isc_694.isc_701 = FALSE;
						GET_TEXT(/*X.RDB$BASE_COLLATION_NAME*/
							 isc_694.isc_696);
					}
					else
						bad_attribute (scan_next_attr, attribute, msgErr_restore_collation);
					break;

				case att_coll_specific_attr:
					if (tdgbl->RESTORE_format >= 7)
					{
						/*X.RDB$SPECIFIC_ATTRIBUTES.NULL*/
						isc_694.isc_700 = FALSE;
						get_source_blob (tdgbl, /*X.RDB$SPECIFIC_ATTRIBUTES*/
									isc_694.isc_695, false);
					}
					else
						bad_attribute (scan_next_attr, attribute, msgErr_restore_collation);
					break;

				default:
					bad_attribute (scan_next_attr, attribute, msgErr_restore_collation);
					// Msg 215 collation
					break;
				}
			}
		/*END_STORE;*/
		   
                   isc_start_and_send (isc_status, (FB_API_HANDLE*) &tdgbl->handles_get_collation_req_handle1, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 138, &isc_694, (short) 0);
		   };
		/*ON_ERROR*/
		if (isc_status [1])
		   {
			general_on_error ();
		/*END_ERROR;*/
		   }
		}
	}
	else
	{
		/*STORE (REQUEST_HANDLE tdgbl->handles_get_collation_req_handle1)
			X IN RDB$COLLATIONS*/
		{
		
                if (!tdgbl->handles_get_collation_req_handle1)
                   isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &tdgbl->handles_get_collation_req_handle1, (short) sizeof(isc_673), (char*) isc_673);
		if (tdgbl->handles_get_collation_req_handle1)
		   {
		   isc_674.isc_675 = isc_blob_null;
		   isc_674.isc_678 = isc_blob_null;
			/*X.RDB$COLLATION_NAME.NULL*/
			isc_674.isc_692 = TRUE;
			/*X.RDB$COLLATION_ID.NULL*/
			isc_674.isc_690 = TRUE;
			/*X.RDB$CHARACTER_SET_ID.NULL*/
			isc_674.isc_688 = TRUE;
			/*X.RDB$COLLATION_ATTRIBUTES.NULL*/
			isc_674.isc_686 = TRUE;
			/*X.RDB$SYSTEM_FLAG*/
			isc_674.isc_685 = 0;
			/*X.RDB$SYSTEM_FLAG.NULL*/
			isc_674.isc_684 = FALSE;
			/*X.RDB$DESCRIPTION.NULL*/
			isc_674.isc_683 = TRUE;
			/*X.RDB$FUNCTION_NAME.NULL*/
			isc_674.isc_682 = TRUE;
			/*X.RDB$BASE_COLLATION_NAME.NULL*/
			isc_674.isc_681 = TRUE;
			/*X.RDB$SPECIFIC_ATTRIBUTES.NULL*/
			isc_674.isc_680 = TRUE;

			skip_init(&scan_next_attr);
			while (skip_scan(&scan_next_attr), get_attribute(&attribute, tdgbl) != att_end)
			{
				switch (attribute)
				{

				case att_coll_name:
					/*X.RDB$COLLATION_NAME.NULL*/
					isc_674.isc_692 = FALSE;
					GET_TEXT(/*X.RDB$COLLATION_NAME*/
						 isc_674.isc_679);
					BURP_verbose(msgVerbose_restore_collation, /*X.RDB$COLLATION_NAME*/
										   isc_674.isc_679);
					break;

				case att_coll_id:
					/*X.RDB$COLLATION_ID.NULL*/
					isc_674.isc_690 = FALSE;
					/*X.RDB$COLLATION_ID*/
					isc_674.isc_691 = (USHORT) get_numeric(tdgbl);
					break;

				case att_coll_cs_id:
					/*X.RDB$CHARACTER_SET_ID.NULL*/
					isc_674.isc_688 = FALSE;
					/*X.RDB$CHARACTER_SET_ID*/
					isc_674.isc_689 = (USHORT) get_numeric(tdgbl);
					break;

				case att_coll_attr:
					/*X.RDB$COLLATION_ATTRIBUTES.NULL*/
					isc_674.isc_686 = FALSE;
					/*X.RDB$COLLATION_ATTRIBUTES*/
					isc_674.isc_687 = (USHORT) get_numeric(tdgbl);
					break;

				case att_coll_subtype:	// No longer used: 93-11-15 DBS
					// still present to handle V4 R&D gbak files
					get_numeric(tdgbl);
					break;

				case att_coll_sysflag:
					/*X.RDB$SYSTEM_FLAG.NULL*/
					isc_674.isc_684 = FALSE;
					/*X.RDB$SYSTEM_FLAG*/
					isc_674.isc_685 = (USHORT) get_numeric(tdgbl);
					break;

				case att_coll_description:
					/*X.RDB$DESCRIPTION.NULL*/
					isc_674.isc_683 = FALSE;
					get_source_blob (tdgbl, /*X.RDB$DESCRIPTION*/
								isc_674.isc_678, false);
					break;

				case att_coll_funct:
					/*X.RDB$FUNCTION_NAME.NULL*/
					isc_674.isc_682 = FALSE;
					GET_TEXT(/*X.RDB$FUNCTION_NAME*/
						 isc_674.isc_677);
					break;

				case att_coll_base_collation_name:
					if (tdgbl->RESTORE_format >= 7)
						eat_text(tdgbl);
					else
						bad_attribute (scan_next_attr, attribute, msgErr_restore_collation);
					break;

				case att_coll_specific_attr:
					if (tdgbl->RESTORE_format >= 7)
						eat_blob(tdgbl);
					else
						bad_attribute (scan_next_attr, attribute, msgErr_restore_collation);
					break;

				default:
					bad_attribute (scan_next_attr, attribute, msgErr_restore_collation);
					// Msg 215 collation
					break;
				}
			}
		/*END_STORE;*/
		   
                   isc_start_and_send (isc_status, (FB_API_HANDLE*) &tdgbl->handles_get_collation_req_handle1, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 138, &isc_674, (short) 0);
		   };
		/*ON_ERROR*/
		if (isc_status [1])
		   {
			general_on_error ();
		/*END_ERROR;*/
		   }
		}
	}

	return true;
}

rec_type get_data(BurpGlobals* tdgbl, burp_rel* relation)
{
   struct isc_671_struct {
          short isc_672;	/* isc_utility */
   } isc_671;
   struct isc_669_struct {
          short isc_670;	/* RDB$INDEX_INACTIVE */
   } isc_669;
   struct isc_666_struct {
          short isc_667;	/* isc_utility */
          short isc_668;	/* RDB$INDEX_INACTIVE */
   } isc_666;
   struct isc_664_struct {
          char  isc_665 [32];	/* RDB$INDEX_NAME */
   } isc_664;
/**************************************
 *
 *	g e t _ d a t a
 *
 **************************************
 *
 * Functional description
 *	Write data records for a relation.
 *
 **************************************/
	isc_req_handle  req_handle = 0;
	/*BASED_ON RDB$INDICES.RDB$INDEX_NAME index_name;*/
	char
	   index_name[32];


	// If we're only doing meta-data, ignore data records

	if (tdgbl->gbl_sw_meta)
		return ignore_data(tdgbl, relation);

	// Start by counting the interesting fields

	RCRD_OFFSET offset = 0;
	ULONG length = 0;
	USHORT count = 0;

	burp_fld* field;
	for (field = relation->rel_fields; field; field = field->fld_next)
	{
		if (!(field->fld_flags & FLD_computed))
		{
			count++;
			length += field->fld_name_length;
		}
	}

	if (tdgbl->RESTORE_format >= 2)
		count += count;

	// Time to generate blr to store data.  Whoppee.

	UCHAR* const blr_buffer = (UCHAR*) BURP_alloc (200 + length + count * 18);
	UCHAR* blr = blr_buffer;

	add_byte(blr, blr_version4);
	add_byte(blr, blr_begin);
	add_byte(blr, blr_message);
	add_byte(blr, 0);				// Message number
	add_word(blr, count);	// Number of fields, counting eof

	// Let's reset count.
	count = 0;

	for (field = relation->rel_fields; field; field = field->fld_next)
	{
		if (field->fld_flags & FLD_computed)
			continue;

		// arrays are of various fld_types but are really blobs

		SSHORT dtype = field->fld_type;
		length = field->fld_length;
		SSHORT alignment = 4;

		if (field->fld_flags & FLD_array)
			dtype = blr_blob;

		if (dtype <= DTYPE_BLR_MAX)
		{
			USHORT l = gds_cvt_blr_dtype[dtype];
			alignment = type_alignments[l];
			if (l = type_lengths[l])
				length = l;
		}

		switch (dtype)
		{
		case blr_text:
		case blr_varying:
			if (dtype == blr_text)
				add_byte(blr, blr_text2);
			else
				add_byte(blr, blr_varying2);

			if (tdgbl->gbl_sw_fix_fss_data && field->fld_character_set_id == CS_UNICODE_FSS)
				add_word(blr, tdgbl->gbl_sw_fix_fss_data_id);
			else
				add_word(blr, field->fld_character_set_id);

			add_word(blr, field->fld_length);
			if (dtype == blr_varying)
				length += sizeof(USHORT);
			break;

		case blr_short:
		case blr_long:
		case blr_quad:
		case blr_int64:
			add_byte(blr, field->fld_type);
			add_byte(blr, field->fld_scale);
			break;

		case blr_float:
		case blr_double:
		case blr_timestamp:
		case blr_sql_time:
		case blr_sql_date:
			add_byte(blr, field->fld_type);
			break;

		case blr_blob:
			alignment = type_alignments[dtype_blob];
			length = type_lengths[dtype_blob];

			if (tdgbl->gbl_sw_fix_fss_data && !(field->fld_flags & FLD_array) &&
				field->fld_sub_type == isc_blob_text && field->fld_character_set_id == CS_UNICODE_FSS)
			{
				add_byte(blr, blr_blob2);
				add_word(blr, field->fld_sub_type);
				add_word(blr, tdgbl->gbl_sw_fix_fss_data_id);
			}
			else
			{
				add_byte(blr, blr_quad);
				add_byte(blr, 0);
			}

			break;

		default:
			BURP_error(26, true, SafeArg() << field->fld_type);
			// msg 26 datatype %ld not understood
			break;
		}
		if (alignment)
			offset = FB_ALIGN(offset, alignment);
		field->fld_offset = offset;
		field->fld_parameter = count++;
		offset += length;
	}

	// If this is format version 2, build fields for null flags

	if (tdgbl->RESTORE_format >= 2)
		for (field = relation->rel_fields; field; field = field->fld_next)
		{
			if (field->fld_flags & FLD_computed)
				continue;
			add_byte(blr, blr_short);
			add_byte(blr, 0);
			offset = FB_ALIGN(offset, sizeof(SSHORT));
			field->fld_missing_parameter = count++;
			offset += sizeof(SSHORT);
		}

	length = offset;

	// Build STORE statement

	add_byte(blr, blr_loop);
	add_byte(blr, blr_receive);
	add_byte(blr, 0);
	add_byte(blr, blr_store);
	add_byte(blr, blr_relation);
	add_string(blr, relation->rel_name);
	add_byte(blr, 0);			// context variable
	add_byte(blr, blr_begin);

	for (field = relation->rel_fields; field; field = field->fld_next)
	{
		if (field->fld_flags & FLD_computed)
			continue;
		add_byte(blr, blr_assignment);
		if (tdgbl->RESTORE_format >= 2)
		{
			add_byte(blr, blr_parameter2);
			add_byte(blr, 0);
			add_word(blr, field->fld_parameter);
			add_word(blr, field->fld_missing_parameter);
		}
		else
		{
			add_byte(blr, blr_parameter);
			add_byte(blr, 0);
			add_word(blr, field->fld_parameter);
		}
		add_byte(blr, blr_field);
		add_byte(blr, 0);
		add_string(blr, field->fld_name);
	}

	add_byte(blr, blr_end);
	add_byte(blr, blr_end);
	add_byte(blr, blr_eoc);

	// Compile request

	USHORT blr_length = blr - blr_buffer;

#ifdef DEBUG
	fb_print_blr(blr_buffer, blr_length, NULL, NULL, 0);
#endif

	FB_API_HANDLE request = 0;
	ISC_STATUS_ARRAY status_vector;

	if (isc_compile_request (status_vector, &DB, &request,
							 blr_length, reinterpret_cast<const char*>(blr_buffer)))
	{
		fb_print_blr(blr_buffer, blr_length, NULL, NULL, 0);
		if (!tdgbl->gbl_sw_incremental)
			BURP_error_redirect (status_vector, 27);
			// msg 27 isc_compile_request failed
		else
		{
			BURP_print_status (false, status_vector);
			BURP_free (blr_buffer);
			return ignore_data(tdgbl, relation);
		}
	}

	BURP_free (blr_buffer);
	SSHORT* buffer = NULL;

	BURP_verbose (124, relation->rel_name);
	// msg 124  restoring data for relation %s

	lstring data;
	data.lstr_allocated = 0;
	data.lstr_address = NULL;
	ULONG old_length = 0;

	ULONG records = 0;
	rec_type record;

	while (true)
	{
		if (get(tdgbl) != att_data_length)
			BURP_error_redirect (NULL, 39);
			// msg 39 expected record length
		USHORT l = (USHORT) get_numeric(tdgbl);
		if (!tdgbl->gbl_sw_transportable && l != length)
		{
#ifdef sparc
			if (!old_length)
				old_length = recompute_length(tdgbl, relation);
#endif
			if (l != old_length)
			{
				BURP_error(40, true, SafeArg() << length << l);
				// msg 40 wrong length record, expected %ld encountered %ld
			}
		}
		if (!buffer) {
			buffer = (SSHORT *) BURP_alloc (MAX (length, l));
		}

		UCHAR* p;
		if (tdgbl->gbl_sw_transportable)
		{
			if (get(tdgbl) != att_xdr_length)
				BURP_error_redirect (NULL, 55);
				// msg 55 Expected XDR record length
			else
			{
				data.lstr_length = l = (USHORT) get_numeric(tdgbl);
				if (l > data.lstr_allocated)
				{
					data.lstr_allocated = l;
					if (data.lstr_address)
						BURP_free (data.lstr_address);
					data.lstr_address = BURP_alloc(data.lstr_allocated);
				}
				p = data.lstr_address;
			}
		}
		else
			p = reinterpret_cast<UCHAR*>(buffer);
		if (get(tdgbl) != att_data_data)
			BURP_error_redirect (NULL, 41);
			// msg 41 expected data attribute

		if (tdgbl->gbl_sw_compress)
			decompress (tdgbl, p, l);
		else
		{
			get_block(tdgbl, p, l);
		}

		if (old_length)
			realign (tdgbl, (UCHAR*) buffer, relation);

		if (tdgbl->gbl_sw_transportable)
			CAN_encode_decode (relation, &data, (UCHAR *)buffer, FALSE);

		records++;

		if ((records % RESTORE_VERBOSE_INTERVAL) == 0)
			BURP_verbose(107, SafeArg() << records);

		for (field = relation->rel_fields; field; field = field->fld_next)
		{
			if (!(field->fld_flags & FLD_computed))
			{
				if (field->fld_type == blr_blob || (field->fld_flags & FLD_array))
				{
					ISC_QUAD* blob_id = (ISC_QUAD*) ((SCHAR*) buffer + field->fld_offset);
					blob_id->gds_quad_high = 0;
					blob_id->gds_quad_low = 0;
				}
			}
		}

		get_record(&record, tdgbl);
		while (record == rec_blob || record == rec_array)
		{
			if (record == rec_blob)
				get_blob (tdgbl, relation->rel_fields, (UCHAR *) buffer);
			else if (record == rec_array)
				get_array (tdgbl, relation, (UCHAR *) buffer);
			get_record(&record, tdgbl);
		}

		ISC_STATUS s;

		// ASF: Preferable we should call isc_start_and_send only when records == 1, but this leaks
		// memory when there are blobs and arrays fields - CORE-3802.
		if (records % 1000 == 1)
			s = isc_start_and_send(status_vector, &request, &gds_trans, 0, (USHORT) length, buffer, 0);
		else
			s = isc_send(status_vector, &request, 0, (USHORT) length, buffer, 0);

		if (s)
		{
			if (status_vector[1] == isc_not_valid)
			{
				if (tdgbl->gbl_sw_incremental)
				{
					BURP_print (false, 138, relation->rel_name);
					// msg 138 validation error on field in relation %s
					BURP_print_status (false, status_vector);
				}
				else
					BURP_error_redirect (status_vector, 47);
					// msg 47 warning -- record could not be restored
			}
			else if (status_vector[1] == isc_malformed_string)
			{
				if (tdgbl->gbl_sw_incremental)
				{
					// msg 114 restore failed for record in relation %s
					BURP_print(false, 114, relation->rel_name);

					BURP_print_status(false, status_vector);
					BURP_print(false, 342);	// isc_gbak_invalid_data
				}
				else
					BURP_error_redirect(status_vector, 342);	// isc_gbak_invalid_data
			}
			else
			{
				if (tdgbl->gbl_sw_incremental)
				{
					BURP_print (false, 114, relation->rel_name);
					// msg 114 restore failed for record in relation %s
					BURP_print_status (false, status_vector);
				}
				else
					BURP_error_redirect (status_vector, 48);
					// msg 48 isc_send failed
			}
		}
		if (record != rec_data)
			break;
	} // while (true)

	BURP_free (buffer);
	if (data.lstr_address)
		BURP_free (data.lstr_address);

	isc_release_request(status_vector, &request);
	if (tdgbl->gbl_sw_incremental)
	{
		BURP_verbose (72, relation->rel_name);
		// msg 72  committing data for relation %s
		/*COMMIT*/
		{
		isc_commit_transaction (isc_status, (FB_API_HANDLE*) &gds_trans);;
		// existing ON_ERROR continues past error, beck
		/*ON_ERROR*/
		if (isc_status [1])
		   {

			// Fix for bug_no 8055:
			// don't throw away the database just because an index
			// could not be made

			// don't bring the database on-line
			tdgbl->flag_on_line = false;
			ISC_STATUS error_code;
			while (error_code = tdgbl->status_vector[1])
			{
				switch (error_code)
				{
					case isc_sort_mem_err:
					case isc_no_dup:
						strcpy(index_name, (TEXT *)tdgbl->status_vector[3]);
						BURP_print_status(false, tdgbl->status_vector);
						/*FOR (REQUEST_HANDLE req_handle)
						 IDX IN RDB$INDICES WITH IDX.RDB$INDEX_NAME EQ index_name*/
						{
                                                if (!req_handle)
                                                   isc_compile_request (NULL, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &req_handle, (short) sizeof(isc_663), (char*) isc_663);
						isc_vtov ((const char*) index_name, (char*) isc_664.isc_665, 32);
                                                isc_start_and_send (NULL, (FB_API_HANDLE*) &req_handle, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 32, &isc_664, (short) 0);
						while (1)
						   {
                                                   isc_receive (NULL, (FB_API_HANDLE*) &req_handle, (short) 1, (short) 4, &isc_666, (short) 0);
						   if (!isc_666.isc_667) break;
							/*MODIFY IDX USING*/
							{
								/*IDX.RDB$INDEX_INACTIVE*/
								isc_666.isc_668 = TRUE;
								BURP_print(false, 240, index_name);
								// msg 240 Index \"%s\" failed to activate because:
								if ( error_code == isc_no_dup )
								{
									BURP_print(false, 241);
									// msg 241 The unique index has duplicate values or NULLs
									BURP_print(false, 242);
									// msg 242 Delete or Update duplicate values or NULLs, and activate index with
								}
								else
								{
									BURP_print(false, 244);
									// msg 244 Not enough disk space to create the sort file for an index
									BURP_print(false, 245);
									// msg 245 Set the TMP environment variable to a directory on a filesystem that does have enough space, and activate index with
								}
								BURP_print(false, 243, index_name);
								// msg 243 ALTER INDEX \"%s\" ACTIVE
							/*END_MODIFY;*/
							isc_669.isc_670 = isc_666.isc_668;
                                                        isc_send (NULL, (FB_API_HANDLE*) &req_handle, (short) 2, (short) 2, &isc_669, (short) 0);
							}
						/*END_FOR;*/
                                                   isc_send (NULL, (FB_API_HANDLE*) &req_handle, (short) 3, (short) 2, &isc_671, (short) 0);
						   }
						}
						// commit one more time
						/*COMMIT*/
						{
						isc_commit_transaction (isc_status, (FB_API_HANDLE*) &gds_trans);;
						/*ON_ERROR*/
						if (isc_status [1])
						   {
							continue;
						/*END_ERROR*/
						   }
						}
						break;
					default:
						BURP_print (false, 69, relation->rel_name);
						// msg 69 commit failed on relation %s
						BURP_print_status (false, tdgbl->status_vector);
						/*ROLLBACK;*/
						{
						isc_rollback_transaction (isc_status, (FB_API_HANDLE*) &gds_trans);;
						/*ON_ERROR*/
						if (isc_status [1])
						   {
							general_on_error ();
						/*END_ERROR;*/
						   }
						}
						break;
				} // end of switch
			} // end of while
		/*END_ERROR;*/
		   }
		}

		/*EXEC SQL SET TRANSACTION NO_AUTO_UNDO;*/
		{
		isc_start_transaction (isc_status, (FB_API_HANDLE*) &gds_trans, (short) 1, &DB, (short) 5, isc_tpb_9);
		SQLCODE = isc_sqlcode(isc_status);
		}
		if (gds_status[1])
			/*EXEC SQL SET TRANSACTION;*/
			{
			isc_start_transaction (isc_status, (FB_API_HANDLE*) &gds_trans, (short) 1, &DB, (short) 4, isc_tpb_10);
			SQLCODE = isc_sqlcode(isc_status);
			}
	}
	BURP_verbose (107, SafeArg() << records);
	// msg 107 %ld records restored

	return record;
}

bool get_exception(BurpGlobals* tdgbl)
{
   struct isc_654_struct {
          char  isc_655 [1024];	/* RDB$MESSAGE */
          ISC_QUAD isc_656;	/* RDB$DESCRIPTION */
          char  isc_657 [32];	/* RDB$EXCEPTION_NAME */
          short isc_658;	/* gds__null_flag */
          short isc_659;	/* RDB$SYSTEM_FLAG */
          short isc_660;	/* gds__null_flag */
          short isc_661;	/* gds__null_flag */
          short isc_662;	/* gds__null_flag */
   } isc_654;
/**************************************
 *
 *	g e t _ e x c e p t i o n
 *
 **************************************
 *
 * Functional description
 *	Reconstruct a exception.
 *
 **************************************/
	att_type	attribute;
	TEXT		temp[GDS_NAME_LEN];
	ULONG		l2 = 0;
	scan_attr_t		scan_next_attr;

	/*STORE (REQUEST_HANDLE tdgbl->handles_get_exception_req_handle1)
		X IN RDB$EXCEPTIONS*/
	{
	
        if (!tdgbl->handles_get_exception_req_handle1)
           isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &tdgbl->handles_get_exception_req_handle1, (short) sizeof(isc_653), (char*) isc_653);
	if (tdgbl->handles_get_exception_req_handle1)
	   {
	   isc_654.isc_656 = isc_blob_null;
		/*X.RDB$EXCEPTION_NAME.NULL*/
		isc_654.isc_662 = TRUE;
		/*X.RDB$DESCRIPTION.NULL*/
		isc_654.isc_661 = TRUE;
		/*X.RDB$MESSAGE.NULL*/
		isc_654.isc_660 = TRUE;
		/*X.RDB$SYSTEM_FLAG*/
		isc_654.isc_659 = 0;
		/*X.RDB$SYSTEM_FLAG.NULL*/
		isc_654.isc_658 = FALSE;

		att_type failed_attrib = att_end;
		bool msg_seen = false; // only for att_exception_msg, not att_exception_msg2
		UCHAR* msg_ptr = reinterpret_cast<UCHAR*>(/*X.RDB$MESSAGE*/
							  isc_654.isc_655);

		skip_init(&scan_next_attr);
		while (skip_scan(&scan_next_attr), get_attribute(&attribute, tdgbl) != att_end)
		{
			switch (attribute)
			{
			case att_exception_name:
				if (!/*X.RDB$EXCEPTION_NAME.NULL*/
				     isc_654.isc_662)
					BURP_error(311, true, SafeArg() << att_exception_name << /*X.RDB$EXCEPTION_NAME*/
												 isc_654.isc_657);
				else
				{
					const ULONG l = GET_TEXT(/*X.RDB$EXCEPTION_NAME*/
								 isc_654.isc_657);
					/*X.RDB$EXCEPTION_NAME.NULL*/
					isc_654.isc_662 = FALSE;
					MISC_terminate (/*X.RDB$EXCEPTION_NAME*/
							isc_654.isc_657, temp, l, sizeof(temp));
					BURP_verbose (199, temp);
					// msg 199 restoring exception %s
				}
				break;

			case att_exception_description:
				if (!/*X.RDB$DESCRIPTION.NULL*/
				     isc_654.isc_661)
					BURP_error(311, true, SafeArg() << att_exception_description << /*X.RDB$EXCEPTION_NAME*/
													isc_654.isc_657);
				else
				{
					msg_seen = false;
					get_misc_blob (tdgbl, /*X.RDB$DESCRIPTION*/
							      isc_654.isc_656, false);
					/*X.RDB$DESCRIPTION.NULL*/
					isc_654.isc_661 = FALSE;
				}
				break;

			case att_exception_description2:
				if (!/*X.RDB$DESCRIPTION.NULL*/
				     isc_654.isc_661)
					BURP_error(311, true, SafeArg() << att_exception_description2 << /*X.RDB$EXCEPTION_NAME*/
													 isc_654.isc_657);
				else
				{
					msg_seen = false;
					get_source_blob (tdgbl, /*X.RDB$DESCRIPTION*/
								isc_654.isc_656, false);
					/*X.RDB$DESCRIPTION.NULL*/
					isc_654.isc_661 = FALSE;
				}
				break;

			case att_exception_msg:
				if (msg_seen)
					BURP_error(311, true, SafeArg() << att_exception_msg << /*X.RDB$EXCEPTION_NAME*/
												isc_654.isc_657);
				else if (!/*X.RDB$MESSAGE.NULL*/
					  isc_654.isc_660)
				{
					msg_seen = true;
					BURP_print(true, 312, SafeArg() << att_exception_msg << /*X.RDB$EXCEPTION_NAME*/
												isc_654.isc_657);
					eat_text(tdgbl);
				}
				else
				{
					msg_seen = true;
					l2 = GET_TEXT(/*X.RDB$MESSAGE*/
						      isc_654.isc_655);
					msg_ptr += l2;
					/*X.RDB$MESSAGE.NULL*/
					isc_654.isc_660 = FALSE;
				}
				break;

			case att_exception_msg2:
				if (msg_seen)
					BURP_error(311, true, SafeArg() << att_exception_msg2 << /*X.RDB$EXCEPTION_NAME*/
												 isc_654.isc_657);
				else if (!/*X.RDB$MESSAGE.NULL*/
					  isc_654.isc_660)
				{
					BURP_print(true, 312, SafeArg() << att_exception_msg2 << /*X.RDB$EXCEPTION_NAME*/
												 isc_654.isc_657);
					eat_text2(tdgbl);
				}
				else
				{
					GET_TEXT2(/*X.RDB$MESSAGE*/
						  isc_654.isc_655);
					/*X.RDB$MESSAGE.NULL*/
					isc_654.isc_660 = FALSE;
				}
				break;

			default:
				if (msg_seen && (tdgbl->RESTORE_format == 7 || tdgbl->RESTORE_format == 8))
				{
					 // we have a corrupt backup
					if (!failed_attrib)
					{
						failed_attrib = attribute;
						BURP_print(true, 313, SafeArg() << failed_attrib << /*X.RDB$EXCEPTION_NAME*/
												    isc_654.isc_657);
					}

					// Notice we use 1021 instead of 1023 because this is the maximum length
					// for this field in v2.0 and v2.1 and they produce the corrupt backups.
					const int FIELD_LIMIT = 1021;

					const int remaining = FIELD_LIMIT - l2;
					if (remaining < 1) // not enough space
					{
						bad_attribute(scan_next_attr, failed_attrib, 287);
						break;
					}
					*msg_ptr++ = char(attribute); // (1)
					UCHAR* rc_ptr = get_block(tdgbl, msg_ptr, MIN(remaining - 1, 255));
					if (remaining > 1 && rc_ptr == msg_ptr) // we couldn't read anything
					{
						bad_attribute(scan_next_attr, failed_attrib, 287);
						break;
					}
					l2 += rc_ptr - msg_ptr + 1; // + 1 because (1)
					msg_ptr = rc_ptr;
					*msg_ptr = 0;
					if (l2 == FIELD_LIMIT)
						msg_seen = false;
				}
				else
					bad_attribute(scan_next_attr, attribute, 287); // msg 287 exception
				break;
			}
		}
		// Versions prior to FB2.0 don't support a field longer than varchar(78).
		// Versions prior to FB2.5 use a field length of 1021, not 1023.
		if (tdgbl->RESTORE_ods < DB_VERSION_DDL11)
			/*X.RDB$MESSAGE*/
			isc_654.isc_655[78] = 0;
		else if (tdgbl->RESTORE_ods < DB_VERSION_DDL11_2)
			/*X.RDB$MESSAGE*/
			isc_654.isc_655[1021] = 0;
	/*END_STORE;*/
	   
           isc_start_and_send (isc_status, (FB_API_HANDLE*) &tdgbl->handles_get_exception_req_handle1, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 1074, &isc_654, (short) 0);
	   };
	/*ON_ERROR*/
	if (isc_status [1])
	   {
		general_on_error ();
	/*END_ERROR;*/
	   }
	}

	return true;
}


burp_fld* get_field(BurpGlobals* tdgbl, burp_rel* relation)
{
   struct isc_619_struct {
          char  isc_620 [32];	/* RDB$FIELD_SOURCE */
          char  isc_621 [32];	/* RDB$FIELD_NAME */
          ISC_QUAD isc_622;	/* RDB$DEFAULT_VALUE */
          ISC_QUAD isc_623;	/* RDB$DEFAULT_SOURCE */
          char  isc_624 [32];	/* RDB$COMPLEX_NAME */
          ISC_QUAD isc_625;	/* RDB$DESCRIPTION */
          char  isc_626 [128];	/* RDB$EDIT_STRING */
          ISC_QUAD isc_627;	/* RDB$QUERY_HEADER */
          char  isc_628 [32];	/* RDB$QUERY_NAME */
          char  isc_629 [32];	/* RDB$SECURITY_CLASS */
          char  isc_630 [32];	/* RDB$BASE_FIELD */
          char  isc_631 [32];	/* RDB$RELATION_NAME */
          short isc_632;	/* gds__null_flag */
          short isc_633;	/* RDB$COLLATION_ID */
          short isc_634;	/* gds__null_flag */
          short isc_635;	/* RDB$NULL_FLAG */
          short isc_636;	/* gds__null_flag */
          short isc_637;	/* gds__null_flag */
          short isc_638;	/* gds__null_flag */
          short isc_639;	/* RDB$UPDATE_FLAG */
          short isc_640;	/* gds__null_flag */
          short isc_641;	/* gds__null_flag */
          short isc_642;	/* RDB$SYSTEM_FLAG */
          short isc_643;	/* gds__null_flag */
          short isc_644;	/* gds__null_flag */
          short isc_645;	/* gds__null_flag */
          short isc_646;	/* gds__null_flag */
          short isc_647;	/* gds__null_flag */
          short isc_648;	/* gds__null_flag */
          short isc_649;	/* gds__null_flag */
          short isc_650;	/* gds__null_flag */
          short isc_651;	/* RDB$VIEW_CONTEXT */
          short isc_652;	/* RDB$FIELD_POSITION */
   } isc_619;
/**************************************
 *
 *	g e t _ f i e l d
 *
 **************************************
 *
 * Functional description
 *	Reconstruct a local field.
 *
 **************************************/
	att_type		attribute;
	scan_attr_t		scan_next_attr;

	// If it is a view and there is a global transaction then use it
	bool global_tr = false;
	isc_tr_handle local_trans;
	if ((relation->rel_flags & REL_view) && tdgbl->global_trans)
	{
		local_trans = tdgbl->global_trans;
		global_tr = true;
	}
	else
		local_trans = gds_trans;

	burp_fld* field = (burp_fld*) BURP_alloc_zero (sizeof(burp_fld));

	/*STORE (TRANSACTION_HANDLE local_trans
			REQUEST_HANDLE tdgbl->handles_get_field_req_handle1)
		X IN RDB$RELATION_FIELDS*/
	{
	
        if (!tdgbl->handles_get_field_req_handle1)
           isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &tdgbl->handles_get_field_req_handle1, (short) sizeof(isc_618), (char*) isc_618);
	if (tdgbl->handles_get_field_req_handle1)
	   {
	   isc_619.isc_622 = isc_blob_null;
	   isc_619.isc_623 = isc_blob_null;
	   isc_619.isc_625 = isc_blob_null;
	   isc_619.isc_627 = isc_blob_null;
		strcpy (/*X.RDB$RELATION_NAME*/
			isc_619.isc_631, relation->rel_name);
		/*X.RDB$FIELD_POSITION*/
		isc_619.isc_652 = 0;
		/*X.RDB$VIEW_CONTEXT.NULL*/
		isc_619.isc_650 = TRUE;
		/*X.RDB$BASE_FIELD.NULL*/
		isc_619.isc_649 = TRUE;
		/*X.RDB$SECURITY_CLASS.NULL*/
		isc_619.isc_648 = TRUE;
		/*X.RDB$QUERY_NAME.NULL*/
		isc_619.isc_647 = TRUE;
		/*X.RDB$QUERY_HEADER.NULL*/
		isc_619.isc_646 = TRUE;
		/*X.RDB$EDIT_STRING.NULL*/
		isc_619.isc_645 = TRUE;
		/*X.RDB$DESCRIPTION.NULL*/
		isc_619.isc_644 = TRUE;
		/*X.RDB$FIELD_POSITION.NULL*/
		isc_619.isc_643 = TRUE;
		/*X.RDB$SYSTEM_FLAG*/
		isc_619.isc_642 = 0;
		/*X.RDB$SYSTEM_FLAG.NULL*/
		isc_619.isc_641 = FALSE;
		/*X.RDB$COMPLEX_NAME.NULL*/
		isc_619.isc_640 = TRUE;
		/*X.RDB$UPDATE_FLAG.NULL*/
		isc_619.isc_638 = TRUE;
		/*X.RDB$DEFAULT_SOURCE.NULL*/
		isc_619.isc_637 = TRUE;
		/*X.RDB$DEFAULT_VALUE.NULL*/
		isc_619.isc_636 = TRUE;
		/*X.RDB$NULL_FLAG.NULL*/
		isc_619.isc_634 = TRUE;
		/*X.RDB$COLLATION_ID.NULL*/
		isc_619.isc_632 = TRUE;

		skip_init(&scan_next_attr);
		while (get_attribute(&attribute, tdgbl) != att_end)
		{
			switch (skip_scan(&scan_next_attr), attribute)
			{
			case att_field_name:
				field->fld_name_length = GET_TEXT(field->fld_name);
				BURP_verbose (115, field->fld_name);
				// msg 115 restoring field %s
				strcpy (/*X.RDB$FIELD_NAME*/
					isc_619.isc_621, field->fld_name);
				break;

			case att_field_source:
				GET_TEXT(/*X.RDB$FIELD_SOURCE*/
					 isc_619.isc_620);
				break;

			case att_field_security_class:
				GET_TEXT(/*X.RDB$SECURITY_CLASS*/
					 isc_619.isc_629);
				fix_security_class_name(tdgbl, /*X.RDB$SECURITY_CLASS*/
							       isc_619.isc_629, true);
				/*X.RDB$SECURITY_CLASS.NULL*/
				isc_619.isc_648 = FALSE;
				break;

			case att_field_query_name:
				GET_TEXT(/*X.RDB$QUERY_NAME*/
					 isc_619.isc_628);
				/*X.RDB$QUERY_NAME.NULL*/
				isc_619.isc_647 = FALSE;
				break;

			case att_field_query_header:
				/*X.RDB$QUERY_HEADER.NULL*/
				isc_619.isc_646 = FALSE;
				get_source_blob (tdgbl, /*X.RDB$QUERY_HEADER*/
							isc_619.isc_627, global_tr);
				break;

			case att_field_edit_string:
				GET_TEXT(/*X.RDB$EDIT_STRING*/
					 isc_619.isc_626);
				/*X.RDB$EDIT_STRING.NULL*/
				isc_619.isc_645 = FALSE;
				break;

			case att_field_position:
				/*X.RDB$FIELD_POSITION.NULL*/
				isc_619.isc_643 = FALSE;
				/*X.RDB$FIELD_POSITION*/
				isc_619.isc_652 = (USHORT) get_numeric(tdgbl);
				break;

			case att_field_number:
				field->fld_number = (USHORT) get_numeric(tdgbl);
				break;

			case att_field_type:
				field->fld_type = (USHORT) get_numeric(tdgbl);
				break;

			case att_field_length:
				field->fld_length = (USHORT) get_numeric(tdgbl);
				break;

			case att_field_scale:
				field->fld_scale = (USHORT) get_numeric(tdgbl);
				break;

			case att_field_sub_type:
				field->fld_sub_type = (USHORT) get_numeric(tdgbl);
				break;

			case att_field_system_flag:
				/*X.RDB$SYSTEM_FLAG*/
				isc_619.isc_642 = (USHORT) get_numeric(tdgbl);
				/*X.RDB$SYSTEM_FLAG.NULL*/
				isc_619.isc_641 = FALSE;
				break;

			case att_view_context:
				/*X.RDB$VIEW_CONTEXT*/
				isc_619.isc_651 = (USHORT) get_numeric(tdgbl);
				/*X.RDB$VIEW_CONTEXT.NULL*/
				isc_619.isc_650 = FALSE;
				break;

			case att_field_computed_flag:
				if (get_numeric(tdgbl))
					field->fld_flags |= FLD_computed;
				break;

			case att_base_field:
				GET_TEXT(/*X.RDB$BASE_FIELD*/
					 isc_619.isc_630);
				/*X.RDB$BASE_FIELD.NULL*/
				isc_619.isc_649 = FALSE;
				break;

			case att_field_description:
				/*X.RDB$DESCRIPTION.NULL*/
				isc_619.isc_644 = FALSE;
				get_misc_blob (tdgbl, /*X.RDB$DESCRIPTION*/
						      isc_619.isc_625, global_tr);
				break;

			case att_field_description2:
				/*X.RDB$DESCRIPTION.NULL*/
				isc_619.isc_644 = FALSE;
				get_source_blob (tdgbl, /*X.RDB$DESCRIPTION*/
							isc_619.isc_625, global_tr);
				break;

			case att_field_complex_name:
				GET_TEXT(/*X.RDB$COMPLEX_NAME*/
					 isc_619.isc_624);
				/*X.RDB$COMPLEX_NAME.NULL*/
				isc_619.isc_640 = FALSE;
				break;

			case att_field_dimensions:
				{
					field->fld_dimensions = (USHORT) get_numeric(tdgbl);
					field->fld_flags |= FLD_array;
					USHORT n = field->fld_dimensions;
					for (SLONG* rp = field->fld_ranges; n; rp += 2, n--)
					{
						if (get_attribute(&attribute, tdgbl) != att_field_range_low)
							bad_attribute (scan_next_attr, attribute, 58);
						// msg 58 array
						else
							*rp = get_numeric(tdgbl);
						if (get_attribute(&attribute, tdgbl) != att_field_range_high)
							bad_attribute (scan_next_attr, attribute, 58);
							// msg 58 array
						else
							*(rp + 1) = get_numeric(tdgbl);
					}
				}
				break;

			case att_field_update_flag:
				/*X.RDB$UPDATE_FLAG.NULL*/
				isc_619.isc_638 = FALSE;
				/*X.RDB$UPDATE_FLAG*/
				isc_619.isc_639 = (USHORT) get_numeric(tdgbl);
				break;

			case att_field_character_length:
				field->fld_character_length = (USHORT) get_numeric(tdgbl);
				break;

			case att_field_default_source:
				/*X.RDB$DEFAULT_SOURCE.NULL*/
				isc_619.isc_637 = FALSE;
				get_source_blob (tdgbl, /*X.RDB$DEFAULT_SOURCE*/
							isc_619.isc_623, global_tr);
				break;

			case att_field_default_value:
				/*X.RDB$DEFAULT_VALUE.NULL*/
				isc_619.isc_636 = FALSE;
				get_blr_blob (tdgbl, /*X.RDB$DEFAULT_VALUE*/
						     isc_619.isc_622, global_tr);
				break;

			case att_field_null_flag:
				if (tdgbl->gbl_sw_novalidity) {
					get_numeric(tdgbl); // skip
				}
				else {
					/*X.RDB$NULL_FLAG.NULL*/
					isc_619.isc_634 = FALSE;
					/*X.RDB$NULL_FLAG*/
					isc_619.isc_635 = (USHORT) get_numeric(tdgbl);
				}
				break;

			case att_field_character_set:
				field->fld_character_set_id = (USHORT) get_numeric(tdgbl);
				break;

			case att_field_collation_id:
				field->fld_collation_id = (USHORT) get_numeric(tdgbl);
				/*X.RDB$COLLATION_ID.NULL*/
				isc_619.isc_632 = FALSE;
				/*X.RDB$COLLATION_ID*/
				isc_619.isc_633 = field->fld_collation_id;
				break;

			default:
				bad_attribute (scan_next_attr, attribute, 84);
				// msg 84 column
				break;
			}
		}

	/*END_STORE;*/
	   
           isc_start_and_send (isc_status, (FB_API_HANDLE*) &tdgbl->handles_get_field_req_handle1, (FB_API_HANDLE*) &local_trans, (short) 0, (short) 426, &isc_619, (short) 0);
	   };
	/*ON_ERROR*/
	if (isc_status [1])
	   {
		general_on_error ();
	/*END_ERROR;*/
	   }
	}

	return field;
}

bool get_field_dimensions(BurpGlobals* tdgbl)
{
   struct isc_613_struct {
          char  isc_614 [32];	/* RDB$FIELD_NAME */
          ISC_LONG isc_615;	/* RDB$UPPER_BOUND */
          ISC_LONG isc_616;	/* RDB$LOWER_BOUND */
          short isc_617;	/* RDB$DIMENSION */
   } isc_613;
/**************************************
 *
 *	g e t _ f i e l d _ d i m e n s i o n s
 *
 **************************************
 *
 * Functional description
 *	Get array field dimensions in rdb$field_dimensions.
 *
 **************************************/
	att_type		attribute;
	scan_attr_t		scan_next_attr;

	/*STORE (REQUEST_HANDLE tdgbl->handles_get_field_dimensions_req_handle1)
		X IN RDB$FIELD_DIMENSIONS*/
	{
	
        if (!tdgbl->handles_get_field_dimensions_req_handle1)
           isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &tdgbl->handles_get_field_dimensions_req_handle1, (short) sizeof(isc_612), (char*) isc_612);
	if (tdgbl->handles_get_field_dimensions_req_handle1)
	   {

		skip_init(&scan_next_attr);
		while (skip_scan(&scan_next_attr), get_attribute(&attribute, tdgbl) != att_end)
		{
			switch (attribute)
			{
			case att_field_name:
				GET_TEXT(/*X.RDB$FIELD_NAME*/
					 isc_613.isc_614);
				break;

			case att_field_dimensions:
				/*X.RDB$DIMENSION*/
				isc_613.isc_617 = (USHORT) get_numeric(tdgbl);
				break;

			case att_field_range_low:
				/*X.RDB$LOWER_BOUND*/
				isc_613.isc_616 = get_numeric(tdgbl);
				break;

			case att_field_range_high:
				/*X.RDB$UPPER_BOUND*/
				isc_613.isc_615 = get_numeric(tdgbl);
				break;

			default:
				bad_attribute (scan_next_attr, attribute, 288);
				// msg 288 array dimensions
				break;
			}
		}
	/*END_STORE;*/
	   
           isc_start_and_send (isc_status, (FB_API_HANDLE*) &tdgbl->handles_get_field_dimensions_req_handle1, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 42, &isc_613, (short) 0);
	   };
	/*ON_ERROR*/
	if (isc_status [1])
	   {
		general_on_error ();
	/*END_ERROR;*/
	   }
	}

	return true;
}

bool get_files(BurpGlobals* tdgbl)
{
   struct isc_605_struct {
          char  isc_606 [256];	/* RDB$FILE_NAME */
          ISC_LONG isc_607;	/* RDB$FILE_LENGTH */
          ISC_LONG isc_608;	/* RDB$FILE_START */
          short isc_609;	/* RDB$SHADOW_NUMBER */
          short isc_610;	/* RDB$FILE_SEQUENCE */
          short isc_611;	/* RDB$FILE_FLAGS */
   } isc_605;
/**************************************
 *
 *	g e t _ f i l e s
 *
 **************************************
 *
 * Functional description
 *	Get any files that were stored; let
 *	somebody else worry about what to do with them.
 *
 **************************************/
	att_type		attribute;
	scan_attr_t		scan_next_attr;

	/*STORE (REQUEST_HANDLE tdgbl->handles_get_files_req_handle1)
		X IN RDB$FILES*/
	{
	
        if (!tdgbl->handles_get_files_req_handle1)
           isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &tdgbl->handles_get_files_req_handle1, (short) sizeof(isc_604), (char*) isc_604);
	if (tdgbl->handles_get_files_req_handle1)
	   {
		/*X.RDB$FILE_FLAGS*/
		isc_605.isc_611 = 0;

		skip_init(&scan_next_attr);
		while (skip_scan(&scan_next_attr), get_attribute(&attribute, tdgbl) != att_end)
		{
			switch (attribute)
			{
			case att_file_filename:
				GET_TEXT(/*X.RDB$FILE_NAME*/
					 isc_605.isc_606);
				BURP_verbose (116, /*X.RDB$FILE_NAME*/
						   isc_605.isc_606);
				// msg 116 restoring file %s
				break;

			case att_file_sequence:
				/*X.RDB$FILE_SEQUENCE*/
				isc_605.isc_610 = (USHORT) get_numeric(tdgbl);
				break;

			case att_file_start:
				/*X.RDB$FILE_START*/
				isc_605.isc_608 = get_numeric(tdgbl);
				break;

			case att_file_length:
				/*X.RDB$FILE_LENGTH*/
				isc_605.isc_607 = get_numeric(tdgbl);
				break;

			case att_file_flags:
				/*X.RDB$FILE_FLAGS*/
				isc_605.isc_611 |= get_numeric(tdgbl);
				break;

			case att_shadow_number:
				/*X.RDB$SHADOW_NUMBER*/
				isc_605.isc_609 = (USHORT) get_numeric(tdgbl);
				if (tdgbl->gbl_sw_kill && /*X.RDB$SHADOW_NUMBER*/
							  isc_605.isc_609)
					/*X.RDB$FILE_FLAGS*/
					isc_605.isc_611 |= FILE_inactive;
				break;

			default:
				bad_attribute (scan_next_attr, attribute, 85);
				// msg 85 file
				break;
			}
		}
	/*END_STORE;*/
	   
           isc_start_and_send (isc_status, (FB_API_HANDLE*) &tdgbl->handles_get_files_req_handle1, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 270, &isc_605, (short) 0);
	   };
	/*ON_ERROR*/
	if (isc_status [1])
	   {
		general_on_error ();
	/*END_ERROR;*/
	   }
	}

	return true;
}

bool get_filter(BurpGlobals* tdgbl)
{
   struct isc_594_struct {
          char  isc_595 [32];	/* RDB$ENTRYPOINT */
          char  isc_596 [256];	/* RDB$MODULE_NAME */
          char  isc_597 [32];	/* RDB$FUNCTION_NAME */
          ISC_QUAD isc_598;	/* RDB$DESCRIPTION */
          short isc_599;	/* RDB$OUTPUT_SUB_TYPE */
          short isc_600;	/* RDB$INPUT_SUB_TYPE */
          short isc_601;	/* gds__null_flag */
          short isc_602;	/* RDB$SYSTEM_FLAG */
          short isc_603;	/* gds__null_flag */
   } isc_594;
/**************************************
 *
 *	g e t _ f i l t e r
 *
 **************************************
 *
 * Functional description
 *	Get a type definition in rdb$filters.
 *
 **************************************/
	att_type		attribute;
	scan_attr_t		scan_next_attr;

	/*STORE (REQUEST_HANDLE tdgbl->handles_get_filter_req_handle1)
		X IN RDB$FILTERS*/
	{
	
        if (!tdgbl->handles_get_filter_req_handle1)
           isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &tdgbl->handles_get_filter_req_handle1, (short) sizeof(isc_593), (char*) isc_593);
	if (tdgbl->handles_get_filter_req_handle1)
	   {
	   isc_594.isc_598 = isc_blob_null;
		/*X.RDB$DESCRIPTION.NULL*/
		isc_594.isc_603 = TRUE;
		/*X.RDB$SYSTEM_FLAG*/
		isc_594.isc_602 = 0;
		/*X.RDB$SYSTEM_FLAG.NULL*/
		isc_594.isc_601 = FALSE;

		skip_init(&scan_next_attr);
		while (skip_scan(&scan_next_attr), get_attribute(&attribute, tdgbl) != att_end)
		{
			switch (attribute)
			{
			case att_filter_name:
				GET_TEXT(/*X.RDB$FUNCTION_NAME*/
					 isc_594.isc_597);
				BURP_verbose (117, /*X.RDB$FUNCTION_NAME*/
						   isc_594.isc_597);
				// msg 117 restoring filter %s
				break;

			case att_filter_description:
				/*X.RDB$DESCRIPTION.NULL*/
				isc_594.isc_603 = FALSE;
				get_misc_blob (tdgbl, /*X.RDB$DESCRIPTION*/
						      isc_594.isc_598, false);
				break;

			case att_filter_description2:
				/*X.RDB$DESCRIPTION.NULL*/
				isc_594.isc_603 = FALSE;
				get_source_blob (tdgbl, /*X.RDB$DESCRIPTION*/
							isc_594.isc_598, false);
				break;

			case att_filter_module_name:
				GET_TEXT(/*X.RDB$MODULE_NAME*/
					 isc_594.isc_596);
				break;

			case att_filter_entrypoint:
				GET_TEXT(/*X.RDB$ENTRYPOINT*/
					 isc_594.isc_595);
				break;

			case att_filter_input_sub_type:
				/*X.RDB$INPUT_SUB_TYPE*/
				isc_594.isc_600 = (USHORT) get_numeric(tdgbl);
				break;

			case att_filter_output_sub_type:
				/*X.RDB$OUTPUT_SUB_TYPE*/
				isc_594.isc_599 = (USHORT) get_numeric(tdgbl);
				break;

			default:
				bad_attribute (scan_next_attr, attribute, 87);
				// msg 87  filter
				break;
			}
		}
	/*END_STORE;*/
	   
           isc_start_and_send (isc_status, (FB_API_HANDLE*) &tdgbl->handles_get_filter_req_handle1, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 338, &isc_594, (short) 0);
	   };
	/*ON_ERROR*/
	if (isc_status [1])
	   {
		general_on_error ();
	/*END_ERROR;*/
	   }
	}

	return true;
}

bool get_function(BurpGlobals* tdgbl)
{
   struct isc_582_struct {
          char  isc_583 [32];	/* RDB$QUERY_NAME */
          char  isc_584 [32];	/* RDB$ENTRYPOINT */
          char  isc_585 [256];	/* RDB$MODULE_NAME */
          char  isc_586 [32];	/* RDB$FUNCTION_NAME */
          ISC_QUAD isc_587;	/* RDB$DESCRIPTION */
          short isc_588;	/* RDB$FUNCTION_TYPE */
          short isc_589;	/* RDB$RETURN_ARGUMENT */
          short isc_590;	/* gds__null_flag */
          short isc_591;	/* gds__null_flag */
          short isc_592;	/* RDB$SYSTEM_FLAG */
   } isc_582;
/**************************************
 *
 *	g e t _ f u n c t i o n
 *
 **************************************
 *
 * Functional description
 *	Reconstruct a function.
 *
 **************************************/
	att_type	attribute;
	GDS_NAME	function_name;
	TEXT		temp[GDS_NAME_LEN];
	SSHORT		l;
	scan_attr_t	scan_next_attr;

	bool existFlag = false;

	/*STORE (REQUEST_HANDLE tdgbl->handles_get_function_req_handle1)
		X IN RDB$FUNCTIONS*/
	{
	
        if (!tdgbl->handles_get_function_req_handle1)
           isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &tdgbl->handles_get_function_req_handle1, (short) sizeof(isc_581), (char*) isc_581);
	if (tdgbl->handles_get_function_req_handle1)
	   {
	   isc_582.isc_587 = isc_blob_null;
		/*X.RDB$SYSTEM_FLAG*/
		isc_582.isc_592 = 0;
		/*X.RDB$SYSTEM_FLAG.NULL*/
		isc_582.isc_591 = FALSE;
		/*X.RDB$DESCRIPTION.NULL*/
		isc_582.isc_590 = TRUE;

		skip_init(&scan_next_attr);
		while (skip_scan(&scan_next_attr), get_attribute(&attribute, tdgbl) != att_end)
		{
			switch (attribute)
			{
			case att_function_name:
				l = GET_TEXT(/*X.RDB$FUNCTION_NAME*/
					     isc_582.isc_586);
				MISC_terminate (/*X.RDB$FUNCTION_NAME*/
						isc_582.isc_586, temp, l, sizeof(temp));
				BURP_verbose (118, temp);
				// msg 118 restoring function %s
				break;

			case att_function_description:
				/*X.RDB$DESCRIPTION.NULL*/
				isc_582.isc_590 = FALSE;
				get_misc_blob (tdgbl, /*X.RDB$DESCRIPTION*/
						      isc_582.isc_587, false);
				break;

			case att_function_description2:
				/*X.RDB$DESCRIPTION.NULL*/
				isc_582.isc_590 = FALSE;
				get_source_blob (tdgbl, /*X.RDB$DESCRIPTION*/
							isc_582.isc_587, false);
				break;

			case att_function_module_name:
				GET_TEXT(/*X.RDB$MODULE_NAME*/
					 isc_582.isc_585);
				break;

			case att_function_entrypoint:
				GET_TEXT(/*X.RDB$ENTRYPOINT*/
					 isc_582.isc_584);
				break;

			case att_function_return_arg:
				/*X.RDB$RETURN_ARGUMENT*/
				isc_582.isc_589 = (USHORT) get_numeric(tdgbl);
				break;

			case att_function_query_name:
				GET_TEXT(/*X.RDB$QUERY_NAME*/
					 isc_582.isc_583);
				break;

			case att_function_type:
				/*X.RDB$FUNCTION_TYPE*/
				isc_582.isc_588 = (USHORT) get_numeric(tdgbl);
				break;

			default:
				bad_attribute (scan_next_attr, attribute, 89);
				// msg 89 function
				break;
			}
		}
	strcpy (function_name, /*X.RDB$FUNCTION_NAME*/
			       isc_582.isc_586);
	/*END_STORE;*/
	   
           isc_start_and_send (isc_status, (FB_API_HANDLE*) &tdgbl->handles_get_function_req_handle1, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 370, &isc_582, (short) 0);
	   };
	/*ON_ERROR*/
	if (isc_status [1])
	   {
		if (gds_status[1] != isc_no_dup)
		{
			general_on_error ();
		}
		else
		{
			existFlag = true;
		}
	/*END_ERROR;*/
	   }
	}

	// at the end of args for a function is the rec_function_end marker
	while (get(tdgbl) == rec_function_arg)
		get_function_arg(tdgbl, existFlag);

	return true;
}

void get_function_arg(BurpGlobals* tdgbl, bool skip_arguments)
{
   struct isc_556_struct {
          char  isc_557 [32];	/* RDB$FUNCTION_NAME */
          short isc_558;	/* RDB$FIELD_LENGTH */
          short isc_559;	/* RDB$FIELD_SCALE */
          short isc_560;	/* RDB$FIELD_TYPE */
          short isc_561;	/* RDB$MECHANISM */
          short isc_562;	/* RDB$ARGUMENT_POSITION */
          short isc_563;	/* gds__null_flag */
          short isc_564;	/* RDB$CHARACTER_SET_ID */
          short isc_565;	/* gds__null_flag */
          short isc_566;	/* RDB$FIELD_SUB_TYPE */
   } isc_556;
   struct isc_568_struct {
          char  isc_569 [32];	/* RDB$FUNCTION_NAME */
          short isc_570;	/* RDB$FIELD_LENGTH */
          short isc_571;	/* RDB$FIELD_SCALE */
          short isc_572;	/* RDB$FIELD_TYPE */
          short isc_573;	/* RDB$MECHANISM */
          short isc_574;	/* RDB$ARGUMENT_POSITION */
          short isc_575;	/* gds__null_flag */
          short isc_576;	/* RDB$FIELD_PRECISION */
          short isc_577;	/* gds__null_flag */
          short isc_578;	/* RDB$CHARACTER_SET_ID */
          short isc_579;	/* gds__null_flag */
          short isc_580;	/* RDB$FIELD_SUB_TYPE */
   } isc_568;
/**************************************
 *
 *	g e t _ f u n c t i o n _ a r g
 *
 **************************************
 *
 * Functional description
 *	Reconstruct function argument.
 *
 **************************************/
	att_type	attribute;
	SSHORT		l;
	TEXT		temp[GDS_NAME_LEN];
	scan_attr_t		scan_next_attr;

	if (skip_arguments)
	{
		char buf[MAX_SQL_IDENTIFIER_SIZE];
		skip_init(&scan_next_attr);
		while (skip_scan(&scan_next_attr), get_attribute(&attribute, tdgbl) != att_end)
		{
			switch (attribute)
			{
			case att_functionarg_name:
				GET_TEXT(buf);
				break;

			case att_functionarg_position:
				get_numeric(tdgbl);
				break;

			case att_functionarg_mechanism:
				get_numeric(tdgbl);
				break;

			case att_functionarg_field_type:
				get_numeric(tdgbl);
				break;

			case att_functionarg_field_scale:
				get_numeric(tdgbl);
				break;

			case att_functionarg_field_length:
				get_numeric(tdgbl);
				break;

			case att_functionarg_field_sub_type:
				get_numeric(tdgbl);
				break;

			case att_functionarg_character_set:
				get_numeric(tdgbl);
				break;

			case att_functionarg_field_precision:
				get_numeric(tdgbl);
				break;

			default:
				bad_attribute (scan_next_attr, attribute, 90);
				// msg 90 function argument
				break;
			}
		}
		return;
	}

	if (tdgbl->RESTORE_ods >= DB_VERSION_DDL10)
	{
		// with RDB$FIELD_PRECISION
		/*STORE (REQUEST_HANDLE tdgbl->handles_get_function_arg_req_handle1)
			X IN RDB$FUNCTION_ARGUMENTS*/
		{
		
                if (!tdgbl->handles_get_function_arg_req_handle1)
                   isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &tdgbl->handles_get_function_arg_req_handle1, (short) sizeof(isc_567), (char*) isc_567);
		if (tdgbl->handles_get_function_arg_req_handle1)
		   {
			/*X.RDB$FIELD_SUB_TYPE.NULL*/
			isc_568.isc_579 = TRUE;
			/*X.RDB$CHARACTER_SET_ID.NULL*/
			isc_568.isc_577 = TRUE;
			/*X.RDB$FIELD_PRECISION.NULL*/
			isc_568.isc_575  = TRUE;

			skip_init(&scan_next_attr);
			while (skip_scan(&scan_next_attr), get_attribute(&attribute, tdgbl) != att_end)
			{
				switch (attribute)
				{
				case att_functionarg_name:
					l = GET_TEXT(/*X.RDB$FUNCTION_NAME*/
						     isc_568.isc_569);
					MISC_terminate (/*X.RDB$FUNCTION_NAME*/
							isc_568.isc_569, temp, l, sizeof(temp));
					BURP_verbose (119, temp);
					// msg 119 restoring argument for function %s
					break;

				case att_functionarg_position:
					/*X.RDB$ARGUMENT_POSITION*/
					isc_568.isc_574 = (USHORT) get_numeric(tdgbl);
					break;

				case att_functionarg_mechanism:
					/*X.RDB$MECHANISM*/
					isc_568.isc_573 = (USHORT) get_numeric(tdgbl);
					break;

				case att_functionarg_field_type:
					/*X.RDB$FIELD_TYPE*/
					isc_568.isc_572 = (USHORT) get_numeric(tdgbl);
					break;

				case att_functionarg_field_scale:
					/*X.RDB$FIELD_SCALE*/
					isc_568.isc_571 = (USHORT) get_numeric(tdgbl);
					break;

				case att_functionarg_field_length:
					/*X.RDB$FIELD_LENGTH*/
					isc_568.isc_570 = (USHORT) get_numeric(tdgbl);
					break;

				case att_functionarg_field_sub_type:
					/*X.RDB$FIELD_SUB_TYPE.NULL*/
					isc_568.isc_579 = FALSE;
					/*X.RDB$FIELD_SUB_TYPE*/
					isc_568.isc_580 = (USHORT) get_numeric(tdgbl);
					break;

				case att_functionarg_character_set:
					/*X.RDB$CHARACTER_SET_ID.NULL*/
					isc_568.isc_577 = FALSE;
					/*X.RDB$CHARACTER_SET_ID*/
					isc_568.isc_578 = (USHORT) get_numeric(tdgbl);
					break;

				case att_functionarg_field_precision:
					if (tdgbl->RESTORE_format >= 6)
					{
						/*X.RDB$FIELD_PRECISION.NULL*/
						isc_568.isc_575 = FALSE;
						/*X.RDB$FIELD_PRECISION*/
						isc_568.isc_576 = (USHORT) get_numeric(tdgbl);
					}
					else
						bad_attribute (scan_next_attr, attribute, 90);
					break;

				default:
					bad_attribute (scan_next_attr, attribute, 90);
					// msg 90 function argument
					break;
				}
			}
		/*END_STORE;*/
		   
                   isc_start_and_send (isc_status, (FB_API_HANDLE*) &tdgbl->handles_get_function_arg_req_handle1, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 54, &isc_568, (short) 0);
		   };
		/*ON_ERROR*/
		if (isc_status [1])
		   {
			general_on_error ();
		/*END_ERROR;*/
		   }
		}
	}
	else
	{
		// without RDB$FIELD_PRECISION
		/*STORE (REQUEST_HANDLE tdgbl->handles_get_function_arg_req_handle1)
			X IN RDB$FUNCTION_ARGUMENTS*/
		{
		
                if (!tdgbl->handles_get_function_arg_req_handle1)
                   isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &tdgbl->handles_get_function_arg_req_handle1, (short) sizeof(isc_555), (char*) isc_555);
		if (tdgbl->handles_get_function_arg_req_handle1)
		   {
			/*X.RDB$FIELD_SUB_TYPE.NULL*/
			isc_556.isc_565 = TRUE;
			/*X.RDB$CHARACTER_SET_ID.NULL*/
			isc_556.isc_563 = TRUE;

			skip_init(&scan_next_attr);
			while (skip_scan(&scan_next_attr), get_attribute(&attribute, tdgbl) != att_end)
			{
				switch (attribute)
				{
				case att_functionarg_name:
					l = GET_TEXT(/*X.RDB$FUNCTION_NAME*/
						     isc_556.isc_557);
					MISC_terminate (/*X.RDB$FUNCTION_NAME*/
							isc_556.isc_557, temp, l, sizeof(temp));
					BURP_verbose (119, temp);
					// msg 119 restoring argument for function %s
					break;

				case att_functionarg_position:
					/*X.RDB$ARGUMENT_POSITION*/
					isc_556.isc_562 = (USHORT) get_numeric(tdgbl);
					break;

				case att_functionarg_mechanism:
					/*X.RDB$MECHANISM*/
					isc_556.isc_561 = (USHORT) get_numeric(tdgbl);
					break;

				case att_functionarg_field_type:
					/*X.RDB$FIELD_TYPE*/
					isc_556.isc_560 = (USHORT) get_numeric(tdgbl);
					break;

				case att_functionarg_field_scale:
					/*X.RDB$FIELD_SCALE*/
					isc_556.isc_559 = (USHORT) get_numeric(tdgbl);
					break;

				case att_functionarg_field_length:
					/*X.RDB$FIELD_LENGTH*/
					isc_556.isc_558 = (USHORT) get_numeric(tdgbl);
					break;

				case att_functionarg_field_sub_type:
					/*X.RDB$FIELD_SUB_TYPE.NULL*/
					isc_556.isc_565 = FALSE;
					/*X.RDB$FIELD_SUB_TYPE*/
					isc_556.isc_566 = (USHORT) get_numeric(tdgbl);
					break;

				case att_functionarg_character_set:
					/*X.RDB$CHARACTER_SET_ID.NULL*/
					isc_556.isc_563 = FALSE;
					/*X.RDB$CHARACTER_SET_ID*/
					isc_556.isc_564 = (USHORT) get_numeric(tdgbl);
					break;

				case att_functionarg_field_precision:
					if (tdgbl->RESTORE_format >= 6)
						get_numeric(tdgbl);
					else
						bad_attribute (scan_next_attr, attribute, 90);

				default:
					bad_attribute (scan_next_attr, attribute, 90);
					// msg 90 function argument
					break;
				}
			}
		/*END_STORE;*/
		   
                   isc_start_and_send (isc_status, (FB_API_HANDLE*) &tdgbl->handles_get_function_arg_req_handle1, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 50, &isc_556, (short) 0);
		   };
		/*ON_ERROR*/
		if (isc_status [1])
		   {
			general_on_error ();
		/*END_ERROR;*/
		   }
		}
	}
}

bool get_generator(BurpGlobals* tdgbl)
{
/**************************************
 *
 *	g e t _ g e n e r a t o r
 *
 **************************************
 *
 * Functional description
 *	Pick up a gen-id.  Like most things, there is ughly history.
 *	In the modern world, gen_id are free floating records.  In the
 *	bad old days they were attributes of relations.  Handle both
 *	nicely.
 *
 **************************************/
	SINT64		value = 0;
	/*BASED_ON RDB$GENERATORS.RDB$GENERATOR_NAME name;*/
	char
	   name[32];

	name[0] = 0; // just in case.
	att_type	attribute;
	scan_attr_t		scan_next_attr;

	skip_init(&scan_next_attr);

	ISC_QUAD gen_desc = {0, 0};
	bool got_desc = false;

	while (skip_scan(&scan_next_attr), get_attribute(&attribute, tdgbl) != att_end)
	{
		switch (attribute)
		{
		case att_gen_generator:
			GET_TEXT(name);
			break;

		case att_gen_value:
			// IB v5 or earlier, gen_id value is an SLONG
			value = (SINT64) get_numeric(tdgbl);
			break;

		case att_gen_value_int64:
			// IB v6 or later, gen_id value is an SINT64
			value = get_int64(tdgbl);
			break;

		case att_gen_description:
			if (tdgbl->RESTORE_format >= 7)
			{
				get_source_blob (tdgbl, gen_desc, false);
				got_desc = gen_desc.gds_quad_high || gen_desc.gds_quad_low;
			}
			else
				bad_attribute(scan_next_attr, attribute, 289);
			break;

		default:
			bad_attribute (scan_next_attr, attribute, 289);
			// msg 289 generator
			break;
		}
	}

	if (tdgbl->gbl_sw_meta)
	{
		value = 0;
	}

	store_blr_gen_id(tdgbl, name, value, got_desc ? &gen_desc : NULL);

	return true;
}

bool get_global_field(BurpGlobals* tdgbl)
{
   struct isc_448_struct {
          char  isc_449 [32];	/* RDB$FIELD_NAME */
          ISC_QUAD isc_450;	/* RDB$DEFAULT_SOURCE */
          ISC_QUAD isc_451;	/* RDB$MISSING_SOURCE */
          ISC_QUAD isc_452;	/* RDB$DESCRIPTION */
          ISC_QUAD isc_453;	/* RDB$VALIDATION_SOURCE */
          ISC_QUAD isc_454;	/* RDB$VALIDATION_BLR */
          ISC_QUAD isc_455;	/* RDB$DEFAULT_VALUE */
          ISC_QUAD isc_456;	/* RDB$MISSING_VALUE */
          ISC_QUAD isc_457;	/* RDB$QUERY_HEADER */
          char  isc_458 [128];	/* RDB$EDIT_STRING */
          char  isc_459 [32];	/* RDB$QUERY_NAME */
          ISC_QUAD isc_460;	/* RDB$COMPUTED_SOURCE */
          ISC_QUAD isc_461;	/* RDB$COMPUTED_BLR */
          short isc_462;	/* gds__null_flag */
          short isc_463;	/* RDB$FIELD_LENGTH */
          short isc_464;	/* RDB$FIELD_TYPE */
          short isc_465;	/* gds__null_flag */
          short isc_466;	/* gds__null_flag */
          short isc_467;	/* gds__null_flag */
          short isc_468;	/* gds__null_flag */
          short isc_469;	/* gds__null_flag */
          short isc_470;	/* gds__null_flag */
          short isc_471;	/* RDB$CHARACTER_LENGTH */
          short isc_472;	/* gds__null_flag */
          short isc_473;	/* gds__null_flag */
          short isc_474;	/* RDB$EXTERNAL_SCALE */
          short isc_475;	/* gds__null_flag */
          short isc_476;	/* RDB$EXTERNAL_TYPE */
          short isc_477;	/* gds__null_flag */
          short isc_478;	/* RDB$EXTERNAL_LENGTH */
          short isc_479;	/* gds__null_flag */
          short isc_480;	/* RDB$DIMENSIONS */
          short isc_481;	/* gds__null_flag */
          short isc_482;	/* gds__null_flag */
          short isc_483;	/* RDB$NULL_FLAG */
          short isc_484;	/* gds__null_flag */
          short isc_485;	/* RDB$SYSTEM_FLAG */
          short isc_486;	/* gds__null_flag */
          short isc_487;	/* gds__null_flag */
          short isc_488;	/* gds__null_flag */
          short isc_489;	/* gds__null_flag */
          short isc_490;	/* gds__null_flag */
          short isc_491;	/* gds__null_flag */
          short isc_492;	/* gds__null_flag */
          short isc_493;	/* gds__null_flag */
          short isc_494;	/* gds__null_flag */
          short isc_495;	/* RDB$FIELD_SUB_TYPE */
          short isc_496;	/* RDB$COLLATION_ID */
          short isc_497;	/* RDB$CHARACTER_SET_ID */
          short isc_498;	/* RDB$SEGMENT_LENGTH */
          short isc_499;	/* RDB$FIELD_SCALE */
   } isc_448;
   struct isc_501_struct {
          char  isc_502 [32];	/* RDB$FIELD_NAME */
          ISC_QUAD isc_503;	/* RDB$DEFAULT_SOURCE */
          ISC_QUAD isc_504;	/* RDB$MISSING_SOURCE */
          ISC_QUAD isc_505;	/* RDB$DESCRIPTION */
          ISC_QUAD isc_506;	/* RDB$VALIDATION_SOURCE */
          ISC_QUAD isc_507;	/* RDB$VALIDATION_BLR */
          ISC_QUAD isc_508;	/* RDB$DEFAULT_VALUE */
          ISC_QUAD isc_509;	/* RDB$MISSING_VALUE */
          ISC_QUAD isc_510;	/* RDB$QUERY_HEADER */
          char  isc_511 [128];	/* RDB$EDIT_STRING */
          char  isc_512 [32];	/* RDB$QUERY_NAME */
          ISC_QUAD isc_513;	/* RDB$COMPUTED_SOURCE */
          ISC_QUAD isc_514;	/* RDB$COMPUTED_BLR */
          short isc_515;	/* gds__null_flag */
          short isc_516;	/* RDB$FIELD_LENGTH */
          short isc_517;	/* RDB$FIELD_TYPE */
          short isc_518;	/* gds__null_flag */
          short isc_519;	/* RDB$FIELD_PRECISION */
          short isc_520;	/* gds__null_flag */
          short isc_521;	/* gds__null_flag */
          short isc_522;	/* gds__null_flag */
          short isc_523;	/* gds__null_flag */
          short isc_524;	/* gds__null_flag */
          short isc_525;	/* gds__null_flag */
          short isc_526;	/* RDB$CHARACTER_LENGTH */
          short isc_527;	/* gds__null_flag */
          short isc_528;	/* gds__null_flag */
          short isc_529;	/* RDB$EXTERNAL_SCALE */
          short isc_530;	/* gds__null_flag */
          short isc_531;	/* RDB$EXTERNAL_TYPE */
          short isc_532;	/* gds__null_flag */
          short isc_533;	/* RDB$EXTERNAL_LENGTH */
          short isc_534;	/* gds__null_flag */
          short isc_535;	/* RDB$DIMENSIONS */
          short isc_536;	/* gds__null_flag */
          short isc_537;	/* gds__null_flag */
          short isc_538;	/* RDB$NULL_FLAG */
          short isc_539;	/* gds__null_flag */
          short isc_540;	/* RDB$SYSTEM_FLAG */
          short isc_541;	/* gds__null_flag */
          short isc_542;	/* gds__null_flag */
          short isc_543;	/* gds__null_flag */
          short isc_544;	/* gds__null_flag */
          short isc_545;	/* gds__null_flag */
          short isc_546;	/* gds__null_flag */
          short isc_547;	/* gds__null_flag */
          short isc_548;	/* gds__null_flag */
          short isc_549;	/* gds__null_flag */
          short isc_550;	/* RDB$FIELD_SUB_TYPE */
          short isc_551;	/* RDB$COLLATION_ID */
          short isc_552;	/* RDB$CHARACTER_SET_ID */
          short isc_553;	/* RDB$SEGMENT_LENGTH */
          short isc_554;	/* RDB$FIELD_SCALE */
   } isc_501;
/**************************************
 *
 *	g e t _ g l o b a l _ f i e l d
 *
 **************************************
 *
 * Functional description
 *	Reconstruct a global field.
 *
 **************************************/
	att_type	attribute;
	TEXT		temp[GDS_NAME_LEN];
	SSHORT		l;
	scan_attr_t		scan_next_attr;

	gfld* gfield = NULL;

	if (tdgbl->RESTORE_ods >= DB_VERSION_DDL10)
	{
		// with rdb$field_precision
		/*STORE (REQUEST_HANDLE tdgbl->handles_get_global_field_req_handle1)
			X IN RDB$FIELDS*/
		{
		
                if (!tdgbl->handles_get_global_field_req_handle1)
                   isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &tdgbl->handles_get_global_field_req_handle1, (short) sizeof(isc_500), (char*) isc_500);
		if (tdgbl->handles_get_global_field_req_handle1)
		   {
		   isc_501.isc_503 = isc_blob_null;
		   isc_501.isc_504 = isc_blob_null;
		   isc_501.isc_505 = isc_blob_null;
		   isc_501.isc_506 = isc_blob_null;
		   isc_501.isc_507 = isc_blob_null;
		   isc_501.isc_508 = isc_blob_null;
		   isc_501.isc_509 = isc_blob_null;
		   isc_501.isc_510 = isc_blob_null;
		   isc_501.isc_513 = isc_blob_null;
		   isc_501.isc_514 = isc_blob_null;

			/*X.RDB$FIELD_SCALE*/
			isc_501.isc_554 = /*X.RDB$SEGMENT_LENGTH*/
   isc_501.isc_553 = 0;
			/*X.RDB$CHARACTER_SET_ID*/
			isc_501.isc_552 = /*X.RDB$COLLATION_ID*/
   isc_501.isc_551 = 0;
			/*X.RDB$FIELD_SUB_TYPE*/
			isc_501.isc_550 = 0;
			/*X.RDB$COMPUTED_BLR.NULL*/
			isc_501.isc_549 = TRUE;
			/*X.RDB$COMPUTED_SOURCE.NULL*/
			isc_501.isc_548 = TRUE;
			/*X.RDB$QUERY_NAME.NULL*/
			isc_501.isc_547 = TRUE;
			/*X.RDB$EDIT_STRING.NULL*/
			isc_501.isc_546 = TRUE;
			/*X.RDB$QUERY_HEADER.NULL*/
			isc_501.isc_545 = TRUE;
			/*X.RDB$MISSING_VALUE.NULL*/
			isc_501.isc_544 = TRUE;
			/*X.RDB$DEFAULT_VALUE.NULL*/
			isc_501.isc_543 = TRUE;
			/*X.RDB$VALIDATION_BLR.NULL*/
			isc_501.isc_542 = TRUE;
			/*X.RDB$VALIDATION_SOURCE.NULL*/
			isc_501.isc_541 = TRUE;
			/*X.RDB$SYSTEM_FLAG*/
			isc_501.isc_540 = 0;
			/*X.RDB$SYSTEM_FLAG.NULL*/
			isc_501.isc_539 = FALSE;
			/*X.RDB$NULL_FLAG.NULL*/
			isc_501.isc_537 = TRUE;
			/*X.RDB$DESCRIPTION.NULL*/
			isc_501.isc_536 = TRUE;
			/*X.RDB$DIMENSIONS.NULL*/
			isc_501.isc_534 = TRUE;
			/*X.RDB$EXTERNAL_LENGTH.NULL*/
			isc_501.isc_532 = TRUE;
			/*X.RDB$EXTERNAL_TYPE.NULL*/
			isc_501.isc_530 = TRUE;
			/*X.RDB$EXTERNAL_SCALE.NULL*/
			isc_501.isc_528 = TRUE;
			/*X.RDB$SEGMENT_LENGTH.NULL*/
			isc_501.isc_527 = TRUE;
			/*X.RDB$CHARACTER_LENGTH.NULL*/
			isc_501.isc_525 = TRUE;
			/*X.RDB$MISSING_SOURCE.NULL*/
			isc_501.isc_524 = TRUE;
			/*X.RDB$DEFAULT_SOURCE.NULL*/
			isc_501.isc_523 = TRUE;
			/*X.RDB$FIELD_SUB_TYPE.NULL*/
			isc_501.isc_522 = TRUE;
			/*X.RDB$CHARACTER_SET_ID.NULL*/
			isc_501.isc_521 = TRUE;
			/*X.RDB$COLLATION_ID.NULL*/
			isc_501.isc_520 = TRUE;
			/*X.RDB$FIELD_PRECISION.NULL*/
			isc_501.isc_518 = TRUE;

			skip_init(&scan_next_attr);
			while (skip_scan(&scan_next_attr), get_attribute(&attribute, tdgbl) != att_end)
			{
				switch (attribute)
				{
				case att_field_name:
					l = GET_TEXT(/*X.RDB$FIELD_NAME*/
						     isc_501.isc_502);
					MISC_terminate (/*X.RDB$FIELD_NAME*/
							isc_501.isc_502, temp, l, sizeof(temp));
					BURP_verbose (121, temp);
					// msg 121  restoring global field %s
					break;

				case att_field_query_name:
					GET_TEXT(/*X.RDB$QUERY_NAME*/
						 isc_501.isc_512);
					/*X.RDB$QUERY_NAME.NULL*/
					isc_501.isc_547 = FALSE;
					break;

				case att_field_edit_string:
					GET_TEXT(/*X.RDB$EDIT_STRING*/
						 isc_501.isc_511);
					/*X.RDB$EDIT_STRING.NULL*/
					isc_501.isc_546 = FALSE;
					break;

				case att_field_query_header:
					/*X.RDB$QUERY_HEADER.NULL*/
					isc_501.isc_545 = FALSE;
					get_source_blob (tdgbl, /*X.RDB$QUERY_HEADER*/
								isc_501.isc_510, false);
					break;

				case att_field_type:
					/*X.RDB$FIELD_TYPE*/
					isc_501.isc_517 = (USHORT) get_numeric(tdgbl);
					break;

				case att_field_length:
					/*X.RDB$FIELD_LENGTH*/
					isc_501.isc_516 = (USHORT) get_numeric(tdgbl);
					break;

				case att_field_scale:
					/*X.RDB$FIELD_SCALE*/
					isc_501.isc_554 = (USHORT) get_numeric(tdgbl);
					/*X.RDB$FIELD_SCALE.NULL*/
					isc_501.isc_515 = FALSE;
					break;

				case att_field_sub_type:
					/*X.RDB$FIELD_SUB_TYPE*/
					isc_501.isc_550 = (USHORT) get_numeric(tdgbl);
					/*X.RDB$FIELD_SUB_TYPE.NULL*/
					isc_501.isc_522 = FALSE;
					break;

				case att_field_segment_length:
					/*X.RDB$SEGMENT_LENGTH*/
					isc_501.isc_553 = (USHORT) get_numeric(tdgbl);
					if (/*X.RDB$SEGMENT_LENGTH*/
					    isc_501.isc_553)
						/*X.RDB$SEGMENT_LENGTH.NULL*/
						isc_501.isc_527 = FALSE;
					break;

				case att_field_computed_blr:
					// if we are going against a V4.0 database,
					// restore the global fields in 2 phases.

					if (tdgbl->global_trans)
					{
						if (!gfield)
							gfield = (gfld*) BURP_alloc_zero(sizeof(gfld));

						get_blr_blob (tdgbl, gfield->gfld_computed_blr, true);
						gfield->gfld_flags |= GFLD_computed_blr;
					}
					else
					{
						/*X.RDB$COMPUTED_BLR.NULL*/
						isc_501.isc_549 = FALSE;
						get_blr_blob (tdgbl, /*X.RDB$COMPUTED_BLR*/
								     isc_501.isc_514, false);
					}
					break;

				case att_field_computed_source:
					// if we are going against a V4.0 database,
					// restore the global fields in 2 phases.

					if (tdgbl->global_trans)
					{
						if (!gfield)
							gfield = (gfld*) BURP_alloc_zero(sizeof(gfld));

						get_misc_blob (tdgbl, gfield->gfld_computed_source, true);
						gfield->gfld_flags |= GFLD_computed_source;
					}
					else
					{
						/*X.RDB$COMPUTED_SOURCE.NULL*/
						isc_501.isc_548 = FALSE;
						get_misc_blob (tdgbl, /*X.RDB$COMPUTED_SOURCE*/
								      isc_501.isc_513, false);
					}
					break;

				case att_field_computed_source2:
					// if we are going against a V4.0 database,
					// restore the global fields in 2 phases.

					if (tdgbl->global_trans)
					{
						if (!gfield)
							gfield = (gfld*) BURP_alloc_zero(sizeof(gfld));

						get_source_blob (tdgbl, gfield->gfld_computed_source2, true);
						gfield->gfld_flags |= GFLD_computed_source2;
					}
					else
					{
						/*X.RDB$COMPUTED_SOURCE.NULL*/
						isc_501.isc_548 = FALSE;
						get_source_blob (tdgbl, /*X.RDB$COMPUTED_SOURCE*/
									isc_501.isc_513, false);
					}
					break;

				case att_field_validation_blr:
					if (tdgbl->gbl_sw_novalidity)
						eat_blob(tdgbl);
					else
					{
						// if we are going against a V4.0 database,
						// restore the global fields in 2 phases.

						if (tdgbl->global_trans)
						{
							if (!gfield)
								gfield = (gfld*) BURP_alloc_zero(sizeof(gfld));

							get_blr_blob (tdgbl, gfield->gfld_vb, true);
							gfield->gfld_flags |= GFLD_validation_blr;
						}
						else
						{
							/*X.RDB$VALIDATION_BLR.NULL*/
							isc_501.isc_542 = FALSE;
							get_blr_blob (tdgbl, /*X.RDB$VALIDATION_BLR*/
									     isc_501.isc_507, false);
						}
					}
					break;

				case att_field_validation_source:
					if (tdgbl->gbl_sw_novalidity)
						eat_blob(tdgbl);
					else
					{
						// if we are going against a V4.0 database,
						// restore the global fields in 2 phases.

						if (tdgbl->global_trans)
						{
							if (!gfield)
								gfield = (gfld*) BURP_alloc_zero(sizeof(gfld));

							get_misc_blob (tdgbl, gfield->gfld_vs, true);
							gfield->gfld_flags |= GFLD_validation_source;
						}
						else
						{
							/*X.RDB$VALIDATION_SOURCE.NULL*/
							isc_501.isc_541 = FALSE;
							get_misc_blob (tdgbl, /*X.RDB$VALIDATION_SOURCE*/
									      isc_501.isc_506, false);
						}
					}
					break;

				case att_field_validation_source2:
					if (tdgbl->gbl_sw_novalidity)
						eat_blob(tdgbl);
					else
					{
						// if we are going against a V4.0 database,
						// restore the global fields in 2 phases.

						if (tdgbl->global_trans)
						{
							if (!gfield)
								gfield = (gfld*) BURP_alloc_zero(sizeof(gfld));

							get_source_blob (tdgbl, gfield->gfld_vs2, true);
							gfield->gfld_flags |= GFLD_validation_source2;
						}
						else
						{
							/*X.RDB$VALIDATION_SOURCE.NULL*/
							isc_501.isc_541 = FALSE;
							get_source_blob (tdgbl, /*X.RDB$VALIDATION_SOURCE*/
										isc_501.isc_506, false);
						}
					}
					break;

				case att_field_missing_value:
					/*X.RDB$MISSING_VALUE.NULL*/
					isc_501.isc_544 = FALSE;
					get_blr_blob (tdgbl, /*X.RDB$MISSING_VALUE*/
							     isc_501.isc_509, false);
					break;

				case att_field_default_value:
					/*X.RDB$DEFAULT_VALUE.NULL*/
					isc_501.isc_543 = FALSE;
					get_blr_blob (tdgbl, /*X.RDB$DEFAULT_VALUE*/
							     isc_501.isc_508, false);
					break;

				case att_field_system_flag:
					/*X.RDB$SYSTEM_FLAG*/
					isc_501.isc_540 = (USHORT) get_numeric(tdgbl);
					/*X.RDB$SYSTEM_FLAG.NULL*/
					isc_501.isc_539 = FALSE;
					break;

				case att_field_null_flag:
					if (tdgbl->gbl_sw_novalidity) {
						get_numeric(tdgbl); // skip
					}
					else {
						/*X.RDB$NULL_FLAG*/
						isc_501.isc_538 = (USHORT) get_numeric(tdgbl);
						/*X.RDB$NULL_FLAG.NULL*/
						isc_501.isc_537 = FALSE;
					}
					break;

				case att_field_description:
					/*X.RDB$DESCRIPTION.NULL*/
					isc_501.isc_536 = FALSE;
					get_misc_blob (tdgbl, /*X.RDB$DESCRIPTION*/
							      isc_501.isc_505, false);
					break;

				case att_field_description2:
					/*X.RDB$DESCRIPTION.NULL*/
					isc_501.isc_536 = FALSE;
					get_source_blob (tdgbl, /*X.RDB$DESCRIPTION*/
								isc_501.isc_505, false);
					break;

				case att_field_external_length:
					/*X.RDB$EXTERNAL_LENGTH.NULL*/
					isc_501.isc_532 = FALSE;
					/*X.RDB$EXTERNAL_LENGTH*/
					isc_501.isc_533 = (USHORT) get_numeric(tdgbl);
					break;

				case att_field_external_scale:
					/*X.RDB$EXTERNAL_SCALE.NULL*/
					isc_501.isc_528 = FALSE;
					/*X.RDB$EXTERNAL_SCALE*/
					isc_501.isc_529 = (USHORT) get_numeric(tdgbl);
					break;

				case att_field_external_type:
					/*X.RDB$EXTERNAL_TYPE.NULL*/
					isc_501.isc_530 = FALSE;
					/*X.RDB$EXTERNAL_TYPE*/
					isc_501.isc_531 = (USHORT) get_numeric(tdgbl);
					break;

				case att_field_dimensions:
					/*X.RDB$DIMENSIONS.NULL*/
					isc_501.isc_534 = FALSE;
					/*X.RDB$DIMENSIONS*/
					isc_501.isc_535 = (USHORT) get_numeric(tdgbl);
					break;

				case att_field_character_length:
					/*X.RDB$CHARACTER_LENGTH.NULL*/
					isc_501.isc_525 = FALSE;
					/*X.RDB$CHARACTER_LENGTH*/
					isc_501.isc_526 = (USHORT) get_numeric(tdgbl);
					break;

				case att_field_default_source:
					/*X.RDB$DEFAULT_SOURCE.NULL*/
					isc_501.isc_523 = FALSE;
					get_source_blob (tdgbl, /*X.RDB$DEFAULT_SOURCE*/
								isc_501.isc_503, false);
					break;

				case att_field_missing_source:
					/*X.RDB$MISSING_SOURCE.NULL*/
					isc_501.isc_524 = FALSE;
					get_source_blob (tdgbl, /*X.RDB$MISSING_SOURCE*/
								isc_501.isc_504, false);
					break;

				case att_field_character_set:
					/*X.RDB$CHARACTER_SET_ID.NULL*/
					isc_501.isc_521 = FALSE;
					/*X.RDB$CHARACTER_SET_ID*/
					isc_501.isc_552 = (USHORT) get_numeric(tdgbl);
					break;

				case att_field_collation_id:
					/*X.RDB$COLLATION_ID.NULL*/
					isc_501.isc_520 = FALSE;
					/*X.RDB$COLLATION_ID*/
					isc_501.isc_551 = (USHORT) get_numeric(tdgbl);
					break;

				case att_field_precision:
					if (tdgbl->RESTORE_format >= 6)
					{
						/*X.RDB$FIELD_PRECISION.NULL*/
						isc_501.isc_518 = FALSE;
						/*X.RDB$FIELD_PRECISION*/
						isc_501.isc_519 = (USHORT) get_numeric(tdgbl);
					}
					else
						bad_attribute (scan_next_attr, attribute, 92);
					break;

				default:
					bad_attribute (scan_next_attr, attribute, 92);
					// msg 92  domain
					break;
				}
			}

			if (/*X.RDB$FIELD_TYPE*/
			    isc_501.isc_517 <= DTYPE_BLR_MAX)
			{
				l = gds_cvt_blr_dtype[/*X.RDB$FIELD_TYPE*/
						      isc_501.isc_517];
				if (l = type_lengths[l])
					/*X.RDB$FIELD_LENGTH*/
					isc_501.isc_516 = l;
			}

			if (gfield)
				strcpy (gfield->gfld_name, /*X.RDB$FIELD_NAME*/
							   isc_501.isc_502);

			if (tdgbl->gbl_sw_fix_fss_data && tdgbl->gbl_sw_fix_fss_data_id == 0 &&
				!/*X.RDB$CHARACTER_SET_ID.NULL*/
				 isc_501.isc_521 && /*X.RDB$CHARACTER_SET_ID*/
    isc_501.isc_552 == CS_UNICODE_FSS &&
				((!/*X.RDB$CHARACTER_LENGTH.NULL*/
				   isc_501.isc_525 &&
					(/*X.RDB$FIELD_TYPE*/
					 isc_501.isc_517 == blr_text || /*X.RDB$FIELD_TYPE*/
		isc_501.isc_517 == blr_varying)) ||
				 /*X.RDB$FIELD_TYPE*/
				 isc_501.isc_517 == blr_blob))
			{
				if (/*X.RDB$FIELD_TYPE*/
				    isc_501.isc_517 != blr_blob)
					/*X.RDB$CHARACTER_LENGTH*/
					isc_501.isc_526 = /*X.RDB$FIELD_LENGTH*/
   isc_501.isc_516;

				/*X.RDB$CHARACTER_SET_ID*/
				isc_501.isc_552 = CS_NONE;
				/*X.RDB$COLLATION_ID*/
				isc_501.isc_551 = 0;
			}

		/*END_STORE;*/
		   
                   isc_start_and_send (isc_status, (FB_API_HANDLE*) &tdgbl->handles_get_global_field_req_handle1, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 352, &isc_501, (short) 0);
		   };
		/*ON_ERROR*/
		if (isc_status [1])
		   {
			general_on_error ();
		/*END_ERROR;*/
		   }
		}

	}
	else // RESTORE_ods < DB_VERSION_DDL10
	{
		// without rdb$field_precision

		/*STORE (REQUEST_HANDLE tdgbl->handles_get_global_field_req_handle1)
			X IN RDB$FIELDS*/
		{
		
                if (!tdgbl->handles_get_global_field_req_handle1)
                   isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &tdgbl->handles_get_global_field_req_handle1, (short) sizeof(isc_447), (char*) isc_447);
		if (tdgbl->handles_get_global_field_req_handle1)
		   {
		   isc_448.isc_450 = isc_blob_null;
		   isc_448.isc_451 = isc_blob_null;
		   isc_448.isc_452 = isc_blob_null;
		   isc_448.isc_453 = isc_blob_null;
		   isc_448.isc_454 = isc_blob_null;
		   isc_448.isc_455 = isc_blob_null;
		   isc_448.isc_456 = isc_blob_null;
		   isc_448.isc_457 = isc_blob_null;
		   isc_448.isc_460 = isc_blob_null;
		   isc_448.isc_461 = isc_blob_null;

			/*X.RDB$FIELD_SCALE*/
			isc_448.isc_499 = /*X.RDB$SEGMENT_LENGTH*/
   isc_448.isc_498 = 0;
			/*X.RDB$CHARACTER_SET_ID*/
			isc_448.isc_497 = /*X.RDB$COLLATION_ID*/
   isc_448.isc_496 = 0;
			/*X.RDB$FIELD_SUB_TYPE*/
			isc_448.isc_495 = 0;
			/*X.RDB$COMPUTED_BLR.NULL*/
			isc_448.isc_494 = TRUE;
			/*X.RDB$COMPUTED_SOURCE.NULL*/
			isc_448.isc_493 = TRUE;
			/*X.RDB$QUERY_NAME.NULL*/
			isc_448.isc_492 = TRUE;
			/*X.RDB$EDIT_STRING.NULL*/
			isc_448.isc_491 = TRUE;
			/*X.RDB$QUERY_HEADER.NULL*/
			isc_448.isc_490 = TRUE;
			/*X.RDB$MISSING_VALUE.NULL*/
			isc_448.isc_489 = TRUE;
			/*X.RDB$DEFAULT_VALUE.NULL*/
			isc_448.isc_488 = TRUE;
			/*X.RDB$VALIDATION_BLR.NULL*/
			isc_448.isc_487 = TRUE;
			/*X.RDB$VALIDATION_SOURCE.NULL*/
			isc_448.isc_486 = TRUE;
			/*X.RDB$SYSTEM_FLAG*/
			isc_448.isc_485 = 0;
			/*X.RDB$SYSTEM_FLAG.NULL*/
			isc_448.isc_484 = FALSE;
			/*X.RDB$NULL_FLAG.NULL*/
			isc_448.isc_482 = TRUE;
			/*X.RDB$DESCRIPTION.NULL*/
			isc_448.isc_481 = TRUE;
			/*X.RDB$DIMENSIONS.NULL*/
			isc_448.isc_479 = TRUE;
			/*X.RDB$EXTERNAL_LENGTH.NULL*/
			isc_448.isc_477 = TRUE;
			/*X.RDB$EXTERNAL_TYPE.NULL*/
			isc_448.isc_475 = TRUE;
			/*X.RDB$EXTERNAL_SCALE.NULL*/
			isc_448.isc_473 = TRUE;
			/*X.RDB$SEGMENT_LENGTH.NULL*/
			isc_448.isc_472 = TRUE;
			/*X.RDB$CHARACTER_LENGTH.NULL*/
			isc_448.isc_470 = TRUE;
			/*X.RDB$MISSING_SOURCE.NULL*/
			isc_448.isc_469 = TRUE;
			/*X.RDB$DEFAULT_SOURCE.NULL*/
			isc_448.isc_468 = TRUE;
			/*X.RDB$FIELD_SUB_TYPE.NULL*/
			isc_448.isc_467 = TRUE;
			/*X.RDB$CHARACTER_SET_ID.NULL*/
			isc_448.isc_466 = TRUE;
			/*X.RDB$COLLATION_ID.NULL*/
			isc_448.isc_465 = TRUE;

			skip_init(&scan_next_attr);
			while (skip_scan(&scan_next_attr), get_attribute(&attribute, tdgbl) != att_end)
			{
				switch (attribute)
				{
				case att_field_name:
					l = GET_TEXT(/*X.RDB$FIELD_NAME*/
						     isc_448.isc_449);
					MISC_terminate (/*X.RDB$FIELD_NAME*/
							isc_448.isc_449, temp, l, sizeof(temp));
					BURP_verbose (121, temp);
					// msg 121  restoring global field %s
					break;

				case att_field_query_name:
					GET_TEXT(/*X.RDB$QUERY_NAME*/
						 isc_448.isc_459);
					/*X.RDB$QUERY_NAME.NULL*/
					isc_448.isc_492 = FALSE;
					break;

				case att_field_edit_string:
					GET_TEXT(/*X.RDB$EDIT_STRING*/
						 isc_448.isc_458);
					/*X.RDB$EDIT_STRING.NULL*/
					isc_448.isc_491 = FALSE;
					break;

				case att_field_query_header:
					/*X.RDB$QUERY_HEADER.NULL*/
					isc_448.isc_490 = FALSE;
					get_source_blob (tdgbl, /*X.RDB$QUERY_HEADER*/
								isc_448.isc_457, false);
					break;

				case att_field_type:
					/*X.RDB$FIELD_TYPE*/
					isc_448.isc_464 = (USHORT) get_numeric(tdgbl);
					break;

				case att_field_length:
					/*X.RDB$FIELD_LENGTH*/
					isc_448.isc_463 = (USHORT) get_numeric(tdgbl);
					break;

				case att_field_scale:
					/*X.RDB$FIELD_SCALE*/
					isc_448.isc_499 = (USHORT) get_numeric(tdgbl);
					/*X.RDB$FIELD_SCALE.NULL*/
					isc_448.isc_462 = FALSE;
					break;

				case att_field_sub_type:
					/*X.RDB$FIELD_SUB_TYPE*/
					isc_448.isc_495 = (USHORT) get_numeric(tdgbl);
					/*X.RDB$FIELD_SUB_TYPE.NULL*/
					isc_448.isc_467 = FALSE;
					break;

				case att_field_segment_length:
					/*X.RDB$SEGMENT_LENGTH*/
					isc_448.isc_498 = (USHORT) get_numeric(tdgbl);
					if (/*X.RDB$SEGMENT_LENGTH*/
					    isc_448.isc_498)
						/*X.RDB$SEGMENT_LENGTH.NULL*/
						isc_448.isc_472 = FALSE;
					break;

				case att_field_computed_blr:
					// if we are going against a V4.0 database,
					// restore the global fields in 2 phases.

					if (tdgbl->global_trans)
					{
						if (!gfield)
							gfield = (gfld*) BURP_alloc_zero(sizeof(gfld));

						get_blr_blob (tdgbl, gfield->gfld_computed_blr, true);
						gfield->gfld_flags |= GFLD_computed_blr;
					}
					else
					{
						/*X.RDB$COMPUTED_BLR.NULL*/
						isc_448.isc_494 = FALSE;
						get_blr_blob (tdgbl, /*X.RDB$COMPUTED_BLR*/
								     isc_448.isc_461, false);
					}
					break;

				case att_field_computed_source:
					// if we are going against a V4.0 database,
					// restore the global fields in 2 phases.

					if (tdgbl->global_trans)
					{
						if (!gfield)
							gfield = (gfld*) BURP_alloc_zero(sizeof(gfld));

						get_misc_blob (tdgbl, gfield->gfld_computed_source, true);
						gfield->gfld_flags |= GFLD_computed_source;
					}
					else
					{
						/*X.RDB$COMPUTED_SOURCE.NULL*/
						isc_448.isc_493 = FALSE;
						get_misc_blob (tdgbl, /*X.RDB$COMPUTED_SOURCE*/
								      isc_448.isc_460, false);
					}
					break;

				case att_field_computed_source2:
					// if we are going against a V4.0 database,
					// restore the global fields in 2 phases.

					if (tdgbl->global_trans)
					{
						if (!gfield)
							gfield = (gfld*) BURP_alloc_zero(sizeof(gfld));

						get_source_blob (tdgbl, gfield->gfld_computed_source2, true);
						gfield->gfld_flags |= GFLD_computed_source2;
					}
					else
					{
						/*X.RDB$COMPUTED_SOURCE.NULL*/
						isc_448.isc_493 = FALSE;
						get_source_blob (tdgbl, /*X.RDB$COMPUTED_SOURCE*/
									isc_448.isc_460, false);
					}
					break;

				case att_field_validation_blr:
					if (tdgbl->gbl_sw_novalidity)
						eat_blob(tdgbl);
					else
					{
						// if we are going against a V4.0 database,
						// restore the global fields in 2 phases.

						if (tdgbl->global_trans)
						{
							if (!gfield)
								gfield = (gfld*) BURP_alloc_zero(sizeof(gfld));

							get_blr_blob (tdgbl, gfield->gfld_vb, true);
							gfield->gfld_flags |= GFLD_validation_blr;
						}
						else
						{
							/*X.RDB$VALIDATION_BLR.NULL*/
							isc_448.isc_487 = FALSE;
							get_blr_blob (tdgbl, /*X.RDB$VALIDATION_BLR*/
									     isc_448.isc_454, false);
						}
					}
					break;

				case att_field_validation_source:
					if (tdgbl->gbl_sw_novalidity)
						eat_blob(tdgbl);
					else
					{
						// if we are going against a V4.0 database,
						// restore the global fields in 2 phases.

						if (tdgbl->global_trans)
						{
							if (!gfield)
								gfield = (gfld*) BURP_alloc_zero(sizeof(gfld));

							get_misc_blob (tdgbl, gfield->gfld_vs, true);
							gfield->gfld_flags |= GFLD_validation_source;
						}
						else
						{
							/*X.RDB$VALIDATION_SOURCE.NULL*/
							isc_448.isc_486 = FALSE;
							get_misc_blob (tdgbl, /*X.RDB$VALIDATION_SOURCE*/
									      isc_448.isc_453, false);
						}
					}
					break;

				case att_field_validation_source2:
					if (tdgbl->gbl_sw_novalidity)
						eat_blob(tdgbl);
					else
					{
						// if we are going against a V4.0 database,
						// restore the global fields in 2 phases.

						if (tdgbl->global_trans)
						{
							if (!gfield)
								gfield = (gfld*) BURP_alloc_zero(sizeof(gfld));

							get_source_blob (tdgbl, gfield->gfld_vs2, true);
							gfield->gfld_flags |= GFLD_validation_source2;
						}
						else
						{
							/*X.RDB$VALIDATION_SOURCE.NULL*/
							isc_448.isc_486 = FALSE;
							get_source_blob (tdgbl, /*X.RDB$VALIDATION_SOURCE*/
										isc_448.isc_453, false);
						}
					}
					break;

				case att_field_missing_value:
					/*X.RDB$MISSING_VALUE.NULL*/
					isc_448.isc_489 = FALSE;
					get_blr_blob (tdgbl, /*X.RDB$MISSING_VALUE*/
							     isc_448.isc_456, false);
					break;

				case att_field_default_value:
					/*X.RDB$DEFAULT_VALUE.NULL*/
					isc_448.isc_488 = FALSE;
					get_blr_blob (tdgbl, /*X.RDB$DEFAULT_VALUE*/
							     isc_448.isc_455, false);
					break;

				case att_field_system_flag:
					/*X.RDB$SYSTEM_FLAG*/
					isc_448.isc_485 = (USHORT) get_numeric(tdgbl);
					/*X.RDB$SYSTEM_FLAG.NULL*/
					isc_448.isc_484 = FALSE;
					break;

				case att_field_null_flag:
					if (tdgbl->gbl_sw_novalidity) {
						get_numeric(tdgbl); // skip
					}
					else {
						/*X.RDB$NULL_FLAG*/
						isc_448.isc_483 = (USHORT) get_numeric(tdgbl);
						/*X.RDB$NULL_FLAG.NULL*/
						isc_448.isc_482 = FALSE;
					}
					break;

				case att_field_description:
					/*X.RDB$DESCRIPTION.NULL*/
					isc_448.isc_481 = FALSE;
					get_misc_blob (tdgbl, /*X.RDB$DESCRIPTION*/
							      isc_448.isc_452, false);
					break;

				case att_field_description2:
					/*X.RDB$DESCRIPTION.NULL*/
					isc_448.isc_481 = FALSE;
					get_source_blob (tdgbl, /*X.RDB$DESCRIPTION*/
								isc_448.isc_452, false);
					break;

				case att_field_external_length:
					/*X.RDB$EXTERNAL_LENGTH.NULL*/
					isc_448.isc_477 = FALSE;
					/*X.RDB$EXTERNAL_LENGTH*/
					isc_448.isc_478 = (USHORT) get_numeric(tdgbl);
					break;

				case att_field_external_scale:
					/*X.RDB$EXTERNAL_SCALE.NULL*/
					isc_448.isc_473 = FALSE;
					/*X.RDB$EXTERNAL_SCALE*/
					isc_448.isc_474 = (USHORT) get_numeric(tdgbl);
					break;

				case att_field_external_type:
					/*X.RDB$EXTERNAL_TYPE.NULL*/
					isc_448.isc_475 = FALSE;
					/*X.RDB$EXTERNAL_TYPE*/
					isc_448.isc_476 = (USHORT) get_numeric(tdgbl);
					break;

				case att_field_dimensions:
					/*X.RDB$DIMENSIONS.NULL*/
					isc_448.isc_479 = FALSE;
					/*X.RDB$DIMENSIONS*/
					isc_448.isc_480 = (USHORT) get_numeric(tdgbl);
					break;

				case att_field_character_length:
					/*X.RDB$CHARACTER_LENGTH.NULL*/
					isc_448.isc_470 = FALSE;
					/*X.RDB$CHARACTER_LENGTH*/
					isc_448.isc_471 = (USHORT) get_numeric(tdgbl);
					break;

				case att_field_default_source:
					/*X.RDB$DEFAULT_SOURCE.NULL*/
					isc_448.isc_468 = FALSE;
					get_source_blob (tdgbl, /*X.RDB$DEFAULT_SOURCE*/
								isc_448.isc_450, false);
					break;

				case att_field_missing_source:
					/*X.RDB$MISSING_SOURCE.NULL*/
					isc_448.isc_469 = FALSE;
					get_source_blob (tdgbl, /*X.RDB$MISSING_SOURCE*/
								isc_448.isc_451, false);
					break;

				case att_field_character_set:
					/*X.RDB$CHARACTER_SET_ID.NULL*/
					isc_448.isc_466 = FALSE;
					/*X.RDB$CHARACTER_SET_ID*/
					isc_448.isc_497 = (USHORT) get_numeric(tdgbl);
					break;

				case att_field_collation_id:
					/*X.RDB$COLLATION_ID.NULL*/
					isc_448.isc_465 = FALSE;
					/*X.RDB$COLLATION_ID*/
					isc_448.isc_496 = (USHORT) get_numeric(tdgbl);
					break;

				case att_field_precision:
					if (tdgbl->RESTORE_format >= 6)
						get_numeric(tdgbl);
					else
						bad_attribute (scan_next_attr, attribute, 92);
					break;

				default:
					bad_attribute (scan_next_attr, attribute, 92);
					// msg 92  domain
					break;
				}
			}

			if (/*X.RDB$FIELD_TYPE*/
			    isc_448.isc_464 <= DTYPE_BLR_MAX)
			{
				l = gds_cvt_blr_dtype[/*X.RDB$FIELD_TYPE*/
						      isc_448.isc_464];
				if (l = type_lengths[l])
					/*X.RDB$FIELD_LENGTH*/
					isc_448.isc_463 = l;
			}

			if (gfield)
				strcpy (gfield->gfld_name, /*X.RDB$FIELD_NAME*/
							   isc_448.isc_449);

			if (tdgbl->gbl_sw_fix_fss_data && tdgbl->gbl_sw_fix_fss_data_id == 0 &&
				!/*X.RDB$CHARACTER_SET_ID.NULL*/
				 isc_448.isc_466 && /*X.RDB$CHARACTER_SET_ID*/
    isc_448.isc_497 == CS_UNICODE_FSS &&
				((!/*X.RDB$CHARACTER_LENGTH.NULL*/
				   isc_448.isc_470 &&
					(/*X.RDB$FIELD_TYPE*/
					 isc_448.isc_464 == blr_text || /*X.RDB$FIELD_TYPE*/
		isc_448.isc_464 == blr_varying)) ||
				 /*X.RDB$FIELD_TYPE*/
				 isc_448.isc_464 == blr_blob))
			{
				if (/*X.RDB$FIELD_TYPE*/
				    isc_448.isc_464 != blr_blob)
					/*X.RDB$CHARACTER_LENGTH*/
					isc_448.isc_471 = /*X.RDB$FIELD_LENGTH*/
   isc_448.isc_463;

				/*X.RDB$CHARACTER_SET_ID*/
				isc_448.isc_497 = CS_NONE;
				/*X.RDB$COLLATION_ID*/
				isc_448.isc_496 = 0;
			}

		/*END_STORE;*/
		   
                   isc_start_and_send (isc_status, (FB_API_HANDLE*) &tdgbl->handles_get_global_field_req_handle1, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 348, &isc_448, (short) 0);
		   };
		/*ON_ERROR*/
		if (isc_status [1])
		   {
			general_on_error ();
		/*END_ERROR;*/
		   }
		}

	}

	if (gfield)
	{
		gfield->gfld_next = tdgbl->gbl_global_fields;
		tdgbl->gbl_global_fields = gfield;
	}

	return true;
}

bool get_index(BurpGlobals* tdgbl, const burp_rel* relation)
{
   struct isc_415_struct {
          short isc_416;	/* isc_utility */
   } isc_415;
   struct isc_413_struct {
          short isc_414;	/* isc_utility */
   } isc_413;
   struct isc_411_struct {
          short isc_412;	/* isc_utility */
   } isc_411;
   struct isc_409_struct {
          char  isc_410 [32];	/* RDB$INDEX_NAME */
   } isc_409;
   struct isc_421_struct {
          short isc_422;	/* isc_utility */
   } isc_421;
   struct isc_418_struct {
          char  isc_419 [32];	/* RDB$RELATION_NAME */
          char  isc_420 [32];	/* RDB$INDEX_NAME */
   } isc_418;
   struct isc_424_struct {
          char  isc_425 [32];	/* RDB$INDEX_NAME */
          char  isc_426 [32];	/* RDB$FIELD_NAME */
          short isc_427;	/* RDB$FIELD_POSITION */
   } isc_424;
   struct isc_429_struct {
          char  isc_430 [32];	/* RDB$INDEX_NAME */
          ISC_QUAD isc_431;	/* RDB$EXPRESSION_BLR */
          ISC_QUAD isc_432;	/* RDB$EXPRESSION_SOURCE */
          char  isc_433 [32];	/* RDB$FOREIGN_KEY */
          ISC_QUAD isc_434;	/* RDB$DESCRIPTION */
          char  isc_435 [32];	/* RDB$RELATION_NAME */
          short isc_436;	/* RDB$SEGMENT_COUNT */
          short isc_437;	/* gds__null_flag */
          short isc_438;	/* RDB$SYSTEM_FLAG */
          short isc_439;	/* gds__null_flag */
          short isc_440;	/* gds__null_flag */
          short isc_441;	/* gds__null_flag */
          short isc_442;	/* gds__null_flag */
          short isc_443;	/* gds__null_flag */
          short isc_444;	/* RDB$INDEX_TYPE */
          short isc_445;	/* RDB$INDEX_INACTIVE */
          short isc_446;	/* RDB$UNIQUE_FLAG */
   } isc_429;
/**************************************
 *
 *	g e t _ i n d e x
 *
 **************************************
 *
 * Functional description
 *	Build an index.  At the end stop
 *	and check that all fields are defined.
 *	If any fields are missing, delete the
 *	index.
 *
 **************************************/
	/*BASED_ON RDB$INDICES.RDB$INDEX_NAME index_name;*/
	char
	   index_name[32];

	att_type	attribute;
	bool		foreign_index = false;
	scan_attr_t		scan_next_attr;

	SSHORT count = 0, segments = 0;

	/*STORE (REQUEST_HANDLE tdgbl->handles_get_index_req_handle1)
		X IN RDB$INDICES*/
	{
	
        if (!tdgbl->handles_get_index_req_handle1)
           isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &tdgbl->handles_get_index_req_handle1, (short) sizeof(isc_428), (char*) isc_428);
	if (tdgbl->handles_get_index_req_handle1)
	   {
	   isc_429.isc_431 = isc_blob_null;
	   isc_429.isc_432 = isc_blob_null;
	   isc_429.isc_434 = isc_blob_null;
		strcpy (/*X.RDB$RELATION_NAME*/
			isc_429.isc_435, relation->rel_name);
		/*X.RDB$UNIQUE_FLAG*/
		isc_429.isc_446 = 0;
		if (!tdgbl->gbl_sw_deactivate_indexes)
			/*X.RDB$INDEX_INACTIVE*/
			isc_429.isc_445 = FALSE;
		else
			/*X.RDB$INDEX_INACTIVE*/
			isc_429.isc_445 = TRUE;
		/*X.RDB$INDEX_TYPE.NULL*/
		isc_429.isc_443 = TRUE;
		/*X.RDB$DESCRIPTION.NULL*/
		isc_429.isc_442 = TRUE;
		/*X.RDB$FOREIGN_KEY.NULL*/
		isc_429.isc_441 = TRUE;
		/*X.RDB$EXPRESSION_SOURCE.NULL*/
		isc_429.isc_440 = TRUE;
		/*X.RDB$EXPRESSION_BLR.NULL*/
		isc_429.isc_439 = TRUE;
		/*X.RDB$SYSTEM_FLAG*/
		isc_429.isc_438 = 0;
		/*X.RDB$SYSTEM_FLAG.NULL*/
		isc_429.isc_437 = FALSE;

		skip_init(&scan_next_attr);
		while (skip_scan(&scan_next_attr), get_attribute(&attribute, tdgbl) != att_end)
		{
			switch (attribute)
			{
			case att_index_name:
				GET_TEXT(/*X.RDB$INDEX_NAME*/
					 isc_429.isc_430);
				strcpy (index_name, /*X.RDB$INDEX_NAME*/
						    isc_429.isc_430);
				BURP_verbose (122, /*X.RDB$INDEX_NAME*/
						   isc_429.isc_430);
				break;

			case att_segment_count:
				/*X.RDB$SEGMENT_COUNT*/
				isc_429.isc_436 = segments = (USHORT) get_numeric(tdgbl);
				break;

			case att_index_unique_flag:
				/*X.RDB$UNIQUE_FLAG*/
				isc_429.isc_446 = (USHORT) get_numeric(tdgbl);
				break;

			case att_index_inactive:
				/*X.RDB$INDEX_INACTIVE*/
				isc_429.isc_445 = (USHORT) get_numeric(tdgbl);
				// Defer foreign key index activation
				// Modified by Toni Martir, all index deferred when verbose
				if (tdgbl->gbl_sw_verbose)
				{
					if (!/*X.RDB$INDEX_INACTIVE*/
					     isc_429.isc_445)
						/*X.RDB$INDEX_INACTIVE*/
						isc_429.isc_445 = DEFERRED_ACTIVE;
				}
				else
				{
					if (!/*X.RDB$INDEX_INACTIVE*/
					     isc_429.isc_445 && foreign_index)
						/*X.RDB$INDEX_INACTIVE*/
						isc_429.isc_445 = DEFERRED_ACTIVE;
				}
				if (tdgbl->gbl_sw_deactivate_indexes)
					/*X.RDB$INDEX_INACTIVE*/
					isc_429.isc_445 = TRUE;
				break;

			case att_index_type:
				/*X.RDB$INDEX_TYPE.NULL*/
				isc_429.isc_443 = FALSE;
				/*X.RDB$INDEX_TYPE*/
				isc_429.isc_444 = (USHORT) get_numeric(tdgbl);
				break;

			case att_index_field_name:
				/*STORE (REQUEST_HANDLE tdgbl->handles_get_index_req_handle2)
					Y IN RDB$INDEX_SEGMENTS*/
				{
				
                                if (!tdgbl->handles_get_index_req_handle2)
                                   isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &tdgbl->handles_get_index_req_handle2, (short) sizeof(isc_423), (char*) isc_423);
				if (tdgbl->handles_get_index_req_handle2)
				   {
					GET_TEXT(/*Y.RDB$FIELD_NAME*/
						 isc_424.isc_426);
					strcpy (/*Y.RDB$INDEX_NAME*/
						isc_424.isc_425, /*X.RDB$INDEX_NAME*/
  isc_429.isc_430);
					/*Y.RDB$FIELD_POSITION*/
					isc_424.isc_427 = count++;
				/*END_STORE;*/
				   
                                   isc_start_and_send (isc_status, (FB_API_HANDLE*) &tdgbl->handles_get_index_req_handle2, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 66, &isc_424, (short) 0);
				   };
				/*ON_ERROR*/
				if (isc_status [1])
				   {
					general_on_error ();
				/*END_ERROR;*/
				   }
				}
				break;

			case att_index_description:
				/*X.RDB$DESCRIPTION.NULL*/
				isc_429.isc_442 = FALSE;
				get_misc_blob (tdgbl, /*X.RDB$DESCRIPTION*/
						      isc_429.isc_434, false);
				break;

			case att_index_description2:
				/*X.RDB$DESCRIPTION.NULL*/
				isc_429.isc_442 = FALSE;
				get_source_blob (tdgbl, /*X.RDB$DESCRIPTION*/
							isc_429.isc_434, false);
				break;

			case att_index_expression_source:
				/*X.RDB$EXPRESSION_SOURCE.NULL*/
				isc_429.isc_440 = FALSE;
				get_source_blob (tdgbl, /*X.RDB$EXPRESSION_SOURCE*/
							isc_429.isc_432, false);
				break;

			case att_index_expression_blr:
				/*X.RDB$EXPRESSION_BLR.NULL*/
				isc_429.isc_439 = FALSE;
				get_blr_blob (tdgbl, /*X.RDB$EXPRESSION_BLR*/
						     isc_429.isc_431, false);
				break;

			case att_index_foreign_key:
				foreign_index = true;
				// Defer foreign key index activation
				if (!/*X.RDB$INDEX_INACTIVE*/
				     isc_429.isc_445)
					/*X.RDB$INDEX_INACTIVE*/
					isc_429.isc_445 = DEFERRED_ACTIVE;
				if (tdgbl->gbl_sw_deactivate_indexes)
					/*X.RDB$INDEX_INACTIVE*/
					isc_429.isc_445 = TRUE;
				/*X.RDB$FOREIGN_KEY.NULL*/
				isc_429.isc_441 = FALSE;
				GET_TEXT(/*X.RDB$FOREIGN_KEY*/
					 isc_429.isc_433);
				break;

			default:
				bad_attribute (scan_next_attr, attribute, 93);
				// msg 93 index
				break;
			}
		}

		count = 0;
		/*FOR (REQUEST_HANDLE tdgbl->handles_get_index_req_handle3)
			RFR IN RDB$RELATION_FIELDS CROSS I_S IN RDB$INDEX_SEGMENTS
			OVER RDB$FIELD_NAME WITH I_S.RDB$INDEX_NAME = index_name AND
			RFR.RDB$RELATION_NAME = relation->rel_name*/
		{
                if (!tdgbl->handles_get_index_req_handle3)
                   isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &tdgbl->handles_get_index_req_handle3, (short) sizeof(isc_417), (char*) isc_417);
		isc_vtov ((const char*) relation->rel_name, (char*) isc_418.isc_419, 32);
		isc_vtov ((const char*) index_name, (char*) isc_418.isc_420, 32);
		if (tdgbl->handles_get_index_req_handle3)
		   {
                   isc_start_and_send (isc_status, (FB_API_HANDLE*) &tdgbl->handles_get_index_req_handle3, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 64, &isc_418, (short) 0);
		   }
		if (!isc_status [1]) {
		while (1)
		   {
                   isc_receive (isc_status, (FB_API_HANDLE*) &tdgbl->handles_get_index_req_handle3, (short) 1, (short) 2, &isc_421, (short) 0);
		   if (!isc_421.isc_422 || isc_status [1]) break;
			count++;
		/*END_FOR;*/
		   }
		   };
		/*ON_ERROR*/
		if (isc_status [1])
		   {
			general_on_error ();
		/*END_ERROR;*/
		   }
		}

		if (count != segments)
		{
			/*FOR (REQUEST_HANDLE tdgbl->handles_get_index_req_handle4)
				I_S IN RDB$INDEX_SEGMENTS WITH I_S.RDB$INDEX_NAME = index_name*/
			{
                        if (!tdgbl->handles_get_index_req_handle4)
                           isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &tdgbl->handles_get_index_req_handle4, (short) sizeof(isc_408), (char*) isc_408);
			isc_vtov ((const char*) index_name, (char*) isc_409.isc_410, 32);
			if (tdgbl->handles_get_index_req_handle4)
			   {
                           isc_start_and_send (isc_status, (FB_API_HANDLE*) &tdgbl->handles_get_index_req_handle4, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 32, &isc_409, (short) 0);
			   }
			if (!isc_status [1]) {
			while (1)
			   {
                           isc_receive (isc_status, (FB_API_HANDLE*) &tdgbl->handles_get_index_req_handle4, (short) 1, (short) 2, &isc_411, (short) 0);
			   if (!isc_411.isc_412 || isc_status [1]) break;
				/*ERASE I_S;*/
				{
                                isc_send (isc_status, (FB_API_HANDLE*) &tdgbl->handles_get_index_req_handle4, (short) 2, (short) 2, &isc_413, (short) 0);
				/*ON_ERROR*/
				if (isc_status [1])
				   {
					general_on_error ();
				/*END_ERROR;*/
				   }
				}
			/*END_FOR;*/
                           isc_send (isc_status, (FB_API_HANDLE*) &tdgbl->handles_get_index_req_handle4, (short) 3, (short) 2, &isc_415, (short) 0);
			   }
			   };
			/*ON_ERROR*/
			if (isc_status [1])
			   {
				general_on_error ();
			/*END_ERROR;*/
			   }
			}
			return false;
		}
	/*END_STORE;*/
	   
           isc_start_and_send (isc_status, (FB_API_HANDLE*) &tdgbl->handles_get_index_req_handle1, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 142, &isc_429, (short) 0);
	   };
	/*ON_ERROR*/
	if (isc_status [1])
	   {
		general_on_error ();
	/*END_ERROR;*/
	   }
	}

	return true;
}

void get_misc_blob(BurpGlobals* tdgbl,
				   ISC_QUAD&	blob_id,
				   bool			glb_trans)
{
/**************************************
 *
 *	g e t _ m i s c _ b l o b
 *
 **************************************
 *
 * Functional description
 *	Read blob attributes and copy data from input file to nice,
 *	shiney, new blob.
 *
 **************************************/
	ISC_STATUS_ARRAY	status_vector;

	const size_t length = get_numeric(tdgbl);

	// Create new blob

	isc_tr_handle	local_trans;
	if (glb_trans && tdgbl->global_trans)
		local_trans = tdgbl->global_trans;
	else
		local_trans = gds_trans;

	UserBlob blob(status_vector);
	if (!blob.create(DB, local_trans, blob_id))
	{
		BURP_error_redirect (status_vector, 37);
		// msg 37 isc_create_blob failed
	}

	// Allocate blob buffer if static buffer is too short
	BlobBuffer static_buffer;
	UCHAR* const buffer = static_buffer.getBuffer(length);

	if (length)
	{
		get_block(tdgbl, buffer, length);
	}

	if (!blob.putData(length, buffer))
	{
		BURP_error_redirect (status_vector, 38);
		// msg 38 isc_put_segment failed
	}

	if (!blob.close())
		BURP_error_redirect (status_vector, 23);
		// msg 23 isc_close_blob failed
}

SLONG get_numeric(BurpGlobals* tdgbl)
{
/**************************************
 *
 *	g e t _ n u m e r i c
 *
 **************************************
 *
 * Functional description
 *	Get a numeric value from the input stream.
 *
 **************************************/
	SLONG	value[2];

	// get_text needs additional space for the terminator,
	// because it treats everything as strings.
	fb_assert(sizeof(value) > sizeof(SLONG));

	const SSHORT length = get_text(tdgbl, (TEXT*) value, sizeof(value));

	return isc_vax_integer ((SCHAR *) value, length);
}

SINT64 get_int64(BurpGlobals* tdgbl)
{
/**************************************
 *
 *	g e t _ i n t 6 4
 *
 **************************************
 *
 * Functional description
 *	Get a possibly-64-bit numeric value from the input stream.
 *
 **************************************/
	SLONG	value[4];

	// get_text needs additional space for the terminator,
	// because it treats everything as strings.
	fb_assert (sizeof(value) > sizeof(SINT64));

	const SSHORT length = get_text(tdgbl, (TEXT*) value, sizeof(value));

	return isc_portable_integer ((UCHAR *) value, length);
}

bool get_procedure(BurpGlobals* tdgbl)
{
   struct isc_369_struct {
          ISC_QUAD isc_370;	/* RDB$PROCEDURE_BLR */
          char  isc_371 [32];	/* RDB$PROCEDURE_NAME */
          char  isc_372 [32];	/* RDB$OWNER_NAME */
          char  isc_373 [32];	/* RDB$SECURITY_CLASS */
          ISC_QUAD isc_374;	/* RDB$DESCRIPTION */
          ISC_QUAD isc_375;	/* RDB$PROCEDURE_SOURCE */
          short isc_376;	/* RDB$PROCEDURE_OUTPUTS */
          short isc_377;	/* gds__null_flag */
          short isc_378;	/* RDB$PROCEDURE_INPUTS */
          short isc_379;	/* gds__null_flag */
          short isc_380;	/* RDB$SYSTEM_FLAG */
          short isc_381;	/* gds__null_flag */
          short isc_382;	/* gds__null_flag */
          short isc_383;	/* gds__null_flag */
          short isc_384;	/* gds__null_flag */
   } isc_369;
   struct isc_386_struct {
          ISC_QUAD isc_387;	/* RDB$PROCEDURE_BLR */
          char  isc_388 [32];	/* RDB$PROCEDURE_NAME */
          ISC_QUAD isc_389;	/* RDB$DEBUG_INFO */
          char  isc_390 [32];	/* RDB$OWNER_NAME */
          char  isc_391 [32];	/* RDB$SECURITY_CLASS */
          ISC_QUAD isc_392;	/* RDB$DESCRIPTION */
          ISC_QUAD isc_393;	/* RDB$PROCEDURE_SOURCE */
          short isc_394;	/* RDB$PROCEDURE_OUTPUTS */
          short isc_395;	/* gds__null_flag */
          short isc_396;	/* RDB$PROCEDURE_INPUTS */
          short isc_397;	/* gds__null_flag */
          short isc_398;	/* gds__null_flag */
          short isc_399;	/* RDB$VALID_BLR */
          short isc_400;	/* gds__null_flag */
          short isc_401;	/* RDB$SYSTEM_FLAG */
          short isc_402;	/* gds__null_flag */
          short isc_403;	/* RDB$PROCEDURE_TYPE */
          short isc_404;	/* gds__null_flag */
          short isc_405;	/* gds__null_flag */
          short isc_406;	/* gds__null_flag */
          short isc_407;	/* gds__null_flag */
   } isc_386;
/**************************************
 *
 *	g e t _ p r o c e d u r e
 *
 **************************************
 *
 * Functional description
 *	Reconstruct a stored procedure.
 *	Use the global_trans so we don't have to commit
 *	until after the indices are activated.  This
 *	will allow us to use a PLAN in a SP.
 *
 **************************************/
	att_type	attribute;
	GDS_NAME	procedure_name = "";
	TEXT		temp[GDS_NAME_LEN];
	SSHORT		l;
	scan_attr_t		scan_next_attr;

	isc_tr_handle local_trans = tdgbl->global_trans ? tdgbl->global_trans : gds_trans;

	burp_prc* procedure = (burp_prc*) BURP_alloc_zero (sizeof(burp_prc));
	procedure->prc_next = tdgbl->procedures;
	tdgbl->procedures = procedure;

	if (tdgbl->RESTORE_ods >= DB_VERSION_DDL11_1)
	{
		/*STORE (TRANSACTION_HANDLE local_trans
				REQUEST_HANDLE tdgbl->handles_get_procedure_req_handle1)
			X IN RDB$PROCEDURES*/
		{
		
                if (!tdgbl->handles_get_procedure_req_handle1)
                   isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &tdgbl->handles_get_procedure_req_handle1, (short) sizeof(isc_385), (char*) isc_385);
		if (tdgbl->handles_get_procedure_req_handle1)
		   {
		   isc_386.isc_387 = isc_blob_null;
		   isc_386.isc_389 = isc_blob_null;
		   isc_386.isc_392 = isc_blob_null;
		   isc_386.isc_393 = isc_blob_null;
			/*X.RDB$PROCEDURE_SOURCE.NULL*/
			isc_386.isc_407 = TRUE;
			/*X.RDB$DESCRIPTION.NULL*/
			isc_386.isc_406 = TRUE;
			/*X.RDB$SECURITY_CLASS.NULL*/
			isc_386.isc_405 = TRUE;
			/*X.RDB$OWNER_NAME.NULL*/
			isc_386.isc_404 = TRUE;
			/*X.RDB$PROCEDURE_TYPE.NULL*/
			isc_386.isc_402 = FALSE;
			/*X.RDB$PROCEDURE_TYPE*/
			isc_386.isc_403 = 0;
			/*X.RDB$SYSTEM_FLAG*/
			isc_386.isc_401 = 0;
			/*X.RDB$SYSTEM_FLAG.NULL*/
			isc_386.isc_400 = FALSE;
			/*X.RDB$VALID_BLR.NULL*/
			isc_386.isc_398 = TRUE;
			/*X.RDB$DEBUG_INFO.NULL*/
			isc_386.isc_397 = TRUE;

			skip_init(&scan_next_attr);
			while (skip_scan(&scan_next_attr), get_attribute(&attribute, tdgbl) != att_end)
			{
				switch (attribute)
				{
				case att_procedure_name:
					l = GET_TEXT(/*X.RDB$PROCEDURE_NAME*/
						     isc_386.isc_388);
					//procedure->prc_name_length = l;
					strcpy (procedure->prc_name, /*X.RDB$PROCEDURE_NAME*/
								     isc_386.isc_388);
					MISC_terminate (/*X.RDB$PROCEDURE_NAME*/
							isc_386.isc_388, temp, l, sizeof(temp));
					BURP_verbose (195, temp);
					// msg 195 restoring stored procedure %s
					break;

				case att_procedure_description:
					get_misc_blob (tdgbl, /*X.RDB$DESCRIPTION*/
							      isc_386.isc_392, true);
					/*X.RDB$DESCRIPTION.NULL*/
					isc_386.isc_406 = FALSE;
					break;

				case att_procedure_description2:
					get_source_blob (tdgbl, /*X.RDB$DESCRIPTION*/
								isc_386.isc_392, true);
					/*X.RDB$DESCRIPTION.NULL*/
					isc_386.isc_406 = FALSE;
					break;

				case att_procedure_source:
					get_misc_blob (tdgbl, /*X.RDB$PROCEDURE_SOURCE*/
							      isc_386.isc_393, true);
					/*X.RDB$PROCEDURE_SOURCE.NULL*/
					isc_386.isc_407 = FALSE;
					break;

				case att_procedure_source2:
					get_source_blob (tdgbl, /*X.RDB$PROCEDURE_SOURCE*/
								isc_386.isc_393, true);
					/*X.RDB$PROCEDURE_SOURCE.NULL*/
					isc_386.isc_407 = FALSE;
					break;

				case att_procedure_blr:
					get_blr_blob (tdgbl, /*X.RDB$PROCEDURE_BLR*/
							     isc_386.isc_387, true);
					break;

				case att_procedure_security_class:
					GET_TEXT(/*X.RDB$SECURITY_CLASS*/
						 isc_386.isc_391);
					fix_security_class_name(tdgbl, /*X.RDB$SECURITY_CLASS*/
								       isc_386.isc_391, false);
					/*X.RDB$SECURITY_CLASS.NULL*/
					isc_386.isc_405 = FALSE;
					break;

				case att_procedure_owner_name:
					GET_TEXT(procedure->prc_owner);
					break;

				case att_procedure_inputs:
					/*X.RDB$PROCEDURE_INPUTS*/
					isc_386.isc_396 = (USHORT) get_numeric(tdgbl);
					if (/*X.RDB$PROCEDURE_INPUTS*/
					    isc_386.isc_396 == 0)
						/*X.RDB$PROCEDURE_INPUTS.NULL*/
						isc_386.isc_395 = TRUE;
					else
						/*X.RDB$PROCEDURE_INPUTS.NULL*/
						isc_386.isc_395 = FALSE;
					break;

				case att_procedure_outputs:
					/*X.RDB$PROCEDURE_OUTPUTS*/
					isc_386.isc_394 = (USHORT) get_numeric(tdgbl);
					break;

				case att_procedure_type:
					if (tdgbl->RESTORE_format >= 8)
						/*X.RDB$PROCEDURE_TYPE*/
						isc_386.isc_403 = (USHORT) get_numeric(tdgbl);
					else
						bad_attribute (scan_next_attr, attribute, 290);
					break;

				case att_procedure_valid_blr:
					if (tdgbl->RESTORE_format >= 8)
					{
						/*X.RDB$VALID_BLR.NULL*/
						isc_386.isc_398 = FALSE;
						/*X.RDB$VALID_BLR*/
						isc_386.isc_399 = (USHORT) get_numeric(tdgbl);
					}
					else
						bad_attribute (scan_next_attr, attribute, 290);
					break;

				case att_procedure_debug_info:
					if (tdgbl->RESTORE_format >= 8)
					{
						/*X.RDB$DEBUG_INFO.NULL*/
						isc_386.isc_397 = FALSE;
						get_misc_blob (tdgbl, /*X.RDB$DEBUG_INFO*/
								      isc_386.isc_389, true);
					}
					else
						bad_attribute (scan_next_attr, attribute, 290);
					break;

				default:
					bad_attribute (scan_next_attr, attribute, 290);
					// msg 290 procedure
					break;
				}
			}
			strcpy (procedure_name, /*X.RDB$PROCEDURE_NAME*/
						isc_386.isc_388);
		/*END_STORE;*/
		   
                   isc_start_and_send (isc_status, (FB_API_HANDLE*) &tdgbl->handles_get_procedure_req_handle1, (FB_API_HANDLE*) &local_trans, (short) 0, (short) 156, &isc_386, (short) 0);
		   };
		/*ON_ERROR*/
		if (isc_status [1])
		   {
			general_on_error ();
		/*END_ERROR;*/
		   }
		}
	}
	else
	{
		/*STORE (TRANSACTION_HANDLE local_trans
				REQUEST_HANDLE tdgbl->handles_get_procedure_req_handle1)
			X IN RDB$PROCEDURES*/
		{
		
                if (!tdgbl->handles_get_procedure_req_handle1)
                   isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &tdgbl->handles_get_procedure_req_handle1, (short) sizeof(isc_368), (char*) isc_368);
		if (tdgbl->handles_get_procedure_req_handle1)
		   {
		   isc_369.isc_370 = isc_blob_null;
		   isc_369.isc_374 = isc_blob_null;
		   isc_369.isc_375 = isc_blob_null;
			/*X.RDB$PROCEDURE_SOURCE.NULL*/
			isc_369.isc_384 = TRUE;
			/*X.RDB$DESCRIPTION.NULL*/
			isc_369.isc_383 = TRUE;
			/*X.RDB$SECURITY_CLASS.NULL*/
			isc_369.isc_382 = TRUE;
			/*X.RDB$OWNER_NAME.NULL*/
			isc_369.isc_381 = TRUE;
			/*X.RDB$SYSTEM_FLAG*/
			isc_369.isc_380 = 0;
			/*X.RDB$SYSTEM_FLAG.NULL*/
			isc_369.isc_379 = FALSE;

			skip_init(&scan_next_attr);
			while (skip_scan(&scan_next_attr), get_attribute(&attribute, tdgbl) != att_end)
			{
				switch (attribute)
				{
				case att_procedure_name:
					l = GET_TEXT(/*X.RDB$PROCEDURE_NAME*/
						     isc_369.isc_371);
					//procedure->prc_name_length = l;
					strcpy (procedure->prc_name, /*X.RDB$PROCEDURE_NAME*/
								     isc_369.isc_371);
					MISC_terminate (/*X.RDB$PROCEDURE_NAME*/
							isc_369.isc_371, temp, l, sizeof(temp));
					BURP_verbose (195, temp);
					// msg 195 restoring stored procedure %s
					break;

				case att_procedure_description:
					get_misc_blob (tdgbl, /*X.RDB$DESCRIPTION*/
							      isc_369.isc_374, true);
					/*X.RDB$DESCRIPTION.NULL*/
					isc_369.isc_383 = FALSE;
					break;

				case att_procedure_description2:
					get_source_blob (tdgbl, /*X.RDB$DESCRIPTION*/
								isc_369.isc_374, true);
					/*X.RDB$DESCRIPTION.NULL*/
					isc_369.isc_383 = FALSE;
					break;

				case att_procedure_source:
					get_misc_blob (tdgbl, /*X.RDB$PROCEDURE_SOURCE*/
							      isc_369.isc_375, true);
					/*X.RDB$PROCEDURE_SOURCE.NULL*/
					isc_369.isc_384 = FALSE;
					break;

				case att_procedure_source2:
					get_source_blob (tdgbl, /*X.RDB$PROCEDURE_SOURCE*/
								isc_369.isc_375, true);
					/*X.RDB$PROCEDURE_SOURCE.NULL*/
					isc_369.isc_384 = FALSE;
					break;

				case att_procedure_blr:
					get_blr_blob (tdgbl, /*X.RDB$PROCEDURE_BLR*/
							     isc_369.isc_370, true);
					break;

				case att_procedure_security_class:
					GET_TEXT(/*X.RDB$SECURITY_CLASS*/
						 isc_369.isc_373);
					fix_security_class_name(tdgbl, /*X.RDB$SECURITY_CLASS*/
								       isc_369.isc_373, false);
					/*X.RDB$SECURITY_CLASS.NULL*/
					isc_369.isc_382 = FALSE;
					break;

				case att_procedure_owner_name:
					GET_TEXT(procedure->prc_owner);
					break;

				case att_procedure_inputs:
					/*X.RDB$PROCEDURE_INPUTS*/
					isc_369.isc_378 = (USHORT) get_numeric(tdgbl);
					if (/*X.RDB$PROCEDURE_INPUTS*/
					    isc_369.isc_378 == 0)
						/*X.RDB$PROCEDURE_INPUTS.NULL*/
						isc_369.isc_377 = TRUE;
					else
						/*X.RDB$PROCEDURE_INPUTS.NULL*/
						isc_369.isc_377 = FALSE;
					break;

				case att_procedure_outputs:
					/*X.RDB$PROCEDURE_OUTPUTS*/
					isc_369.isc_376 = (USHORT) get_numeric(tdgbl);
					break;

				case att_procedure_type:
					if (tdgbl->RESTORE_format >= 8)
						get_numeric(tdgbl);
					else
						bad_attribute (scan_next_attr, attribute, 290);
					break;

				default:
					bad_attribute (scan_next_attr, attribute, 290);
					// msg 290 procedure
					break;
				}
			}
			strcpy (procedure_name, /*X.RDB$PROCEDURE_NAME*/
						isc_369.isc_371);
		/*END_STORE;*/
		   
                   isc_start_and_send (isc_status, (FB_API_HANDLE*) &tdgbl->handles_get_procedure_req_handle1, (FB_API_HANDLE*) &local_trans, (short) 0, (short) 138, &isc_369, (short) 0);
		   };
		/*ON_ERROR*/
		if (isc_status [1])
		   {
			general_on_error ();
		/*END_ERROR;*/
		   }
		}
	}

	// at the end of prms for a procedure is the rec_procedure_end marker

	while (get(tdgbl) == rec_procedure_prm)
		get_procedure_prm (tdgbl, procedure_name);

	return true;
}

bool get_procedure_prm (BurpGlobals* tdgbl, GDS_NAME procptr)
{
   struct isc_333_struct {
          char  isc_334 [32];	/* RDB$FIELD_SOURCE */
          char  isc_335 [32];	/* RDB$PARAMETER_NAME */
          char  isc_336 [32];	/* RDB$PROCEDURE_NAME */
          ISC_QUAD isc_337;	/* RDB$DESCRIPTION */
          short isc_338;	/* RDB$PARAMETER_NUMBER */
          short isc_339;	/* RDB$PARAMETER_TYPE */
          short isc_340;	/* gds__null_flag */
          short isc_341;	/* RDB$SYSTEM_FLAG */
          short isc_342;	/* gds__null_flag */
   } isc_333;
   struct isc_344_struct {
          char  isc_345 [32];	/* RDB$FIELD_SOURCE */
          char  isc_346 [32];	/* RDB$PARAMETER_NAME */
          char  isc_347 [32];	/* RDB$RELATION_NAME */
          char  isc_348 [32];	/* RDB$FIELD_NAME */
          ISC_QUAD isc_349;	/* RDB$DEFAULT_SOURCE */
          ISC_QUAD isc_350;	/* RDB$DEFAULT_VALUE */
          ISC_QUAD isc_351;	/* RDB$DESCRIPTION */
          char  isc_352 [32];	/* RDB$PROCEDURE_NAME */
          short isc_353;	/* RDB$PARAMETER_NUMBER */
          short isc_354;	/* RDB$PARAMETER_TYPE */
          short isc_355;	/* gds__null_flag */
          short isc_356;	/* gds__null_flag */
          short isc_357;	/* gds__null_flag */
          short isc_358;	/* RDB$PARAMETER_MECHANISM */
          short isc_359;	/* gds__null_flag */
          short isc_360;	/* RDB$NULL_FLAG */
          short isc_361;	/* gds__null_flag */
          short isc_362;	/* RDB$SYSTEM_FLAG */
          short isc_363;	/* gds__null_flag */
          short isc_364;	/* RDB$COLLATION_ID */
          short isc_365;	/* gds__null_flag */
          short isc_366;	/* gds__null_flag */
          short isc_367;	/* gds__null_flag */
   } isc_344;
/**************************************
 *
 *	g e t _ p r o c e d u r e _ p r m
 *
 **************************************
 *
 * Functional description
 *	Reconstruct stored procedure parameter.
 *	Use the global_trans so we don't have to commit
 *	until after the indices are activated.  This
 *	will allow us to use a PLAN in a SP.
 *
 **************************************/
	att_type	attribute;
	SSHORT		l;
	TEXT		temp[GDS_NAME_LEN];
	scan_attr_t		scan_next_attr;

	isc_tr_handle local_trans = tdgbl->global_trans ? tdgbl->global_trans : gds_trans;

	if (tdgbl->RESTORE_ods >= DB_VERSION_DDL11_1)
	{
		/*STORE (TRANSACTION_HANDLE local_trans
				REQUEST_HANDLE tdgbl->handles_get_procedure_prm_req_handle1)
			X IN RDB$PROCEDURE_PARAMETERS*/
		{
		
                if (!tdgbl->handles_get_procedure_prm_req_handle1)
                   isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &tdgbl->handles_get_procedure_prm_req_handle1, (short) sizeof(isc_343), (char*) isc_343);
		if (tdgbl->handles_get_procedure_prm_req_handle1)
		   {
		   isc_344.isc_349 = isc_blob_null;
		   isc_344.isc_350 = isc_blob_null;
		   isc_344.isc_351 = isc_blob_null;

			strcpy(/*X.RDB$PROCEDURE_NAME*/
			       isc_344.isc_352, procptr);

			/*X.RDB$DESCRIPTION.NULL*/
			isc_344.isc_367 = TRUE;
			/*X.RDB$DEFAULT_VALUE.NULL*/
			isc_344.isc_366 = TRUE;
			/*X.RDB$DEFAULT_SOURCE.NULL*/
			isc_344.isc_365 = TRUE;
			/*X.RDB$COLLATION_ID.NULL*/
			isc_344.isc_363 = TRUE;

			/*X.RDB$SYSTEM_FLAG*/
			isc_344.isc_362 = 0;
			/*X.RDB$SYSTEM_FLAG.NULL*/
			isc_344.isc_361 = FALSE;

			/*X.RDB$NULL_FLAG*/
			isc_344.isc_360 = FALSE;
			/*X.RDB$NULL_FLAG.NULL*/
			isc_344.isc_359 = FALSE;

			/*X.RDB$PARAMETER_MECHANISM*/
			isc_344.isc_358 = prm_mech_normal;
			/*X.RDB$PARAMETER_MECHANISM.NULL*/
			isc_344.isc_357 = FALSE;

			// DB_VERSION_DDL11_2
			/*X.RDB$FIELD_NAME.NULL*/
			isc_344.isc_356 = TRUE;
			/*X.RDB$RELATION_NAME.NULL*/
			isc_344.isc_355 = TRUE;

			skip_init(&scan_next_attr);
			while (skip_scan(&scan_next_attr), get_attribute(&attribute, tdgbl) != att_end)
			{
				switch (attribute)
				{
				case att_procedureprm_name:
					l = GET_TEXT(/*X.RDB$PARAMETER_NAME*/
						     isc_344.isc_346);
					MISC_terminate (/*X.RDB$PARAMETER_NAME*/
							isc_344.isc_346, temp, l, sizeof(temp));
					BURP_verbose (196, temp);
					// msg 196 restoring parameter %s for stored procedure
					break;

				case att_procedureprm_type:
					/*X.RDB$PARAMETER_TYPE*/
					isc_344.isc_354= (USHORT) get_numeric(tdgbl);
					break;

				case att_procedureprm_number:
					/*X.RDB$PARAMETER_NUMBER*/
					isc_344.isc_353= (USHORT) get_numeric(tdgbl);
					break;

				case att_procedureprm_field_source:
					GET_TEXT(/*X.RDB$FIELD_SOURCE*/
						 isc_344.isc_345);
					break;

				case att_procedureprm_description:
					get_misc_blob (tdgbl, /*X.RDB$DESCRIPTION*/
							      isc_344.isc_351, true);
					/*X.RDB$DESCRIPTION.NULL*/
					isc_344.isc_367 = FALSE;
					break;

				case att_procedureprm_description2:
					get_source_blob (tdgbl, /*X.RDB$DESCRIPTION*/
								isc_344.isc_351, true);
					/*X.RDB$DESCRIPTION.NULL*/
					isc_344.isc_367 = FALSE;
					break;

				case att_procedureprm_default_value:
					if (tdgbl->RESTORE_format >= 8)
					{
						/*X.RDB$DEFAULT_VALUE.NULL*/
						isc_344.isc_366 = FALSE;
						get_blr_blob (tdgbl, /*X.RDB$DEFAULT_VALUE*/
								     isc_344.isc_350, true);
					}
					else
						bad_attribute (scan_next_attr, attribute, 291);
					break;

				case att_procedureprm_default_source:
					if (tdgbl->RESTORE_format >= 8)
					{
						/*X.RDB$DEFAULT_SOURCE.NULL*/
						isc_344.isc_365 = FALSE;
						get_source_blob (tdgbl, /*X.RDB$DEFAULT_SOURCE*/
									isc_344.isc_349, true);
					}
					else
						bad_attribute (scan_next_attr, attribute, 291);
					break;

				case att_procedureprm_collation_id:
					if (tdgbl->RESTORE_format >= 8)
					{
						/*X.RDB$COLLATION_ID.NULL*/
						isc_344.isc_363 = FALSE;
						/*X.RDB$COLLATION_ID*/
						isc_344.isc_364 = (USHORT) get_numeric(tdgbl);
					}
					else
						bad_attribute (scan_next_attr, attribute, 291);
					break;

				case att_procedureprm_null_flag:
					if (tdgbl->RESTORE_format >= 8)
						/*X.RDB$NULL_FLAG*/
						isc_344.isc_360 = (USHORT) get_numeric(tdgbl);
					else
						bad_attribute (scan_next_attr, attribute, 291);
					break;

				case att_procedureprm_mechanism:
					if (tdgbl->RESTORE_format >= 8)
						/*X.RDB$PARAMETER_MECHANISM*/
						isc_344.isc_358 = (USHORT) get_numeric(tdgbl);
					else
						bad_attribute (scan_next_attr, attribute, 291);
					break;

				// DB_VERSION_DDL11_2
				case att_procedureprm_field_name:
					/*X.RDB$FIELD_NAME.NULL*/
					isc_344.isc_356 = FALSE;
					GET_TEXT(/*X.RDB$FIELD_NAME*/
						 isc_344.isc_348);
					break;

				// DB_VERSION_DDL11_2
				case att_procedureprm_relation_name:
					/*X.RDB$RELATION_NAME.NULL*/
					isc_344.isc_355 = FALSE;
					GET_TEXT(/*X.RDB$RELATION_NAME*/
						 isc_344.isc_347);
					break;

				default:
					bad_attribute (scan_next_attr, attribute, 291);
					// msg 291 procedure parameter
					break;
				}
			}
		/*END_STORE;*/
		   
                   isc_start_and_send (isc_status, (FB_API_HANDLE*) &tdgbl->handles_get_procedure_prm_req_handle1, (FB_API_HANDLE*) &local_trans, (short) 0, (short) 214, &isc_344, (short) 0);
		   };
		/*ON_ERROR*/
		if (isc_status [1])
		   {
			general_on_error ();
		/*END_ERROR;*/
		   }
		}
	}
	else
	{
		/*STORE (TRANSACTION_HANDLE local_trans
				REQUEST_HANDLE tdgbl->handles_get_procedure_prm_req_handle1)
			X IN RDB$PROCEDURE_PARAMETERS*/
		{
		
                if (!tdgbl->handles_get_procedure_prm_req_handle1)
                   isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &tdgbl->handles_get_procedure_prm_req_handle1, (short) sizeof(isc_332), (char*) isc_332);
		if (tdgbl->handles_get_procedure_prm_req_handle1)
		   {
		   isc_333.isc_337 = isc_blob_null;
			/*X.RDB$DESCRIPTION.NULL*/
			isc_333.isc_342 = TRUE;
			strcpy (/*X.RDB$PROCEDURE_NAME*/
				isc_333.isc_336, procptr);
			/*X.RDB$SYSTEM_FLAG*/
			isc_333.isc_341 = 0;
			/*X.RDB$SYSTEM_FLAG.NULL*/
			isc_333.isc_340 = FALSE;

			skip_init(&scan_next_attr);
			while (skip_scan(&scan_next_attr), get_attribute(&attribute, tdgbl) != att_end)
			{
				switch (attribute)
				{
				case att_procedureprm_name:
					l = GET_TEXT(/*X.RDB$PARAMETER_NAME*/
						     isc_333.isc_335);
					MISC_terminate (/*X.RDB$PARAMETER_NAME*/
							isc_333.isc_335, temp, l, sizeof(temp));
					BURP_verbose (196, temp);
					// msg 196 restoring parameter %s for stored procedure
					break;

				case att_procedureprm_type:
					/*X.RDB$PARAMETER_TYPE*/
					isc_333.isc_339= (USHORT) get_numeric(tdgbl);
					break;

				case att_procedureprm_number:
					/*X.RDB$PARAMETER_NUMBER*/
					isc_333.isc_338= (USHORT) get_numeric(tdgbl);
					break;

				case att_procedureprm_field_source:
					GET_TEXT(/*X.RDB$FIELD_SOURCE*/
						 isc_333.isc_334);
					break;

				case att_procedureprm_description:
					get_misc_blob (tdgbl, /*X.RDB$DESCRIPTION*/
							      isc_333.isc_337, true);
					/*X.RDB$DESCRIPTION.NULL*/
					isc_333.isc_342 = FALSE;
					break;

				case att_procedureprm_description2:
					get_source_blob (tdgbl, /*X.RDB$DESCRIPTION*/
								isc_333.isc_337, true);
					/*X.RDB$DESCRIPTION.NULL*/
					isc_333.isc_342 = FALSE;
					break;

				default:
					bad_attribute (scan_next_attr, attribute, 291);
					// msg 291 procedure parameter
					break;
				}
			}
		/*END_STORE;*/
		   
                   isc_start_and_send (isc_status, (FB_API_HANDLE*) &tdgbl->handles_get_procedure_prm_req_handle1, (FB_API_HANDLE*) &local_trans, (short) 0, (short) 114, &isc_333, (short) 0);
		   };
		/*ON_ERROR*/
		if (isc_status [1])
		   {
			general_on_error ();
		/*END_ERROR;*/
		   }
		}
	}

	return true;
}

bool get_ref_constraint(BurpGlobals* tdgbl)
{
   struct isc_321_struct {
          char  isc_322 [8];	/* RDB$MATCH_OPTION */
          char  isc_323 [32];	/* RDB$CONST_NAME_UQ */
          char  isc_324 [32];	/* RDB$CONSTRAINT_NAME */
          char  isc_325 [12];	/* RDB$DELETE_RULE */
          char  isc_326 [12];	/* RDB$UPDATE_RULE */
          short isc_327;	/* gds__null_flag */
          short isc_328;	/* gds__null_flag */
          short isc_329;	/* gds__null_flag */
          short isc_330;	/* gds__null_flag */
          short isc_331;	/* gds__null_flag */
   } isc_321;
/**************************************
 *
 *	g e t _ r e f _ c o n s t r a i n t
 *
 **************************************
 *
 * Functional description
 *	Restore data for referential constraints.
 *
 **************************************/
	att_type        attribute;
	scan_attr_t		scan_next_attr;

	/*STORE (REQUEST_HANDLE tdgbl->handles_get_ref_constraint_req_handle1)
		X IN RDB$REF_CONSTRAINTS*/
	{
	
        if (!tdgbl->handles_get_ref_constraint_req_handle1)
           isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &tdgbl->handles_get_ref_constraint_req_handle1, (short) sizeof(isc_320), (char*) isc_320);
	if (tdgbl->handles_get_ref_constraint_req_handle1)
	   {
		/*X.RDB$CONSTRAINT_NAME.NULL*/
		isc_321.isc_331 = TRUE;
		/*X.RDB$CONST_NAME_UQ.NULL*/
		isc_321.isc_330 = TRUE;
		/*X.RDB$MATCH_OPTION.NULL*/
		isc_321.isc_329 = TRUE;
		/*X.RDB$UPDATE_RULE.NULL*/
		isc_321.isc_328 = TRUE;
		/*X.RDB$DELETE_RULE.NULL*/
		isc_321.isc_327 = TRUE;

		skip_init(&scan_next_attr);
		while (skip_scan(&scan_next_attr), get_attribute(&attribute, tdgbl) != att_end)
		{
			switch (attribute)
			{
				case att_ref_constraint_name:
					/*X.RDB$CONSTRAINT_NAME.NULL*/
					isc_321.isc_331 = FALSE;
					GET_TEXT(/*X.RDB$CONSTRAINT_NAME*/
						 isc_321.isc_324);
					break;

				case att_ref_unique_const_name:
					/*X.RDB$CONST_NAME_UQ.NULL*/
					isc_321.isc_330 = FALSE;
					GET_TEXT(/*X.RDB$CONST_NAME_UQ*/
						 isc_321.isc_323);
					break;

				case att_ref_match_option:
					/*X.RDB$MATCH_OPTION.NULL*/
					isc_321.isc_329 = FALSE;
					GET_TEXT(/*X.RDB$MATCH_OPTION*/
						 isc_321.isc_322);
					break;

				case att_ref_update_rule:
					/*X.RDB$UPDATE_RULE.NULL*/
					isc_321.isc_328 = FALSE;
					GET_TEXT(/*X.RDB$UPDATE_RULE*/
						 isc_321.isc_326);
					break;

				case att_ref_delete_rule:
					/*X.RDB$DELETE_RULE.NULL*/
					isc_321.isc_327 = FALSE;
					GET_TEXT(/*X.RDB$DELETE_RULE*/
						 isc_321.isc_325);
					break;

				default:
					bad_attribute (scan_next_attr, attribute, 292);
					// msg 292 referential constraint
					break;
			}
		}
	/*END_STORE;*/
	   
           isc_start_and_send (isc_status, (FB_API_HANDLE*) &tdgbl->handles_get_ref_constraint_req_handle1, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 106, &isc_321, (short) 0);
	   };
	/*ON_ERROR*/
	if (isc_status [1])
	   {
		general_on_error ();
	/*END_ERROR;*/
	   }
	}

	return true;
}

bool get_relation(BurpGlobals* tdgbl)
{
   struct isc_277_struct {
          char  isc_278 [32];	/* RDB$RELATION_NAME */
          char  isc_279 [256];	/* RDB$EXTERNAL_FILE */
          ISC_QUAD isc_280;	/* RDB$EXTERNAL_DESCRIPTION */
          ISC_QUAD isc_281;	/* RDB$RUNTIME */
          ISC_QUAD isc_282;	/* RDB$DESCRIPTION */
          ISC_QUAD isc_283;	/* RDB$VIEW_SOURCE */
          ISC_QUAD isc_284;	/* RDB$VIEW_BLR */
          char  isc_285 [32];	/* RDB$SECURITY_CLASS */
          short isc_286;	/* gds__null_flag */
          short isc_287;	/* gds__null_flag */
          short isc_288;	/* gds__null_flag */
          short isc_289;	/* gds__null_flag */
          short isc_290;	/* gds__null_flag */
          short isc_291;	/* gds__null_flag */
          short isc_292;	/* gds__null_flag */
          short isc_293;	/* gds__null_flag */
          short isc_294;	/* RDB$FLAGS */
          short isc_295;	/* gds__null_flag */
          short isc_296;	/* RDB$SYSTEM_FLAG */
   } isc_277;
   struct isc_298_struct {
          char  isc_299 [32];	/* RDB$RELATION_NAME */
          char  isc_300 [256];	/* RDB$EXTERNAL_FILE */
          ISC_QUAD isc_301;	/* RDB$EXTERNAL_DESCRIPTION */
          ISC_QUAD isc_302;	/* RDB$RUNTIME */
          ISC_QUAD isc_303;	/* RDB$DESCRIPTION */
          ISC_QUAD isc_304;	/* RDB$VIEW_SOURCE */
          ISC_QUAD isc_305;	/* RDB$VIEW_BLR */
          char  isc_306 [32];	/* RDB$SECURITY_CLASS */
          short isc_307;	/* gds__null_flag */
          short isc_308;	/* RDB$RELATION_TYPE */
          short isc_309;	/* gds__null_flag */
          short isc_310;	/* gds__null_flag */
          short isc_311;	/* gds__null_flag */
          short isc_312;	/* gds__null_flag */
          short isc_313;	/* gds__null_flag */
          short isc_314;	/* gds__null_flag */
          short isc_315;	/* gds__null_flag */
          short isc_316;	/* gds__null_flag */
          short isc_317;	/* RDB$FLAGS */
          short isc_318;	/* gds__null_flag */
          short isc_319;	/* RDB$SYSTEM_FLAG */
   } isc_298;
/**************************************
 *
 *	g e t _ r e l a t i o n
 *
 **************************************
 *
 * Functional description
 *	Write relation meta-data and data.
 *	Use the default transaction for RELATIONS,
 *	and use the global_trans for VIEWS.  This
 *	enables us to have views of SP and views
 *	with plans.  Assume it is a view if it has
 *	RDB$VIEW_BLR, also assume RDB$VIEW_BLR is
 *	the first blob in the backup file.
 *
 *
 **************************************/
	TEXT		temp[GDS_NAME_LEN];
	SSHORT		l;

	SLONG		rel_flags = 0, sys_flag = 0, type = 0;
	bool		rel_flags_null = true, type_null = true;
	ISC_QUAD	view_blr = isc_blob_null, view_src = isc_blob_null,
				rel_desc = isc_blob_null, ext_desc = isc_blob_null;
	bool		view_blr_null = true, view_src_null = true, rel_desc_null = true,
				ext_desc_null = true;

	/*BASED_ON RDB$RELATIONS.RDB$SECURITY_CLASS sec_class;*/
	char
	   sec_class[32];

	sec_class[0] = '\0';
	bool		sec_class_null = true;

	/*BASED_ON RDB$RELATIONS.RDB$EXTERNAL_FILE ext_file_name;*/
	char
	   ext_file_name[256];

	ext_file_name[0] = '\0';
	bool		ext_file_name_null = true;

	// Pick up relation attributes

	burp_rel* relation = (burp_rel*) BURP_alloc_zero (sizeof(burp_rel));
	relation->rel_next = tdgbl->relations;
	tdgbl->relations = relation;

	/*
	STORE (REQUEST_HANDLE tdgbl->handles_get_relation_req_handle1)
		X IN RDB$RELATIONS
		X.RDB$SYSTEM_FLAG = 0;
		X.RDB$SYSTEM_FLAG.NULL = FALSE;
		X.RDB$FLAGS.NULL = TRUE;
		X.RDB$SECURITY_CLASS.NULL = TRUE;
		X.RDB$VIEW_BLR.NULL = TRUE;
		X.RDB$VIEW_SOURCE.NULL = TRUE;
		X.RDB$DESCRIPTION.NULL = TRUE;
		X.RDB$RUNTIME.NULL = TRUE;
		X.RDB$EXTERNAL_DESCRIPTION.NULL = TRUE;
	*/

	att_type attribute;
	scan_attr_t scan_next_attr;
	skip_init(&scan_next_attr);

	while (skip_scan(&scan_next_attr), get_attribute(&attribute, tdgbl) != att_end)
	{
		switch (attribute)
		{
		case att_relation_name:
			l = GET_TEXT(relation->rel_name);
			relation->rel_name_length = l;
			MISC_terminate (relation->rel_name, temp, l, sizeof(temp));
			BURP_verbose (167, temp);
			// msg 167 restoring relation %s
			break;

		case att_relation_security_class:
			sec_class_null = false;
			GET_TEXT(sec_class);
			fix_security_class_name(tdgbl, sec_class, false);
			break;

		case att_relation_view_blr:
			view_blr_null = false;
			get_blr_blob(tdgbl, view_blr, true);
			relation->rel_flags |= REL_view;
			break;

		case att_relation_view_source:
			view_src_null = false;
			get_misc_blob (tdgbl, view_src, !view_blr_null);
			break;

		case att_relation_view_source2:
			view_src_null = false;
			get_source_blob(tdgbl, view_src, !view_blr_null);
			break;

		case att_relation_description:
			rel_desc_null = false;
			get_misc_blob(tdgbl, rel_desc, !view_blr_null);
			break;

		case att_relation_description2:
			rel_desc_null = false;
			get_source_blob(tdgbl, rel_desc, !view_blr_null);
			break;

		case att_relation_flags:
			rel_flags_null = false;
			rel_flags = get_numeric(tdgbl);
			break;

		case att_relation_system_flag:
			sys_flag = get_numeric(tdgbl);
			break;

		case att_relation_ext_description:
			ext_desc_null = false;
			get_misc_blob(tdgbl, ext_desc, !view_blr_null);
			break;

		case att_relation_ext_description2:
			ext_desc_null = false;
			get_source_blob(tdgbl, ext_desc, !view_blr_null);
			break;

		case att_relation_owner_name:
			GET_TEXT(relation->rel_owner);
			break;

		case att_relation_ext_file_name:
			ext_file_name_null = false;
			GET_TEXT(ext_file_name);
			break;

		case att_relation_type:
			if (tdgbl->RESTORE_format >= 8)
			{
				type_null = false;
				type = get_numeric(tdgbl);
			}
			else
				bad_attribute(scan_next_attr, attribute, 111);
			break;

		default:
			bad_attribute (scan_next_attr, attribute, 111);
			// msg 111 table
			break;
		}
	}

	// If this is a view and there is a global transaction then use it
	isc_tr_handle local_trans;
	if (view_blr_null || !tdgbl->global_trans)
		local_trans = gds_trans;
	else
		local_trans = tdgbl->global_trans;

	if (tdgbl->RESTORE_ods >= DB_VERSION_DDL11_1)
	{
		/*STORE (TRANSACTION_HANDLE local_trans
				REQUEST_HANDLE tdgbl->handles_get_relation_req_handle1)
			X IN RDB$RELATIONS*/
		{
		
                if (!tdgbl->handles_get_relation_req_handle1)
                   isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &tdgbl->handles_get_relation_req_handle1, (short) sizeof(isc_297), (char*) isc_297);
		if (tdgbl->handles_get_relation_req_handle1)
		   {
		   isc_298.isc_301 = isc_blob_null;
		   isc_298.isc_302 = isc_blob_null;
		   isc_298.isc_303 = isc_blob_null;
		   isc_298.isc_304 = isc_blob_null;
		   isc_298.isc_305 = isc_blob_null;

			/*X.RDB$SYSTEM_FLAG.NULL*/
			isc_298.isc_318 = FALSE;
			/*X.RDB$FLAGS.NULL*/
			isc_298.isc_316 = rel_flags_null;
			/*X.RDB$SECURITY_CLASS.NULL*/
			isc_298.isc_315 = sec_class_null;
			/*X.RDB$VIEW_BLR.NULL*/
			isc_298.isc_314 = view_blr_null;
			/*X.RDB$VIEW_SOURCE.NULL*/
			isc_298.isc_313 = view_src_null;
			/*X.RDB$DESCRIPTION.NULL*/
			isc_298.isc_312 = rel_desc_null;
			/*X.RDB$RUNTIME.NULL*/
			isc_298.isc_311 = TRUE;
			/*X.RDB$EXTERNAL_DESCRIPTION.NULL*/
			isc_298.isc_310 = ext_desc_null;
			/*X.RDB$EXTERNAL_FILE.NULL*/
			isc_298.isc_309 = ext_file_name_null;
			/*X.RDB$RELATION_TYPE.NULL*/
			isc_298.isc_307 = type_null;

			/*X.RDB$SYSTEM_FLAG*/
			isc_298.isc_319 = (USHORT) sys_flag;
			/*X.RDB$FLAGS*/
			isc_298.isc_317 = (USHORT) rel_flags;
			/*X.RDB$VIEW_BLR*/
			isc_298.isc_305 = view_blr;
			/*X.RDB$VIEW_SOURCE*/
			isc_298.isc_304 = view_src;
			/*X.RDB$DESCRIPTION*/
			isc_298.isc_303 = rel_desc;
			/*X.RDB$EXTERNAL_DESCRIPTION*/
			isc_298.isc_301 = ext_desc;

			strcpy(/*X.RDB$SECURITY_CLASS*/
			       isc_298.isc_306, sec_class);
			strcpy(/*X.RDB$RELATION_NAME*/
			       isc_298.isc_299, relation->rel_name);
			strcpy(/*X.RDB$EXTERNAL_FILE*/
			       isc_298.isc_300, ext_file_name);

			/*X.RDB$RELATION_TYPE*/
			isc_298.isc_308 = (USHORT) type;

		/*END_STORE;*/
		   
                   isc_start_and_send (isc_status, (FB_API_HANDLE*) &tdgbl->handles_get_relation_req_handle1, (FB_API_HANDLE*) &local_trans, (short) 0, (short) 386, &isc_298, (short) 0);
		   };
		/*ON_ERROR*/
		if (isc_status [1])
		   {
			general_on_error ();
		/*END_ERROR;*/
		   }
		}
	}
	else
	{
		/*STORE (TRANSACTION_HANDLE local_trans
				REQUEST_HANDLE tdgbl->handles_get_relation_req_handle1)
			X IN RDB$RELATIONS*/
		{
		
                if (!tdgbl->handles_get_relation_req_handle1)
                   isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &tdgbl->handles_get_relation_req_handle1, (short) sizeof(isc_276), (char*) isc_276);
		if (tdgbl->handles_get_relation_req_handle1)
		   {
		   isc_277.isc_280 = isc_blob_null;
		   isc_277.isc_281 = isc_blob_null;
		   isc_277.isc_282 = isc_blob_null;
		   isc_277.isc_283 = isc_blob_null;
		   isc_277.isc_284 = isc_blob_null;

			/*X.RDB$SYSTEM_FLAG.NULL*/
			isc_277.isc_295 = FALSE;
			/*X.RDB$FLAGS.NULL*/
			isc_277.isc_293 = rel_flags_null;
			/*X.RDB$SECURITY_CLASS.NULL*/
			isc_277.isc_292 = sec_class_null;
			/*X.RDB$VIEW_BLR.NULL*/
			isc_277.isc_291 = view_blr_null;
			/*X.RDB$VIEW_SOURCE.NULL*/
			isc_277.isc_290 = view_src_null;
			/*X.RDB$DESCRIPTION.NULL*/
			isc_277.isc_289 = rel_desc_null;
			/*X.RDB$RUNTIME.NULL*/
			isc_277.isc_288 = TRUE;
			/*X.RDB$EXTERNAL_DESCRIPTION.NULL*/
			isc_277.isc_287 = ext_desc_null;
			/*X.RDB$EXTERNAL_FILE.NULL*/
			isc_277.isc_286 = ext_file_name_null;

			/*X.RDB$SYSTEM_FLAG*/
			isc_277.isc_296 = (USHORT) sys_flag;
			/*X.RDB$FLAGS*/
			isc_277.isc_294 = (USHORT) rel_flags;
			/*X.RDB$VIEW_BLR*/
			isc_277.isc_284 = view_blr;
			/*X.RDB$VIEW_SOURCE*/
			isc_277.isc_283 = view_src;
			/*X.RDB$DESCRIPTION*/
			isc_277.isc_282 = rel_desc;
			/*X.RDB$EXTERNAL_DESCRIPTION*/
			isc_277.isc_280 = ext_desc;

			strcpy(/*X.RDB$SECURITY_CLASS*/
			       isc_277.isc_285, sec_class);
			strcpy(/*X.RDB$RELATION_NAME*/
			       isc_277.isc_278, relation->rel_name);
			strcpy(/*X.RDB$EXTERNAL_FILE*/
			       isc_277.isc_279, ext_file_name);

		/*END_STORE;*/
		   
                   isc_start_and_send (isc_status, (FB_API_HANDLE*) &tdgbl->handles_get_relation_req_handle1, (FB_API_HANDLE*) &local_trans, (short) 0, (short) 382, &isc_277, (short) 0);
		   };
		/*ON_ERROR*/
		if (isc_status [1])
		   {
			general_on_error ();
		/*END_ERROR;*/
		   }
		}
	}

	// Eat up misc. records
	burp_fld* field = NULL;
	burp_fld** ptr = &relation->rel_fields;

	rec_type record;
	while (get_record(&record, tdgbl) != rec_data)
	{
		switch (record)
		{
		case rec_relation_end:
			if (tdgbl->gbl_sw_incremental)
			{
				BURP_verbose (170, relation->rel_name);
				// msg 170: committing metadata for relation %s
				/*COMMIT*/
				{
				isc_commit_transaction (isc_status, (FB_API_HANDLE*) &gds_trans);;
				// existing ON_ERROR continues past error, beck
				/*ON_ERROR*/
				if (isc_status [1])
				   {
					BURP_print (false, 171, relation->rel_name);
					// msg 171: error committing metadata for relation %s
					BURP_print_status (false, tdgbl->status_vector);
					/*ROLLBACK;*/
					{
					isc_rollback_transaction (isc_status, (FB_API_HANDLE*) &gds_trans);;
					/*ON_ERROR*/
					if (isc_status [1])
					   {
						general_on_error ();
					/*END_ERROR;*/
					   }
					}
				/*END_ERROR;*/
				   }
				}
				/*EXEC SQL SET TRANSACTION NO_AUTO_UNDO;*/
				{
				isc_start_transaction (isc_status, (FB_API_HANDLE*) &gds_trans, (short) 1, &DB, (short) 5, isc_tpb_11);
				SQLCODE = isc_sqlcode(isc_status);
				}
				if (gds_status[1])
					/*EXEC SQL SET TRANSACTION;*/
					{
					isc_start_transaction (isc_status, (FB_API_HANDLE*) &gds_trans, (short) 1, &DB, (short) 4, isc_tpb_12);
					SQLCODE = isc_sqlcode(isc_status);
					}
			}
			return true;

		case rec_field:
			*ptr = field = get_field (tdgbl, relation);
			if (!field)
				return false;
			ptr = &field->fld_next;
			break;

		case rec_view:
			get_view(tdgbl, relation);
			break;

		default:
			BURP_error(43, true, SafeArg() << record);
			// msg 43 don't recognize record type %ld
			break;
		}
	}

	// If we fall thru, there are data records to be gotten
	// we can get here only when restoring ancient gbak'ed files where rec_data
	// was once embedded into rec_relation ... otherwise, meta commit happens
	// when we see the first rec_relation_data

	BURP_verbose (68);
	// msg 68 committing meta data

	/*COMMIT;*/
	{
	isc_commit_transaction (isc_status, (FB_API_HANDLE*) &gds_trans);;
	/*ON_ERROR*/
	if (isc_status [1])
	   {
		general_on_error ();
	/*END_ERROR;*/
	   }
	}

	/*EXEC SQL SET TRANSACTION NO_AUTO_UNDO;*/
	{
	isc_start_transaction (isc_status, (FB_API_HANDLE*) &gds_trans, (short) 1, &DB, (short) 5, isc_tpb_13);
	SQLCODE = isc_sqlcode(isc_status);
	}
	if (gds_status[1])
		/*EXEC SQL SET TRANSACTION;*/
		{
		isc_start_transaction (isc_status, (FB_API_HANDLE*) &gds_trans, (short) 1, &DB, (short) 4, isc_tpb_14);
		SQLCODE = isc_sqlcode(isc_status);
		}

	get_data(tdgbl, relation);

	return true;
}

bool get_rel_constraint(BurpGlobals* tdgbl)
{
   struct isc_263_struct {
          char  isc_264 [32];	/* RDB$INDEX_NAME */
          char  isc_265 [32];	/* RDB$RELATION_NAME */
          char  isc_266 [32];	/* RDB$CONSTRAINT_NAME */
          char  isc_267 [4];	/* RDB$INITIALLY_DEFERRED */
          char  isc_268 [4];	/* RDB$DEFERRABLE */
          char  isc_269 [12];	/* RDB$CONSTRAINT_TYPE */
          short isc_270;	/* gds__null_flag */
          short isc_271;	/* gds__null_flag */
          short isc_272;	/* gds__null_flag */
          short isc_273;	/* gds__null_flag */
          short isc_274;	/* gds__null_flag */
          short isc_275;	/* gds__null_flag */
   } isc_263;
/**************************************
 *
 *	g e t _ r e l _ c o n s t r a i n t
 *
 **************************************
 *
 * Functional description
 *	Restore data for relation constraints.
 *
 **************************************/
	att_type		attribute;
	scan_attr_t		scan_next_attr;

	/*STORE (REQUEST_HANDLE tdgbl->handles_get_rel_constraint_req_handle1)
		X IN RDB$RELATION_CONSTRAINTS*/
	{
	
        if (!tdgbl->handles_get_rel_constraint_req_handle1)
           isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &tdgbl->handles_get_rel_constraint_req_handle1, (short) sizeof(isc_262), (char*) isc_262);
	if (tdgbl->handles_get_rel_constraint_req_handle1)
	   {
		/*X.RDB$CONSTRAINT_NAME.NULL*/
		isc_263.isc_275 = TRUE;
		/*X.RDB$CONSTRAINT_TYPE.NULL*/
		isc_263.isc_274 = TRUE;
		/*X.RDB$RELATION_NAME.NULL*/
		isc_263.isc_273 = TRUE;
		/*X.RDB$DEFERRABLE.NULL*/
		isc_263.isc_272 = TRUE;
		/*X.RDB$INITIALLY_DEFERRED.NULL*/
		isc_263.isc_271 = TRUE;
		/*X.RDB$INDEX_NAME.NULL*/
		isc_263.isc_270 = TRUE;

		skip_init(&scan_next_attr);
		while (skip_scan(&scan_next_attr), get_attribute(&attribute, tdgbl) != att_end)
		{
			switch (attribute)
			{
				case att_rel_constraint_name:
					/*X.RDB$CONSTRAINT_NAME.NULL*/
					isc_263.isc_275 = FALSE;
					GET_TEXT(/*X.RDB$CONSTRAINT_NAME*/
						 isc_263.isc_266);
					break;

				case att_rel_constraint_type:
					/*X.RDB$CONSTRAINT_TYPE.NULL*/
					isc_263.isc_274 = FALSE;
					GET_TEXT(/*X.RDB$CONSTRAINT_TYPE*/
						 isc_263.isc_269);
					break;

				case att_rel_constraint_rel_name:
					/*X.RDB$RELATION_NAME.NULL*/
					isc_263.isc_273 = FALSE;
					GET_TEXT(/*X.RDB$RELATION_NAME*/
						 isc_263.isc_265);
					break;

				case att_rel_constraint_defer:
					/*X.RDB$DEFERRABLE.NULL*/
					isc_263.isc_272 = FALSE;
					GET_TEXT(/*X.RDB$DEFERRABLE*/
						 isc_263.isc_268);
					break;

				case att_rel_constraint_init:
					/*X.RDB$INITIALLY_DEFERRED.NULL*/
					isc_263.isc_271 = FALSE;
					GET_TEXT(/*X.RDB$INITIALLY_DEFERRED*/
						 isc_263.isc_267);
					break;

				case att_rel_constraint_index:
					/*X.RDB$INDEX_NAME.NULL*/
					isc_263.isc_270 = FALSE;
					GET_TEXT(/*X.RDB$INDEX_NAME*/
						 isc_263.isc_264);
					break;

				default:
					bad_attribute (scan_next_attr, attribute, 208);
					// msg 208 table constraint
					break;
			}
		}
	/*END_STORE;*/
	   
           isc_start_and_send (isc_status, (FB_API_HANDLE*) &tdgbl->handles_get_rel_constraint_req_handle1, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 128, &isc_263, (short) 0);
	   };
	/*ON_ERROR*/
	if (isc_status [1])
	   {
		general_on_error ();
	/*END_ERROR;*/
	   }
	}

	return true;
}

bool get_relation_data(BurpGlobals* tdgbl)
{
/**************************************
 *
 *	g e t _ r e l a t i o n _ d a t a
 *
 **************************************
 *
 * Functional description
 *	Restore data for a relation.  This is called when the data is
 *	standing free from the relation definition.  We first need to
 *	find the relation named.  If we can't find it, give up.
 *
 **************************************/
	/*BASED_ON RDB$RELATIONS.RDB$RELATION_NAME name;*/
	char
	   name[32];

	att_type	attribute;
	scan_attr_t		scan_next_attr;

	burp_rel* relation = NULL;

	skip_init(&scan_next_attr);
	while (skip_scan(&scan_next_attr), get_attribute(&attribute, tdgbl) != att_end)
	{
		switch (attribute)
		{
		case att_relation_name:
			GET_TEXT(name);
			relation = find_relation (tdgbl, name);
			break;

		default:
			bad_attribute (scan_next_attr, attribute, 111);
			// msg 111 table
			break;
		}
	}

	if (!relation)
		BURP_error_redirect (NULL, 49);
	// msg 49 no relation name for data

	// Eat up misc. records
	rec_type record;
	get_record(&record, tdgbl);

	SLONG gen_id;

	skip_init(&scan_next_attr);
	while (skip_scan(&scan_next_attr), true)
	{
		switch (record)
		{
		case rec_relation_end:
			return true;

		case rec_data:
			record = get_data(tdgbl, relation);
			// get_data does a GET_RECORD
			break;

		case rec_gen_id:
			gen_id = get_numeric(tdgbl);
			store_blr_gen_id (tdgbl, name, gen_id, NULL);
			get_record(&record, tdgbl);
			break;

		case rec_index:
			get_index (tdgbl, relation);
			get_record(&record, tdgbl);
			break;

		case rec_trigger:  // old style trigger
			get_trigger_old (tdgbl, relation);
			get_record(&record, tdgbl);
			break;

		default:
			bad_attribute (scan_next_attr, attribute, 111);
			// msg 111 relation
			get_record(&record, tdgbl);
			break;
		}
	}

	return true;
}

bool get_sql_roles(BurpGlobals* tdgbl)
{
   struct isc_247_struct {
          char  isc_248 [32];	/* RDB$OWNER_NAME */
          char  isc_249 [32];	/* RDB$ROLE_NAME */
          short isc_250;	/* gds__null_flag */
          short isc_251;	/* gds__null_flag */
   } isc_247;
   struct isc_253_struct {
          ISC_QUAD isc_254;	/* RDB$DESCRIPTION */
          char  isc_255 [32];	/* RDB$OWNER_NAME */
          char  isc_256 [32];	/* RDB$ROLE_NAME */
          short isc_257;	/* gds__null_flag */
          short isc_258;	/* RDB$SYSTEM_FLAG */
          short isc_259;	/* gds__null_flag */
          short isc_260;	/* gds__null_flag */
          short isc_261;	/* gds__null_flag */
   } isc_253;
/**************************************
 *
 *	g e t _ s q l _ r o l e s
 *
 **************************************
 *
 * Functional description
 *	Restore data for SQL roles
 *
 **************************************/
	att_type		attribute;
	scan_attr_t		scan_next_attr;
	TEXT			temp[GDS_NAME_LEN];
	SSHORT			l;

	if (tdgbl->RESTORE_ods >= DB_VERSION_DDL11)
	{
		/*STORE (REQUEST_HANDLE tdgbl->handles_get_sql_roles_req_handle1)
			X IN RDB$ROLES*/
		{
		
                if (!tdgbl->handles_get_sql_roles_req_handle1)
                   isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &tdgbl->handles_get_sql_roles_req_handle1, (short) sizeof(isc_252), (char*) isc_252);
		if (tdgbl->handles_get_sql_roles_req_handle1)
		   {
		   isc_253.isc_254 = isc_blob_null;

			/*X.RDB$ROLE_NAME.NULL*/
			isc_253.isc_261 = TRUE;
			/*X.RDB$OWNER_NAME.NULL*/
			isc_253.isc_260 = TRUE;
			/*X.RDB$DESCRIPTION.NULL*/
			isc_253.isc_259 = TRUE;
			/*X.RDB$SYSTEM_FLAG*/
			isc_253.isc_258 = 0;
			/*X.RDB$SYSTEM_FLAG.NULL*/
			isc_253.isc_257 = FALSE;

			skip_init(&scan_next_attr);
			while (skip_scan(&scan_next_attr), get_attribute(&attribute, tdgbl) != att_end)
			{
				switch (attribute)
				{
				case att_role_name:
					/*X.RDB$ROLE_NAME.NULL*/
					isc_253.isc_261 = FALSE;
					l = GET_TEXT(/*X.RDB$ROLE_NAME*/
						     isc_253.isc_256);
					MISC_terminate (/*X.RDB$ROLE_NAME*/
							isc_253.isc_256, temp, l, sizeof(temp));
					// msg 251, restoring SQL role: %s
					BURP_verbose (251, temp);
					break;

				case att_role_owner_name:
					/*X.RDB$OWNER_NAME.NULL*/
					isc_253.isc_260 = FALSE;
					GET_TEXT(/*X.RDB$OWNER_NAME*/
						 isc_253.isc_255);
					break;

				case att_role_description:
					if (tdgbl->RESTORE_format >= 7)
					{
						get_source_blob (tdgbl, /*X.RDB$DESCRIPTION*/
									isc_253.isc_254, false);
						/*X.RDB$DESCRIPTION.NULL*/
						isc_253.isc_259 = FALSE;
					}
					else
						bad_attribute (scan_next_attr, attribute, 250);
				    break;

				default:
					// msg 250 SQL role
					bad_attribute (scan_next_attr, attribute, 250);
					break;
				}
			}
		/*END_STORE*/
		   
                   isc_start_and_send (isc_status, (FB_API_HANDLE*) &tdgbl->handles_get_sql_roles_req_handle1, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 82, &isc_253, (short) 0);
		   };
		/*ON_ERROR*/
		if (isc_status [1])
		   {
			general_on_error ();
		/*END_ERROR;*/
		   }
		}
	}
	else if (tdgbl->RESTORE_ods >= DB_VERSION_DDL9)
	{
		// This is the first IB version (v5, ods9) where roles appeared.
		// They remained unchanged for IB6 / FB1 and FB1.5 (ods10).
		/*STORE (REQUEST_HANDLE tdgbl->handles_get_sql_roles_req_handle1)
			X IN RDB$ROLES*/
		{
		
                if (!tdgbl->handles_get_sql_roles_req_handle1)
                   isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &tdgbl->handles_get_sql_roles_req_handle1, (short) sizeof(isc_246), (char*) isc_246);
		if (tdgbl->handles_get_sql_roles_req_handle1)
		   {

			/*X.RDB$ROLE_NAME.NULL*/
			isc_247.isc_251 = TRUE;
			/*X.RDB$OWNER_NAME.NULL*/
			isc_247.isc_250 = TRUE;
			// Here we didn't have RBD$SYSTEM_FLAG field.

			skip_init(&scan_next_attr);
			while (skip_scan(&scan_next_attr), get_attribute(&attribute, tdgbl) != att_end)
			{
				switch (attribute)
				{
				case att_role_name:
					/*X.RDB$ROLE_NAME.NULL*/
					isc_247.isc_251 = FALSE;
					l = GET_TEXT(/*X.RDB$ROLE_NAME*/
						     isc_247.isc_249);
					MISC_terminate (/*X.RDB$ROLE_NAME*/
							isc_247.isc_249, temp, l, sizeof(temp));
					// msg 251, restoring SQL role: %s
					BURP_verbose (251, temp);
					break;

				case att_role_owner_name:
					/*X.RDB$OWNER_NAME.NULL*/
					isc_247.isc_250 = FALSE;
					GET_TEXT(/*X.RDB$OWNER_NAME*/
						 isc_247.isc_248);
					break;

				case att_role_description:
					if (tdgbl->RESTORE_format >= 7)
						eat_blob(tdgbl);
					else
						bad_attribute (scan_next_attr, attribute, 250);
					break;

				default:
					// msg 250 SQL role
					bad_attribute (scan_next_attr, attribute, 250);
					break;
				}
			}
		/*END_STORE*/
		   
                   isc_start_and_send (isc_status, (FB_API_HANDLE*) &tdgbl->handles_get_sql_roles_req_handle1, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 68, &isc_247, (short) 0);
		   };
		/*ON_ERROR*/
		if (isc_status [1])
		   {
			general_on_error ();
		/*END_ERROR;*/
		   }
		}
	}
	else
	{
		// We say we support IB4, then we should skip roles.
		skip_init(&scan_next_attr);

		while (skip_scan(&scan_next_attr), get_attribute(&attribute, tdgbl) != att_end)
		{
			switch (attribute)
			{
			case att_role_name:
			case att_role_owner_name:
				eat_text(tdgbl);
				break;

			case att_role_description:
				if (tdgbl->RESTORE_format >= 7)
					eat_blob(tdgbl);
				else
					bad_attribute (scan_next_attr, attribute, 250);
				break;

			default:
				// msg 250 SQL role
				bad_attribute (scan_next_attr, attribute, 250);
				break;
			}
		}
	}

	return true;
}

bool get_mapping(BurpGlobals* tdgbl)
{
/**************************************
 *
 *	g e t _ m a p p i n g
 *
 **************************************
 *
 * Functional description
 *	Restore mapping to users and roles
 *	Restricted version - only single
 *	mapping is accepted
 *
 **************************************/
	att_type		attribute;
	scan_attr_t		scan_next_attr;
	TEXT			temp[GDS_NAME_LEN];
	SSHORT			l;
	Firebird::string role, os;

	if (tdgbl->RESTORE_ods >= DB_VERSION_DDL11_1)
	{
		skip_init(&scan_next_attr);
		while (skip_scan(&scan_next_attr), get_attribute(&attribute, tdgbl) != att_end)
		{
			switch (attribute)
			{
/*			case att_map_role:
				l = GET_TEXT(temp);
				role.assign(temp, l);
				break;

			case att_map_os:
				l = GET_TEXT(temp);
				os.assign(temp, l);
				break;
 */
			case att_auto_map_role:
				l = GET_TEXT(temp);
				role.assign(temp, l);
				break;

			default:
				// msg 299 name mapping
				bad_attribute (scan_next_attr, attribute, 299);
				break;
			}
		}

		if (tdgbl->RESTORE_ods < DB_VERSION_DDL11_2)
		{
			return true;	// silently skip attributes on old server
		}

		if (role != ADMIN_ROLE)
		{
			BURP_error(300, false);
			return true;
		}

		if (tdgbl->firstMap)
		{
			tdgbl->firstMap = false;
			BURP_verbose(301);
			// msg 301, restoring names mapping
		}
		BURP_verbose(298, ADMIN_ROLE);
		// msg 298, restoring map @1
		Firebird::string sql;
		sql.printf("%s ('%s', %d) %s",
			"UPDATE OR INSERT INTO RDB$ROLES(RDB$ROLE_NAME, RDB$SYSTEM_FLAG) VALUES",
			ADMIN_ROLE, ROLE_FLAG_MAY_TRUST | ROLE_FLAG_DBO,
			"MATCHING (RDB$ROLE_NAME)");
		isc_dsql_execute_immediate(tdgbl->status_vector, &tdgbl->db_handle, &tdgbl->tr_handle,
								   sql.length(), sql.c_str(), 1, NULL);
		if (tdgbl->status_vector[1])
		{
			general_on_error ();
		}
	}
	return true;
}

bool is_ascii_name (const TEXT *name, const SSHORT len)
{
/**************************************
 *
 *	i s _ a s c i i _ n a m e
 *
 **************************************
 *
 * Functional description
 *	Check if the input text is valid ASCII uppercased name
 *
 **************************************/
	SSHORT i = 0;

	while (i < len &&
			( (name[i] >= 'A' && name[i] <= 'Z') ||
			(name[i] >= '0' && name[i] <= '9') ||
			  name[i] == '_' || name[i] == '$' ) )
	{
		++i;
	}
	return (i == len);
}

bool get_security_class(BurpGlobals* tdgbl)
{
   struct isc_241_struct {
          ISC_QUAD isc_242;	/* RDB$ACL */
          char  isc_243 [32];	/* RDB$SECURITY_CLASS */
          ISC_QUAD isc_244;	/* RDB$DESCRIPTION */
          short isc_245;	/* gds__null_flag */
   } isc_241;
/**************************************
 *
 *	g e t _ s e c u r i t y _ c l a s s
 *
 **************************************
 *
 * Functional description
 *	Restore a security class record including access control list.
 *
 **************************************/
	att_type	attribute;
	TEXT		temp[GDS_NAME_LEN];
	SSHORT		l = 0;
	scan_attr_t		scan_next_attr;
	bool		is_valid_sec_class = false;

	/*STORE (REQUEST_HANDLE tdgbl->handles_get_security_class_req_handle1)
		X IN RDB$SECURITY_CLASSES*/
	{
	
        if (!tdgbl->handles_get_security_class_req_handle1)
           isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &tdgbl->handles_get_security_class_req_handle1, (short) sizeof(isc_240), (char*) isc_240);
	if (tdgbl->handles_get_security_class_req_handle1)
	   {
	   isc_241.isc_242 = isc_blob_null;
	   isc_241.isc_244 = isc_blob_null;

		/*X.RDB$DESCRIPTION.NULL*/
		isc_241.isc_245 = TRUE;

		skip_init(&scan_next_attr);
		while (skip_scan(&scan_next_attr), get_attribute(&attribute, tdgbl) != att_end)
		{
			switch (attribute)
			{
			case att_class_security_class:
				l = GET_TEXT(/*X.RDB$SECURITY_CLASS*/
					     isc_241.isc_243);

				// Bug fix for bug_no 7299: There was a V3 bug that inserted
				// garbage security class entry when doing GBAK. In order to
				// restore the V3 gbak file with this bad security entry to
				// V4 database. We should check if the security class is a
				// valid ASCII name. If not, skip this entry by setting
				// 'is_valid_sec_class' to false.

				is_valid_sec_class = is_ascii_name(/*X.RDB$SECURITY_CLASS*/
								   isc_241.isc_243, l);
				if (!is_valid_sec_class)
				{
					MISC_terminate (/*X.RDB$SECURITY_CLASS*/
							isc_241.isc_243, temp, l, sizeof(temp));
					BURP_print (false, 234, temp);
					// msg 234   Skipped bad security class entry: %s
					break;
				}

				MISC_terminate (/*X.RDB$SECURITY_CLASS*/
						isc_241.isc_243, temp, l, sizeof(temp));
				BURP_verbose (125, temp);
				// msg 125   restoring security class %s
				break;

			case att_class_acl:
				get_misc_blob (tdgbl, /*X.RDB$ACL*/
						      isc_241.isc_242, false);
				break;

			case att_class_description:
				/*X.RDB$DESCRIPTION.NULL*/
				isc_241.isc_245 = FALSE;
				get_misc_blob (tdgbl, /*X.RDB$DESCRIPTION*/
						      isc_241.isc_244, false);
				break;

			case att_class_description2:
				/*X.RDB$DESCRIPTION.NULL*/
				isc_241.isc_245 = FALSE;
				get_source_blob (tdgbl, /*X.RDB$DESCRIPTION*/
							isc_241.isc_244, false);
				break;

			default:
				bad_attribute (scan_next_attr, attribute, 131);
				// msg 131 security class
				break;
			}
		}
		// If the security class is not valid ASCII name, don't store it to the
		// database. Simply return from here and the entry is discarded.
		if (!is_valid_sec_class)
		{
			return true;
		}
	/*END_STORE;*/
	   
           isc_start_and_send (isc_status, (FB_API_HANDLE*) &tdgbl->handles_get_security_class_req_handle1, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 50, &isc_241, (short) 0);
	   };
	/*ON_ERROR*/
	if (isc_status [1])
	   {
		general_on_error ();
	/*END_ERROR;*/
	   }
	}

	return true;
}

void get_source_blob(BurpGlobals*	tdgbl,
					 ISC_QUAD&		blob_id,
					 bool			glb_trans)
{
/**************************************
 *
 *	g e t _ s o u r c e _ b l o b
 *
 **************************************
 *
 * Functional description
 *	Read source blob and query header attributes and copy data from
 *	input file to nice, shiney, new blob.
 *
 **************************************/
	ISC_STATUS_ARRAY	status_vector;

	SLONG length = get_numeric(tdgbl);

	// Create new blob

	UserBlob blob(status_vector);
	isc_tr_handle	local_trans;
	if (glb_trans && tdgbl->global_trans)
		local_trans = tdgbl->global_trans;
	else
		local_trans = gds_trans;

	bool ok;

	if (tdgbl->gbl_sw_fix_fss_metadata)
	{
		UCHAR bpb[15];
		UCHAR* p = bpb;

		*p++ = isc_bpb_version1;

		*p++ = isc_bpb_source_type;
		*p++ = 2;
		put_short(p, isc_blob_text);
		p += 2;
		*p++ = isc_bpb_source_interp;
		*p++ = 1;
		*p++ = tdgbl->gbl_sw_fix_fss_metadata_id;

		*p++ = isc_bpb_target_type;
		*p++ = 2;
		put_short(p, isc_blob_text);
		p += 2;
		*p++ = isc_bpb_target_interp;
		*p++ = 1;
		*p++ = CS_UNICODE_FSS;

		ok = blob.create(DB, local_trans, blob_id, p - bpb, bpb);
	}
	else
		ok = blob.create(DB, local_trans, blob_id);

	if (!ok)
	{
		BURP_error_redirect (status_vector, 37);
		// msg 37 isc_create_blob failed
	}

	// Allocate blob buffer if static buffer is too short
	BlobBuffer static_buffer;
	UCHAR* const buffer = static_buffer.getBuffer(length);

	while (length > 0)
	{
		UCHAR* p = buffer;
		while (*p++ = get(tdgbl))
			length--;
		--p;
		--length; // -- or ++ ??? p is decremented, will have to test.
		const USHORT seg_len = p - buffer;

		if (!blob.putSegment(seg_len, buffer))
		{
			BURP_error_redirect (status_vector, 38);
			// msg 38 isc_put_segment failed
		}
	}

	if (!blob.close())
		BURP_error_redirect (status_vector, 23);
		// msg 23 isc_close_blob failed
}

USHORT get_text(BurpGlobals* 	tdgbl,
				TEXT*			text,
				ULONG			length)
{
/**************************************
 *
 *	g e t _ t e x t
 *
 **************************************
 *
 * Functional description
 *	Move a text attribute to a string and fill.
 *
 **************************************/
	const ULONG l = get(tdgbl);

	if (length <= l)
		BURP_error_redirect (NULL, 46);
		// msg 46 string truncated

	if (l)
		text = (TEXT*) get_block(tdgbl, (UCHAR*) text, l);

	*text = 0;

	return (USHORT) l;
}

USHORT get_text2(BurpGlobals* tdgbl, TEXT* text, ULONG length)
{
/**************************************
 *
 *	g e t _ t e x t 2
 *
 **************************************
 *
 * Functional description
 *	Move a text attribute to a string and fill, using USHORT as length indicator.
 *
 **************************************/
	UCHAR lenstr[sizeof(USHORT)] = "";
	get_block(tdgbl, lenstr, sizeof(lenstr));
	const USHORT len = (USHORT) gds__vax_integer(lenstr, sizeof(lenstr));

	if (length <= len)
	{
		BURP_error_redirect (NULL, 46);
		// msg 46 string truncated
	}

	if (len)
		text = (TEXT*) get_block(tdgbl, (UCHAR*) text, len);

	*text = 0;

	return len;
}

bool get_trigger_old (BurpGlobals*	tdgbl,
					  burp_rel*		relation)
{
   struct isc_227_struct {
          char  isc_228 [32];	/* RDB$RELATION_NAME */
          char  isc_229 [32];	/* RDB$TRIGGER_NAME */
          ISC_QUAD isc_230;	/* RDB$TRIGGER_SOURCE */
          ISC_QUAD isc_231;	/* RDB$TRIGGER_BLR */
          ISC_QUAD isc_232;	/* RDB$DESCRIPTION */
          short isc_233;	/* RDB$TRIGGER_SEQUENCE */
          short isc_234;	/* RDB$TRIGGER_TYPE */
          short isc_235;	/* gds__null_flag */
          short isc_236;	/* RDB$SYSTEM_FLAG */
          short isc_237;	/* gds__null_flag */
          short isc_238;	/* gds__null_flag */
          short isc_239;	/* gds__null_flag */
   } isc_227;
/**************************************
 *
 *	g e t _ t r i g g e r _ o l d
 *
 **************************************
 *
 * Functional description
 *	Get a trigger definition for a relation.
 *
 **************************************/
	enum trig_t	type;
	att_type	attribute;
	TEXT		name[GDS_NAME_LEN];
	scan_attr_t		scan_next_attr;

	/*STORE (REQUEST_HANDLE tdgbl->handles_get_trigger_old_req_handle1)
		X IN RDB$TRIGGERS*/
	{
	
        if (!tdgbl->handles_get_trigger_old_req_handle1)
           isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &tdgbl->handles_get_trigger_old_req_handle1, (short) sizeof(isc_226), (char*) isc_226);
	if (tdgbl->handles_get_trigger_old_req_handle1)
	   {
	   isc_227.isc_230 = isc_blob_null;
	   isc_227.isc_231 = isc_blob_null;
	   isc_227.isc_232 = isc_blob_null;

		/*X.RDB$DESCRIPTION.NULL*/
		isc_227.isc_239 = TRUE;
		/*X.RDB$TRIGGER_BLR.NULL*/
		isc_227.isc_238 = TRUE;
		/*X.RDB$TRIGGER_SOURCE.NULL*/
		isc_227.isc_237 = TRUE;
		/*X.RDB$SYSTEM_FLAG*/
		isc_227.isc_236 = 0;
		/*X.RDB$SYSTEM_FLAG.NULL*/
		isc_227.isc_235 = FALSE;

		skip_init(&scan_next_attr);
		while (skip_scan(&scan_next_attr), get_attribute(&attribute, tdgbl) != att_end)
		{
			switch (attribute)
			{
			case att_trig_type:
				type = (enum trig_t) get_numeric(tdgbl);
				break;

			case att_trig_blr:
				/*X.RDB$TRIGGER_BLR.NULL*/
				isc_227.isc_238 = FALSE;
				get_blr_blob (tdgbl, /*X.RDB$TRIGGER_BLR*/
						     isc_227.isc_231, false);
				break;

			case att_trig_source:
				/*X.RDB$TRIGGER_SOURCE.NULL*/
				isc_227.isc_237 = FALSE;
				get_misc_blob (tdgbl, /*X.RDB$TRIGGER_SOURCE*/
						      isc_227.isc_230, false);
				break;

			case att_trig_source2:
				/*X.RDB$TRIGGER_SOURCE.NULL*/
				isc_227.isc_237 = FALSE;
				get_source_blob (tdgbl, /*X.RDB$TRIGGER_SOURCE*/
							isc_227.isc_230, false);
				break;

			default:
				bad_attribute (scan_next_attr, attribute, 134);
				// msg 134 trigger
				break;
			}
		}

		// fill in rest of attributes unique to new trigger format

		TEXT* p = /*X.RDB$TRIGGER_NAME*/
			  isc_227.isc_229;
		const TEXT* const end = p + 31;
		const TEXT* q = relation->rel_name;
		while (*q) {
			*p++ = *q++;
		}

		switch (type)
		{
		case trig_pre_store:
			/*X.RDB$TRIGGER_TYPE*/
			isc_227.isc_234 = TRIG_TYPE_PRE_STORE;
			q = "$STORE";
			break;
		case trig_pre_modify:
			/*X.RDB$TRIGGER_TYPE*/
			isc_227.isc_234 = TRIG_TYPE_PRE_MODIFY;
			q = "$MODIFY";
			break;
		case trig_post_erase:
			/*X.RDB$TRIGGER_TYPE*/
			isc_227.isc_234 = TRIG_TYPE_POST_ERASE;
			q = "$ERASE";
			break;
		default:
			bad_attribute (scan_next_attr, attribute, 136);
			// msg 136 trigger type
			return 0;
		}

		while (*q && p < end) {
			*p++ = *q++;
		}
		*p = 0;
		BURP_verbose (126, /*X.RDB$TRIGGER_NAME*/
				   isc_227.isc_229);
		// msg 126 restoring trigger %s
		strncpy (/*X.RDB$RELATION_NAME*/
			 isc_227.isc_228, relation->rel_name, GDS_NAME_LEN);
		strcpy (name, /*X.RDB$TRIGGER_NAME*/
			      isc_227.isc_229);
		/*X.RDB$TRIGGER_SEQUENCE*/
		isc_227.isc_233 = TRIGGER_SEQUENCE_DEFAULT;

	/*END_STORE;*/
	   
           isc_start_and_send (isc_status, (FB_API_HANDLE*) &tdgbl->handles_get_trigger_old_req_handle1, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 102, &isc_227, (short) 0);
	   };
	/*ON_ERROR*/
	if (isc_status [1])
	   {
		general_on_error ();
	/*END_ERROR;*/
	   }
	}

	if (tdgbl->gbl_sw_incremental)
	{
		/*COMMIT*/
		{
		isc_commit_transaction (isc_status, (FB_API_HANDLE*) &gds_trans);;
		// existing ON_ERROR continues past error, beck
		/*ON_ERROR*/
		if (isc_status [1])
		   {
			BURP_print (false, 94, name);
			// msg 94 trigger %s is invalid
			BURP_print_status (false, tdgbl->status_vector);
			/*ROLLBACK;*/
			{
			isc_rollback_transaction (isc_status, (FB_API_HANDLE*) &gds_trans);;
			/*ON_ERROR*/
			if (isc_status [1])
			   {
				general_on_error ();
			/*END_ERROR;*/
			   }
			}
		/*END_ERROR;*/
		   }
		}
		/*EXEC SQL SET TRANSACTION NO_AUTO_UNDO;*/
		{
		isc_start_transaction (isc_status, (FB_API_HANDLE*) &gds_trans, (short) 1, &DB, (short) 5, isc_tpb_15);
		SQLCODE = isc_sqlcode(isc_status);
		}
		if (gds_status[1])
			/*EXEC SQL SET TRANSACTION;*/
			{
			isc_start_transaction (isc_status, (FB_API_HANDLE*) &gds_trans, (short) 1, &DB, (short) 4, isc_tpb_16);
			SQLCODE = isc_sqlcode(isc_status);
			}
	}

	return true;
}

bool get_trigger(BurpGlobals* tdgbl)
{
   struct isc_187_struct {
          char  isc_188 [32];	/* RDB$TRIGGER_NAME */
          ISC_QUAD isc_189;	/* RDB$TRIGGER_SOURCE */
          ISC_QUAD isc_190;	/* RDB$TRIGGER_BLR */
          ISC_QUAD isc_191;	/* RDB$DESCRIPTION */
          char  isc_192 [32];	/* RDB$RELATION_NAME */
          short isc_193;	/* RDB$TRIGGER_INACTIVE */
          short isc_194;	/* RDB$TRIGGER_SEQUENCE */
          short isc_195;	/* RDB$TRIGGER_TYPE */
          short isc_196;	/* gds__null_flag */
          short isc_197;	/* RDB$FLAGS */
          short isc_198;	/* gds__null_flag */
          short isc_199;	/* RDB$SYSTEM_FLAG */
          short isc_200;	/* gds__null_flag */
          short isc_201;	/* gds__null_flag */
          short isc_202;	/* gds__null_flag */
          short isc_203;	/* gds__null_flag */
   } isc_187;
   struct isc_205_struct {
          char  isc_206 [32];	/* RDB$TRIGGER_NAME */
          ISC_QUAD isc_207;	/* RDB$DEBUG_INFO */
          ISC_QUAD isc_208;	/* RDB$TRIGGER_SOURCE */
          ISC_QUAD isc_209;	/* RDB$TRIGGER_BLR */
          ISC_QUAD isc_210;	/* RDB$DESCRIPTION */
          char  isc_211 [32];	/* RDB$RELATION_NAME */
          short isc_212;	/* RDB$TRIGGER_INACTIVE */
          short isc_213;	/* RDB$TRIGGER_SEQUENCE */
          short isc_214;	/* RDB$TRIGGER_TYPE */
          short isc_215;	/* gds__null_flag */
          short isc_216;	/* gds__null_flag */
          short isc_217;	/* RDB$VALID_BLR */
          short isc_218;	/* gds__null_flag */
          short isc_219;	/* RDB$FLAGS */
          short isc_220;	/* gds__null_flag */
          short isc_221;	/* RDB$SYSTEM_FLAG */
          short isc_222;	/* gds__null_flag */
          short isc_223;	/* gds__null_flag */
          short isc_224;	/* gds__null_flag */
          short isc_225;	/* gds__null_flag */
   } isc_205;
/**************************************
 *
 *	g e t _ t r i g g e r
 *
 **************************************
 *
 * Functional description
 *	Get a trigger definition in rdb$triggers.
 *
 **************************************/
	att_type	attribute;
	/*BASED_ON RDB$TRIGGERS.RDB$TRIGGER_NAME name;*/
	char
	   name[32];

	scan_attr_t		scan_next_attr;

	isc_tr_handle local_trans = tdgbl->global_trans ? tdgbl->global_trans : gds_trans;

	if (tdgbl->RESTORE_ods >= DB_VERSION_DDL11_1)
	{
		/*STORE (TRANSACTION_HANDLE local_trans
				REQUEST_HANDLE tdgbl->handles_get_trigger_req_handle1)
			X IN RDB$TRIGGERS*/
		{
		
                if (!tdgbl->handles_get_trigger_req_handle1)
                   isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &tdgbl->handles_get_trigger_req_handle1, (short) sizeof(isc_204), (char*) isc_204);
		if (tdgbl->handles_get_trigger_req_handle1)
		   {
		   isc_205.isc_207 = isc_blob_null;
		   isc_205.isc_208 = isc_blob_null;
		   isc_205.isc_209 = isc_blob_null;
		   isc_205.isc_210 = isc_blob_null;

			/*X.RDB$RELATION_NAME.NULL*/
			isc_205.isc_225 = TRUE;
			/*X.RDB$DESCRIPTION.NULL*/
			isc_205.isc_224 = TRUE;
			/*X.RDB$TRIGGER_BLR.NULL*/
			isc_205.isc_223 = TRUE;
			/*X.RDB$TRIGGER_SOURCE.NULL*/
			isc_205.isc_222 = TRUE;
			/*X.RDB$SYSTEM_FLAG*/
			isc_205.isc_221 = 0;
			/*X.RDB$SYSTEM_FLAG.NULL*/
			isc_205.isc_220 = FALSE;
			/*X.RDB$FLAGS.NULL*/
			isc_205.isc_218 = TRUE;
			/*X.RDB$VALID_BLR.NULL*/
			isc_205.isc_216 = TRUE;
			/*X.RDB$DEBUG_INFO.NULL*/
			isc_205.isc_215 = TRUE;

			skip_init(&scan_next_attr);
			while (skip_scan(&scan_next_attr), get_attribute(&attribute, tdgbl) != att_end)
			{
				switch (attribute)
				{
				case att_trig_type:
					/*X.RDB$TRIGGER_TYPE*/
					isc_205.isc_214 = (USHORT) get_numeric(tdgbl);
					break;

				case att_trig_flags:
					/*X.RDB$FLAGS*/
					isc_205.isc_219 = (USHORT) get_numeric(tdgbl);
					/*X.RDB$FLAGS.NULL*/
					isc_205.isc_218 = FALSE;
					break;

				case att_trig_blr:
					/*X.RDB$TRIGGER_BLR.NULL*/
					isc_205.isc_223 = FALSE;
					get_blr_blob (tdgbl, /*X.RDB$TRIGGER_BLR*/
							     isc_205.isc_209, true);
					break;

				case att_trig_source:
					/*X.RDB$TRIGGER_SOURCE.NULL*/
					isc_205.isc_222 = FALSE;
					get_misc_blob (tdgbl, /*X.RDB$TRIGGER_SOURCE*/
							      isc_205.isc_208, true);
					break;

				case att_trig_source2:
					/*X.RDB$TRIGGER_SOURCE.NULL*/
					isc_205.isc_222 = FALSE;
					get_source_blob (tdgbl, /*X.RDB$TRIGGER_SOURCE*/
								isc_205.isc_208, true);
					break;

				case att_trig_name:
					GET_TEXT(/*X.RDB$TRIGGER_NAME*/
						 isc_205.isc_206);
					strcpy (name, /*X.RDB$TRIGGER_NAME*/
						      isc_205.isc_206);
					BURP_verbose (126, /*X.RDB$TRIGGER_NAME*/
							   isc_205.isc_206);
					// msg 126 restoring trigger %s
					break;

				case att_trig_relation_name:
					/*X.RDB$RELATION_NAME.NULL*/
					isc_205.isc_225 = FALSE;
					GET_TEXT(/*X.RDB$RELATION_NAME*/
						 isc_205.isc_211);
					break;

				case att_trig_sequence:
					/*X.RDB$TRIGGER_SEQUENCE*/
					isc_205.isc_213 = (USHORT) get_numeric(tdgbl);
					break;

				case att_trig_description:
					/*X.RDB$DESCRIPTION.NULL*/
					isc_205.isc_224 = FALSE;
					get_misc_blob (tdgbl, /*X.RDB$DESCRIPTION*/
							      isc_205.isc_210, true);
					break;

				case att_trig_description2:
					/*X.RDB$DESCRIPTION.NULL*/
					isc_205.isc_224 = FALSE;
					get_source_blob (tdgbl, /*X.RDB$DESCRIPTION*/
								isc_205.isc_210, true);
					break;

				case att_trig_system_flag:
					/*X.RDB$SYSTEM_FLAG*/
					isc_205.isc_221 = (USHORT) get_numeric(tdgbl);
					/*X.RDB$SYSTEM_FLAG.NULL*/
					isc_205.isc_220 = FALSE;
					break;

				case att_trig_inactive:
					/*X.RDB$TRIGGER_INACTIVE*/
					isc_205.isc_212 = (USHORT) get_numeric(tdgbl);
					break;

				case att_trig_valid_blr:
					if (tdgbl->RESTORE_format >= 8)
					{
						/*X.RDB$VALID_BLR.NULL*/
						isc_205.isc_216 = FALSE;
						/*X.RDB$VALID_BLR*/
						isc_205.isc_217 = (USHORT) get_numeric(tdgbl);
					}
					else
						bad_attribute (scan_next_attr, attribute, 134);
					break;

				case att_trig_debug_info:
					if (tdgbl->RESTORE_format >= 8)
					{
						/*X.RDB$DEBUG_INFO.NULL*/
						isc_205.isc_215 = FALSE;
						get_misc_blob (tdgbl, /*X.RDB$DEBUG_INFO*/
								      isc_205.isc_207, true);
					}
					else
						bad_attribute (scan_next_attr, attribute, 134);
					break;

				default:
					bad_attribute (scan_next_attr, attribute, 134);
					// msg 134 trigger
					break;
				}
			}
		/*END_STORE;*/
		   
                   isc_start_and_send (isc_status, (FB_API_HANDLE*) &tdgbl->handles_get_trigger_req_handle1, (FB_API_HANDLE*) &local_trans, (short) 0, (short) 124, &isc_205, (short) 0);
		   };
		/*ON_ERROR*/
		if (isc_status [1])
		   {
			general_on_error ();
		/*END_ERROR;*/
		   }
		}
	}
	else
	{
		/*STORE (TRANSACTION_HANDLE local_trans
				REQUEST_HANDLE tdgbl->handles_get_trigger_req_handle1)
			X IN RDB$TRIGGERS*/
		{
		
                if (!tdgbl->handles_get_trigger_req_handle1)
                   isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &tdgbl->handles_get_trigger_req_handle1, (short) sizeof(isc_186), (char*) isc_186);
		if (tdgbl->handles_get_trigger_req_handle1)
		   {
		   isc_187.isc_189 = isc_blob_null;
		   isc_187.isc_190 = isc_blob_null;
		   isc_187.isc_191 = isc_blob_null;

			/*X.RDB$RELATION_NAME.NULL*/
			isc_187.isc_203 = TRUE;
			/*X.RDB$DESCRIPTION.NULL*/
			isc_187.isc_202 = TRUE;
			/*X.RDB$TRIGGER_BLR.NULL*/
			isc_187.isc_201 = TRUE;
			/*X.RDB$TRIGGER_SOURCE.NULL*/
			isc_187.isc_200 = TRUE;
			/*X.RDB$SYSTEM_FLAG*/
			isc_187.isc_199 = 0;
			/*X.RDB$SYSTEM_FLAG.NULL*/
			isc_187.isc_198 = FALSE;
			/*X.RDB$FLAGS.NULL*/
			isc_187.isc_196 = TRUE;

			skip_init(&scan_next_attr);
			while (skip_scan(&scan_next_attr), get_attribute(&attribute, tdgbl) != att_end)
			{
				switch (attribute)
				{
				case att_trig_type:
					/*X.RDB$TRIGGER_TYPE*/
					isc_187.isc_195 = (USHORT) get_numeric(tdgbl);
					break;

				case att_trig_flags:
					/*X.RDB$FLAGS*/
					isc_187.isc_197 = (USHORT) get_numeric(tdgbl);
					/*X.RDB$FLAGS.NULL*/
					isc_187.isc_196 = FALSE;
					break;

				case att_trig_blr:
					/*X.RDB$TRIGGER_BLR.NULL*/
					isc_187.isc_201 = FALSE;
					get_blr_blob (tdgbl, /*X.RDB$TRIGGER_BLR*/
							     isc_187.isc_190, true);
					break;

				case att_trig_source:
					/*X.RDB$TRIGGER_SOURCE.NULL*/
					isc_187.isc_200 = FALSE;
					get_misc_blob (tdgbl, /*X.RDB$TRIGGER_SOURCE*/
							      isc_187.isc_189, true);
					break;

				case att_trig_source2:
					/*X.RDB$TRIGGER_SOURCE.NULL*/
					isc_187.isc_200 = FALSE;
					get_source_blob (tdgbl, /*X.RDB$TRIGGER_SOURCE*/
								isc_187.isc_189, true);
					break;

				case att_trig_name:
					GET_TEXT(/*X.RDB$TRIGGER_NAME*/
						 isc_187.isc_188);
					strcpy (name, /*X.RDB$TRIGGER_NAME*/
						      isc_187.isc_188);
					BURP_verbose (126, /*X.RDB$TRIGGER_NAME*/
							   isc_187.isc_188);
					// msg 126 restoring trigger %s
					break;

				case att_trig_relation_name:
					/*X.RDB$RELATION_NAME.NULL*/
					isc_187.isc_203 = FALSE;
					GET_TEXT(/*X.RDB$RELATION_NAME*/
						 isc_187.isc_192);
					break;

				case att_trig_sequence:
					/*X.RDB$TRIGGER_SEQUENCE*/
					isc_187.isc_194 = (USHORT) get_numeric(tdgbl);
					break;

				case att_trig_description:
					/*X.RDB$DESCRIPTION.NULL*/
					isc_187.isc_202 = FALSE;
					get_misc_blob (tdgbl, /*X.RDB$DESCRIPTION*/
							      isc_187.isc_191, true);
					break;

				case att_trig_description2:
					/*X.RDB$DESCRIPTION.NULL*/
					isc_187.isc_202 = FALSE;
					get_source_blob (tdgbl, /*X.RDB$DESCRIPTION*/
								isc_187.isc_191, true);
					break;

				case att_trig_system_flag:
					/*X.RDB$SYSTEM_FLAG*/
					isc_187.isc_199 = (USHORT) get_numeric(tdgbl);
					/*X.RDB$SYSTEM_FLAG.NULL*/
					isc_187.isc_198 = FALSE;
					break;

				case att_trig_inactive:
					/*X.RDB$TRIGGER_INACTIVE*/
					isc_187.isc_193 = (USHORT) get_numeric(tdgbl);
					break;

				default:
					bad_attribute (scan_next_attr, attribute, 134);
					// msg 134 trigger
					break;
				}
			}
		/*END_STORE;*/
		   
                   isc_start_and_send (isc_status, (FB_API_HANDLE*) &tdgbl->handles_get_trigger_req_handle1, (FB_API_HANDLE*) &local_trans, (short) 0, (short) 110, &isc_187, (short) 0);
		   };
		/*ON_ERROR*/
		if (isc_status [1])
		   {
			general_on_error ();
		/*END_ERROR;*/
		   }
		}
	}

	if (tdgbl->gbl_sw_incremental)
	{
		/*COMMIT*/
		{
		isc_commit_transaction (isc_status, (FB_API_HANDLE*) &gds_trans);;
		// existing ON_ERROR continues past error, beck
		/*ON_ERROR*/
		if (isc_status [1])
		   {
			BURP_print (false, 94, name);
			// msg 94 trigger %s is invalid
			BURP_print_status (false, tdgbl->status_vector);
			/*ROLLBACK;*/
			{
			isc_rollback_transaction (isc_status, (FB_API_HANDLE*) &gds_trans);;
			/*ON_ERROR*/
			if (isc_status [1])
			   {
				general_on_error ();
			/*END_ERROR;*/
			   }
			}
		/*END_ERROR;*/
		   }
		}
		/*EXEC SQL SET TRANSACTION NO_AUTO_UNDO;*/
		{
		isc_start_transaction (isc_status, (FB_API_HANDLE*) &gds_trans, (short) 1, &DB, (short) 5, isc_tpb_17);
		SQLCODE = isc_sqlcode(isc_status);
		}
		if (gds_status[1])
			/*EXEC SQL SET TRANSACTION;*/
			{
			isc_start_transaction (isc_status, (FB_API_HANDLE*) &gds_trans, (short) 1, &DB, (short) 4, isc_tpb_18);
			SQLCODE = isc_sqlcode(isc_status);
			}
	}

	return true;
}

bool get_trigger_message(BurpGlobals* tdgbl)
{
   struct isc_177_struct {
          char  isc_178 [1024];	/* RDB$MESSAGE */
          char  isc_179 [32];	/* RDB$TRIGGER_NAME */
          short isc_180;	/* RDB$MESSAGE_NUMBER */
   } isc_177;
   struct isc_184_struct {
          short isc_185;	/* isc_utility */
   } isc_184;
   struct isc_182_struct {
          char  isc_183 [32];	/* RDB$TRIGGER_NAME */
   } isc_182;
/**************************************
 *
 *	g e t _ t r i g g e r _ m e s s a g e
 *
 **************************************
 *
 * Functional description
 *	Get a trigger message text.
 *
 **************************************/
	att_type	attribute;
	scan_attr_t		scan_next_attr;

	/*BASED_ON RDB$TRIGGER_MESSAGES.RDB$TRIGGER_NAME name;*/
	char
	   name[32];

	/*BASED_ON RDB$TRIGGER_MESSAGES.RDB$MESSAGE_NUMBER number*/
	short
	   number
 = -1;
	/*BASED_ON RDB$TRIGGER_MESSAGES.RDB$MESSAGE message;*/
	char
	   message[1024];


	bool sysflag = false;
	skip_init(&scan_next_attr);
	while (skip_scan(&scan_next_attr), get_attribute(&attribute, tdgbl) != att_end)
	{
		switch (attribute)
		{
		case att_trigmsg_name:
			GET_TEXT(name);
			sysflag = false;
			/*FOR (REQUEST_HANDLE tdgbl->handles_get_trigger_message_req_handle1)
				FIRST 1 X IN RDB$TRIGGERS WITH
				X.RDB$SYSTEM_FLAG EQ 1 AND X.RDB$TRIGGER_NAME EQ name*/
			{
                        if (!tdgbl->handles_get_trigger_message_req_handle1)
                           isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &tdgbl->handles_get_trigger_message_req_handle1, (short) sizeof(isc_181), (char*) isc_181);
			isc_vtov ((const char*) name, (char*) isc_182.isc_183, 32);
			if (tdgbl->handles_get_trigger_message_req_handle1)
			   {
                           isc_start_and_send (isc_status, (FB_API_HANDLE*) &tdgbl->handles_get_trigger_message_req_handle1, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 32, &isc_182, (short) 0);
			   }
			if (!isc_status [1]) {
			while (1)
			   {
                           isc_receive (isc_status, (FB_API_HANDLE*) &tdgbl->handles_get_trigger_message_req_handle1, (short) 1, (short) 2, &isc_184, (short) 0);
			   if (!isc_184.isc_185 || isc_status [1]) break;
				sysflag = true;
			/*END_FOR;*/
			   }
			   };
			/*ON_ERROR*/
			if (isc_status [1])
			   {
				general_on_error ();
			/*END_ERROR;*/
			   }
			}
			BURP_verbose (127, name);
			// msg 127 restoring trigger message for %s
			break;

		case att_trigmsg_number:
			number = (USHORT) get_numeric(tdgbl);
			break;

		case att_trigmsg_text:
			GET_TEXT(message);
			break;

		default:
			bad_attribute (scan_next_attr, attribute, 135);
			// msg 135  trigger message
			break;
		}
	}

	if (sysflag)
		return true;

	// Versions prior to FB2.0 don't support a field longer than varchar(78).
	if (tdgbl->RESTORE_ods < DB_VERSION_DDL11)
		message[78] = 0;

	isc_tr_handle local_trans = tdgbl->global_trans ? tdgbl->global_trans : gds_trans;

	/*STORE (TRANSACTION_HANDLE local_trans
			REQUEST_HANDLE tdgbl->handles_get_trigger_message_req_handle2)
		X IN RDB$TRIGGER_MESSAGES*/
	{
	
        if (!tdgbl->handles_get_trigger_message_req_handle2)
           isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &tdgbl->handles_get_trigger_message_req_handle2, (short) sizeof(isc_176), (char*) isc_176);
	if (tdgbl->handles_get_trigger_message_req_handle2)
	   {
		strcpy (/*X.RDB$TRIGGER_NAME*/
			isc_177.isc_179, name);
		/*X.RDB$MESSAGE_NUMBER*/
		isc_177.isc_180 = number;
		strcpy (/*X.RDB$MESSAGE*/
			isc_177.isc_178, message);
	/*END_STORE;*/
	   
           isc_start_and_send (isc_status, (FB_API_HANDLE*) &tdgbl->handles_get_trigger_message_req_handle2, (FB_API_HANDLE*) &local_trans, (short) 0, (short) 1058, &isc_177, (short) 0);
	   };
	/*ON_ERROR*/
	if (isc_status [1])
	   {
		general_on_error ();
	/*END_ERROR;*/
	   }
	}

	if (tdgbl->gbl_sw_incremental)
	{
		/*COMMIT*/
		{
		isc_commit_transaction (isc_status, (FB_API_HANDLE*) &gds_trans);;
		// existing ON_ERROR continues past error, beck
		/*ON_ERROR*/
		if (isc_status [1])
		   {
			BURP_print (false, 94, name);
			// msg 94 trigger %s is invalid
			BURP_print_status (false, tdgbl->status_vector);
			/*ROLLBACK;*/
			{
			isc_rollback_transaction (isc_status, (FB_API_HANDLE*) &gds_trans);;
			/*ON_ERROR*/
			if (isc_status [1])
			   {
				general_on_error ();
			/*END_ERROR;*/
			   }
			}
		/*END_ERROR;*/
		   }
		}
		/*EXEC SQL SET TRANSACTION NO_AUTO_UNDO;*/
		{
		isc_start_transaction (isc_status, (FB_API_HANDLE*) &gds_trans, (short) 1, &DB, (short) 5, isc_tpb_19);
		SQLCODE = isc_sqlcode(isc_status);
		}
		if (gds_status[1])
			/*EXEC SQL SET TRANSACTION;*/
			{
			isc_start_transaction (isc_status, (FB_API_HANDLE*) &gds_trans, (short) 1, &DB, (short) 4, isc_tpb_20);
			SQLCODE = isc_sqlcode(isc_status);
			}
	}

	return true;
}

bool get_type(BurpGlobals* tdgbl)
{
   struct isc_168_struct {
          char  isc_169 [32];	/* RDB$FIELD_NAME */
          char  isc_170 [32];	/* RDB$TYPE_NAME */
          ISC_QUAD isc_171;	/* RDB$DESCRIPTION */
          short isc_172;	/* RDB$TYPE */
          short isc_173;	/* gds__null_flag */
          short isc_174;	/* RDB$SYSTEM_FLAG */
          short isc_175;	/* gds__null_flag */
   } isc_168;
/**************************************
 *
 *	g e t _ t y p e
 *
 **************************************
 *
 * Functional description
 *	Get a type definition in rdb$types.
 *
 **************************************/
	att_type	attribute;
	ULONG		l;
	TEXT		temp[GDS_NAME_LEN];
	scan_attr_t		scan_next_attr;

	/*STORE (REQUEST_HANDLE tdgbl->handles_get_type_req_handle1)
		X IN RDB$TYPES*/
	{
	
        if (!tdgbl->handles_get_type_req_handle1)
           isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &tdgbl->handles_get_type_req_handle1, (short) sizeof(isc_167), (char*) isc_167);
	if (tdgbl->handles_get_type_req_handle1)
	   {
	   isc_168.isc_171 = isc_blob_null;

		/*X.RDB$DESCRIPTION.NULL*/
		isc_168.isc_175 = TRUE;
		/*X.RDB$SYSTEM_FLAG*/
		isc_168.isc_174 = 0;
		/*X.RDB$SYSTEM_FLAG.NULL*/
		isc_168.isc_173 = FALSE;

		skip_init(&scan_next_attr);
		while (skip_scan(&scan_next_attr), get_attribute(&attribute, tdgbl) != att_end)
		{
			switch (attribute)
			{
			case att_type_name:
				l = GET_TEXT(/*X.RDB$TYPE_NAME*/
					     isc_168.isc_170);
				break;

			case att_type_type:
				/*X.RDB$TYPE*/
				isc_168.isc_172 = (USHORT) get_numeric(tdgbl);
				break;

			case att_type_field_name:
				GET_TEXT(/*X.RDB$FIELD_NAME*/
					 isc_168.isc_169);
				break;

			case att_type_description:
				/*X.RDB$DESCRIPTION.NULL*/
				isc_168.isc_175 = FALSE;
				get_misc_blob (tdgbl, /*X.RDB$DESCRIPTION*/
						      isc_168.isc_171, false);
				break;

			case att_type_description2:
				/*X.RDB$DESCRIPTION.NULL*/
				isc_168.isc_175 = FALSE;
				get_source_blob (tdgbl, /*X.RDB$DESCRIPTION*/
							isc_168.isc_171, false);
				break;

			case att_type_system_flag:
				/*X.RDB$SYSTEM_FLAG*/
				isc_168.isc_174 = (USHORT) get_numeric(tdgbl);
				/*X.RDB$SYSTEM_FLAG.NULL*/
				isc_168.isc_173 = FALSE;
				break;

			default:
				bad_attribute (scan_next_attr, attribute, 293);
				// msg 293 type (in RDB$TYPES)
				break;
			}
		}

		MISC_terminate (/*X.RDB$TYPE_NAME*/
				isc_168.isc_170, temp, l, sizeof(temp));
		BURP_verbose (128, SafeArg() << temp << /*X.RDB$FIELD_NAME*/
							isc_168.isc_169);
		// msg 128  restoring type %s for field %s

	/*END_STORE;*/
	   
           isc_start_and_send (isc_status, (FB_API_HANDLE*) &tdgbl->handles_get_type_req_handle1, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 80, &isc_168, (short) 0);
	   };
	/*ON_ERROR*/
	if (isc_status [1])
	   {
		general_on_error ();
	/*END_ERROR;*/
	   }
	}

	return true;
}

bool get_user_privilege(BurpGlobals* tdgbl)
{
   struct isc_154_struct {
          char  isc_155 [32];	/* RDB$RELATION_NAME */
          char  isc_156 [32];	/* RDB$GRANTOR */
          char  isc_157 [32];	/* RDB$USER */
          char  isc_158 [32];	/* RDB$FIELD_NAME */
          short isc_159;	/* gds__null_flag */
          short isc_160;	/* RDB$USER_TYPE */
          short isc_161;	/* gds__null_flag */
          short isc_162;	/* RDB$GRANT_OPTION */
          short isc_163;	/* gds__null_flag */
          short isc_164;	/* RDB$OBJECT_TYPE */
          short isc_165;	/* gds__null_flag */
          char  isc_166 [7];	/* RDB$PRIVILEGE */
   } isc_154;
/**************************************
 *
 *	g e t _ u s e r _ p r i v i l e g e
 *
 **************************************
 *
 * Functional description
 *	Get a user privilege.
 *	Get next interesting user privilege.
 *
 **************************************/
	att_type	attribute;
	scan_attr_t		scan_next_attr;
	USHORT		flags = 0;

	/*BASED_ON RDB$USER_PRIVILEGES.RDB$USER user;*/
	char
	   user[32];

	/*BASED_ON RDB$USER_PRIVILEGES.RDB$GRANTOR grantor;*/
	char
	   grantor[32];

	/*BASED_ON RDB$USER_PRIVILEGES.RDB$PRIVILEGE privilege;*/
	char
	   privilege[7];

	/*BASED_ON RDB$USER_PRIVILEGES.RDB$GRANT_OPTION grant_option*/
	short
	   grant_option
 = 0;
	/*BASED_ON RDB$USER_PRIVILEGES.RDB$RELATION_NAME relation_name;*/
	char
	   relation_name[32];

	/*BASED_ON RDB$USER_PRIVILEGES.RDB$FIELD_NAME field_name;*/
	char
	   field_name[32];

	/*BASED_ON RDB$USER_PRIVILEGES.RDB$USER_TYPE user_type;*/
	short
	   user_type;

	/*BASED_ON RDB$USER_PRIVILEGES.RDB$OBJECT_TYPE object_type;*/
	short
	   object_type;


	user_type = obj_user;
	object_type = obj_relation;

	skip_init(&scan_next_attr);
	while (skip_scan(&scan_next_attr), get_attribute(&attribute, tdgbl) != att_end)
	{
		switch (attribute)
		{
		case att_priv_user:
			// default USER_TYPE to USER
			flags |= USER_PRIV_USER;
			GET_TEXT(user);
			BURP_verbose (123, user);
			// msg 123 restoring privilege for user %s
			break;

		case att_priv_grantor:
			flags |= USER_PRIV_GRANTOR;
			GET_TEXT(grantor);
			break;

		case att_priv_privilege:
			flags |= USER_PRIV_PRIVILEGE;
			GET_TEXT(privilege);
			break;

		case att_priv_grant_option:
			flags |= USER_PRIV_GRANT_OPTION;
			grant_option = (USHORT) get_numeric(tdgbl);
			break;

		case att_priv_object_name:
			flags |= USER_PRIV_OBJECT_NAME;
			// default OBJECT_TYPE to RELATION
			GET_TEXT(relation_name);
			break;

		case att_priv_field_name:
			flags |= USER_PRIV_FIELD_NAME;
			GET_TEXT(field_name);
			break;

		case att_priv_user_type:
			flags |= USER_PRIV_USER_TYPE;
			user_type = (USHORT) get_numeric(tdgbl);
			break;

		case att_priv_obj_type:
			flags |= USER_PRIV_OBJECT_TYPE;
			object_type = (USHORT) get_numeric(tdgbl);
			break;

		default:
			bad_attribute (scan_next_attr, attribute, 105);
			// msg 105 privilege
			break;
		}
	}

	// Check if object exists
	isc_tr_handle	local_trans = 0;
	bool exists = false;
	switch (object_type)
	{
	case obj_procedure:
		{
		for (const burp_prc* proc = tdgbl->procedures; proc; proc = proc->prc_next)
			if (!strcmp(proc->prc_name, relation_name))
			{
				exists = true;
				local_trans = tdgbl->global_trans ? tdgbl->global_trans : gds_trans;
				break;
			}
		}
		break;

	case obj_relation:
		{
		for (const burp_rel* rel = tdgbl->relations; rel; rel = rel->rel_next)
			if (!strcmp(rel->rel_name, relation_name))
			{
				exists = true;
				if (rel->rel_flags & REL_view)
					local_trans = tdgbl->global_trans ? tdgbl->global_trans : gds_trans;
			break;
			}
		}
		break;

		default:
			exists = true;
			break;
	}

	if (tdgbl->RESTORE_ods <= DB_VERSION_DDL8)
	{
		// Discard roles for IB4.
		if (user_type == obj_sql_role || object_type == obj_sql_role)
			exists = false;
	}

	if (exists)
	{
		if (!local_trans)
			local_trans = gds_trans;

		/*STORE (TRANSACTION_HANDLE local_trans
				REQUEST_HANDLE tdgbl->handles_get_user_privilege_req_handle1)
			X IN RDB$USER_PRIVILEGES*/
		{
		
                if (!tdgbl->handles_get_user_privilege_req_handle1)
                   isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &tdgbl->handles_get_user_privilege_req_handle1, (short) sizeof(isc_153), (char*) isc_153);
		if (tdgbl->handles_get_user_privilege_req_handle1)
		   {

			/*X.RDB$FIELD_NAME.NULL*/
			isc_154.isc_165 = TRUE;
			/*X.RDB$OBJECT_TYPE.NULL*/
			isc_154.isc_163 = TRUE;

			if (flags & USER_PRIV_USER)
				strcpy (/*X.RDB$USER*/
					isc_154.isc_157, user);

			if (flags & USER_PRIV_GRANTOR)
				strcpy (/*X.RDB$GRANTOR*/
					isc_154.isc_156, grantor);

			if (flags & USER_PRIV_PRIVILEGE)
				strcpy (/*X.RDB$PRIVILEGE*/
					isc_154.isc_166, privilege);

			if (flags & USER_PRIV_GRANT_OPTION)
			{
				/*X.RDB$GRANT_OPTION*/
				isc_154.isc_162 = grant_option;
					if (grant_option == 0)
						/*X.RDB$GRANT_OPTION.NULL*/
						isc_154.isc_161 = TRUE;
					else
						/*X.RDB$GRANT_OPTION.NULL*/
						isc_154.isc_161 = FALSE;
			}

			if (flags & USER_PRIV_OBJECT_NAME)
				strcpy (/*X.RDB$RELATION_NAME*/
					isc_154.isc_155, relation_name);

			if (flags & USER_PRIV_FIELD_NAME)
			{
				/*X.RDB$FIELD_NAME.NULL*/
				isc_154.isc_165 = FALSE;
				strcpy (/*X.RDB$FIELD_NAME*/
					isc_154.isc_158, field_name);
			}

			// USER_TYPE & OBJECT_TYPE are fields that did not exist before
			// V4.0. So, we have to reconstruct them and initialize them to
			// reasonable values. If they existed before then user_type and
			// object_type contain the proper values. If they didn't exist
			// then user_type and object_type contain the reasonable default
			// values.

			/*X.RDB$USER_TYPE.NULL*/
			isc_154.isc_159 = FALSE;
			/*X.RDB$USER_TYPE*/
			isc_154.isc_160 = user_type;

			/*X.RDB$OBJECT_TYPE.NULL*/
			isc_154.isc_163 = FALSE;
			/*X.RDB$OBJECT_TYPE*/
			isc_154.isc_164 = object_type;



			// If OBJECT_TYPE didn't exist before and we have a field level
			// user privileges, then use obj_field instead.

			// NOTE: Scanning the V4.0 code base, obj_field has never been
			// used at all. The following code should be uncommented
			// in case we ever introduce obj_field to the picture.

/***********************************************************
			if ( !(flags & USER_PRIV_OBJECT_TYPE) )
			{
				if ( flags & USER_PRIV_FIELD_NAME )
				{
					X.RDB$OBJECT_TYPE = obj_field;
				}
			}
***********************************************************/

		/*END_STORE;*/
		   
                   isc_start_and_send (isc_status, (FB_API_HANDLE*) &tdgbl->handles_get_user_privilege_req_handle1, (FB_API_HANDLE*) &local_trans, (short) 0, (short) 149, &isc_154, (short) 0);
		   };
		/*ON_ERROR*/
		if (isc_status [1])
		   {
			general_on_error ();
		/*END_ERROR;*/
		   }
		}
	}

	return true;
}

bool get_view(BurpGlobals*	tdgbl,
			  burp_rel*		relation)
{
   struct isc_148_struct {
          char  isc_149 [256];	/* RDB$CONTEXT_NAME */
          char  isc_150 [32];	/* RDB$RELATION_NAME */
          char  isc_151 [32];	/* RDB$VIEW_NAME */
          short isc_152;	/* RDB$VIEW_CONTEXT */
   } isc_148;
/**************************************
 *
 *	g e t _ v i e w
 *
 **************************************
 *
 * Functional description
 *	Store a record in RDB$VIEW_RELATIONS.
 *
 **************************************/
	att_type	attribute;
	scan_attr_t		scan_next_attr;

	// If there is a global transaction then use it

	isc_tr_handle local_trans = tdgbl->global_trans ? tdgbl->global_trans : gds_trans;

	/*STORE (TRANSACTION_HANDLE local_trans
			REQUEST_HANDLE tdgbl->handles_get_view_req_handle1)
		X IN RDB$VIEW_RELATIONS*/
	{
	
        if (!tdgbl->handles_get_view_req_handle1)
           isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &tdgbl->handles_get_view_req_handle1, (short) sizeof(isc_147), (char*) isc_147);
	if (tdgbl->handles_get_view_req_handle1)
	   {
		strcpy (/*X.RDB$VIEW_NAME*/
			isc_148.isc_151, relation->rel_name);

		skip_init(&scan_next_attr);
		while (skip_scan(&scan_next_attr), get_attribute(&attribute, tdgbl) != att_end)
		{
			switch (attribute)
			{
			case att_view_relation_name:
				GET_TEXT(/*X.RDB$RELATION_NAME*/
					 isc_148.isc_150);
				break;

			case att_view_context_name:
				GET_TEXT(/*X.RDB$CONTEXT_NAME*/
					 isc_148.isc_149);
				if (tdgbl->RESTORE_ods < DB_VERSION_DDL11_2) {
					/*X.RDB$CONTEXT_NAME*/
					isc_148.isc_149[31] = 0;
				}
				break;

			case att_view_context_id:
				/*X.RDB$VIEW_CONTEXT*/
				isc_148.isc_152 = (USHORT) get_numeric(tdgbl);
				break;

			default:
				bad_attribute (scan_next_attr, attribute, 140);
				// msg 140 view
				break;
			}
		}
	/*END_STORE;*/
	   
           isc_start_and_send (isc_status, (FB_API_HANDLE*) &tdgbl->handles_get_view_req_handle1, (FB_API_HANDLE*) &local_trans, (short) 0, (short) 322, &isc_148, (short) 0);
	   };
	/*ON_ERROR*/
	if (isc_status [1])
	   {
		general_on_error ();
	/*END_ERROR;*/
	   }
	}

	return true;
}

void ignore_array(BurpGlobals*	tdgbl,
				  burp_rel*		relation)
{
/**************************************
 *
 *	i g n o r e _ a r r a y
 *
 **************************************
 *
 * Functional description
 *	Ignore data from input file, like a
 *	dummy get_array().
 *
 **************************************/
	burp_fld* field = NULL;
	att_type attribute;
	SLONG* range;
	const SLONG* end_ranges;
	USHORT field_number;
	scan_attr_t scan_next_attr;

	// Pick up attributes

	skip_init(&scan_next_attr);
	while (skip_scan(&scan_next_attr), get_attribute(&attribute, tdgbl) != att_blob_data)
	{
		switch (attribute)
		{
		case att_blob_field_number:
			field_number = (USHORT) get_numeric(tdgbl);
			for (field = relation->rel_fields; field; field = field->fld_next) {
				if (field->fld_number == field_number)
					break;
			}
			if (!field)
				BURP_error_redirect (NULL, 36);
				// msg 36 Can't find field for blob
			break;

		case att_array_dimensions:
			field->fld_dimensions = (SSHORT) get_numeric(tdgbl);
			end_ranges = field->fld_ranges + 2 * field->fld_dimensions;
			for (range = field->fld_ranges; range < end_ranges; range += 2)
			{
				if (get_attribute(&attribute, tdgbl) != att_array_range_low)
					bad_attribute (scan_next_attr, attribute, 58);
					// msg 58 array
				else
					range[0] = get_numeric(tdgbl);
				if (get_attribute(&attribute, tdgbl) != att_array_range_high)
					bad_attribute (scan_next_attr, attribute, 58);
					// msg 58 array
				else
					range[1] = get_numeric(tdgbl);
			}
			break;

		default:
			bad_attribute (scan_next_attr, attribute, 58);
			// msg 58 array
			break;
		}
	}

	SLONG length = get(tdgbl);
	length |= get(tdgbl) << 8;
	length |= get(tdgbl) << 16;
	length |= get(tdgbl) << 24;

	SLONG lcount = 0;
	if (tdgbl->gbl_sw_transportable)
	{
		if (get_attribute(&attribute, tdgbl) != att_xdr_array)
			BURP_error_redirect (NULL, 55);
			// msg 55 Expected XDR record length
		else
		{
			lcount = get(tdgbl);
			lcount |= get(tdgbl) << 8;
			lcount |= get(tdgbl) << 16;
			lcount |= get(tdgbl) << 24;
		}
	}
	else
	{
		lcount = length;
	}

	if (lcount)
		get_skip(tdgbl, lcount);
}

void ignore_blob(BurpGlobals* tdgbl)
{
/**************************************
 *
 *	i g n o r e _ b l o b
 *
 **************************************
 *
 * Functional description
 *	Skip over blob data records.
 *
 **************************************/
	att_type	attribute;
	scan_attr_t		scan_next_attr;

	// Pick up attributes

	SLONG segments = 0;

	skip_init(&scan_next_attr);
	while (skip_scan(&scan_next_attr), get_attribute(&attribute, tdgbl) != att_blob_data)
	{
		switch (attribute)
		{
		case att_blob_field_number:
			get_numeric(tdgbl);
			break;

		case att_blob_max_segment:
			get_numeric(tdgbl);
			break;

		case att_blob_number_segments:
			segments = get_numeric(tdgbl);
			break;

		case att_blob_type:
			get_numeric(tdgbl);
			break;

		default:
			bad_attribute (scan_next_attr, attribute, 64);
			// msg 64 blob
			break;
		}
	}

	// Eat up blob segments

	while (--segments >= 0)
	{
		USHORT length = get(tdgbl);
		length |= get(tdgbl) << 8;
		if (length)
			get_skip(tdgbl, length);
	}
}

rec_type ignore_data(BurpGlobals*	tdgbl,
					 burp_rel*		relation)
{
/**************************************
 *
 *	i g n o r e _ d a t a
 *
 **************************************
 *
 * Functional description
 *	Ignore data records for a relation.
 *
 **************************************/
	ULONG records = 0;
	rec_type record;

	while (true)
	{
		if (get(tdgbl) != att_data_length)
			BURP_error_redirect (NULL, 39);
			// msg 39 expected record length
		USHORT l = (USHORT) get_numeric(tdgbl);
		if (tdgbl->gbl_sw_transportable)
		{
			if (get(tdgbl) != att_xdr_length)
				BURP_error_redirect (NULL, 55);
				// msg 55 Expected XDR record length
			else
				l = (USHORT) get_numeric(tdgbl);
		}
		if (get(tdgbl) != att_data_data)
			BURP_error_redirect (NULL, 41);
			// msg 41 expected data attribute
		if (l) {
			if (tdgbl->gbl_sw_compress)
			{
				UCHAR* buffer = (UCHAR*) BURP_alloc (l);
				decompress (tdgbl, buffer, l);
				BURP_free (buffer);
			}
			else
				get_skip(tdgbl, l);
		}
		++records;

		while (get_record(&record, tdgbl))
		{
			if (record == rec_blob)
				ignore_blob(tdgbl);
			else if (record == rec_array)
				ignore_array (tdgbl, relation);
			else
				break;
		}
		if (record != rec_data)
			break;
	}

	BURP_verbose (106, SafeArg() << records);
	// msg 106 %ld records ignored

	return record;
}

void realign(BurpGlobals*		tdgbl,
			 UCHAR*				buffer,
			 const burp_rel*	relation)
{
/**************************************
 *
 *	r e a l i g n
 *
 **************************************
 *
 * Functional description
 *	Miserable input record is misaligned.
 *	Shuffle fields around.  N.B. this one
 *	only works if the old buffer is longer
 *	than the new.
 *
 **************************************/
	UCHAR* p = 0;
	const UCHAR* q = 0;

	for (const burp_fld* field = relation->rel_fields; field; field = field->fld_next)
	{
		if (field->fld_flags & FLD_computed)
			continue;

		p = buffer + field->fld_offset;
		q = buffer + field->fld_old_offset;
		USHORT l = field->fld_length;

		// CVC: This code assumes fld_offset < fld_old_offset,
		// why not use memmove() instead?

		// Beware of overlaps here - don't use memcpy
		while (l--) {
			*p++ = *q++;
		}

		if (field->fld_type == blr_varying)
		{
			*p++ = *q++;
			*p++ = *q++;
		}
	}

	// If this is format version 2 or greater, build fields for null flags

	if (tdgbl->RESTORE_format >= 2)
	{
		for (const burp_fld* field = relation->rel_fields; field; field = field->fld_next)
		{
			if (field->fld_flags & FLD_computed)
				continue;
			p = buffer + FB_ALIGN(p - buffer, sizeof(SSHORT));
			q = buffer + FB_ALIGN(q - buffer, sizeof(SSHORT));
			*p++ = *q++;
			*p++ = *q++;
		}
	}
}

#ifdef sparc
USHORT recompute_length(BurpGlobals*	tdgbl,
						burp_rel*		relation)
{
/**************************************
 *
 *	r e c o m p u t e _ l e n g t h
 *
 **************************************
 *
 * Functional description
 *	Recompute length of a record using an old
 *	alignment if there is one.  At the moment,
 *	only SPARC has one.
 *
 **************************************/

	ULONG	offset = 0; // there was garbage, possibly nobody uses sparc define?
	const SSHORT* alignments = old_sparcs;

	for (burp_fld* field = relation->rel_fields; field; field = field->fld_next)
	{
		if (field->fld_flags & FLD_computed)
			continue;
		ULONG length = field->fld_length;
		// ULONG alignment = 4; useless, see assignment below

		// arrays are of various fld_types but are really blobs

		ULONG dtype = field->fld_type;

		if (field->fld_flags & FLD_array)
		{
			dtype = blr_blob;
			length = 8;
		}

		const ULONG alignment = alignments[gds_cvt_blr_dtype[field->fld_type]];
		if (dtype == blr_varying)
			length += sizeof(USHORT);

		if (alignment)
			offset = FB_ALIGN(offset, alignment);
		field->fld_old_offset = offset;
		offset += length;
	}

	// If this is format version 2, build fields for null flags

	if (tdgbl->RESTORE_format >= 2)
	{
		for (const burp_fld* field = relation->rel_fields; field; field = field->fld_next)
		{
			if (field->fld_flags & FLD_computed)
				continue;
			offset = FB_ALIGN(offset, sizeof(SSHORT));
			offset += sizeof(SSHORT);
		}
	}

	return offset;
}
#endif

bool restore(BurpGlobals*	tdgbl,
			 const TEXT*	file_name,
			 const TEXT*	database_name)
{
   struct isc_99_struct {
          short isc_100;	/* isc_utility */
   } isc_99;
   struct isc_96_struct {
          double isc_97;	/* RDB$STATISTICS */
          short isc_98;	/* gds__null_flag */
   } isc_96;
   struct isc_92_struct {
          double isc_93;	/* RDB$STATISTICS */
          short isc_94;	/* isc_utility */
          short isc_95;	/* gds__null_flag */
   } isc_92;
   struct isc_106_struct {
          short isc_107;	/* isc_utility */
   } isc_106;
   struct isc_104_struct {
          short isc_105;	/* isc_utility */
   } isc_104;
   struct isc_102_struct {
          short isc_103;	/* isc_utility */
   } isc_102;
   struct isc_117_struct {
          short isc_118;	/* isc_utility */
   } isc_117;
   struct isc_114_struct {
          char  isc_115 [32];	/* RDB$DEFAULT_COLLATE_NAME */
          short isc_116;	/* gds__null_flag */
   } isc_114;
   struct isc_109_struct {
          char  isc_110 [32];	/* RDB$DEFAULT_COLLATE_NAME */
          char  isc_111 [32];	/* RDB$CHARACTER_SET_NAME */
          short isc_112;	/* isc_utility */
          short isc_113;	/* gds__null_flag */
   } isc_109;
   struct isc_122_struct {
          short isc_123;	/* isc_utility */
          short isc_124;	/* RDB$CHARACTER_SET_ID */
   } isc_122;
   struct isc_120_struct {
          char  isc_121 [32];	/* RDB$CHARACTER_SET_NAME */
   } isc_120;
   struct isc_128_struct {
          short isc_129;	/* isc_utility */
          short isc_130;	/* RDB$CHARACTER_SET_ID */
   } isc_128;
   struct isc_126_struct {
          char  isc_127 [32];	/* RDB$CHARACTER_SET_NAME */
   } isc_126;
   struct isc_137_struct {
          short isc_138;	/* isc_utility */
   } isc_137;
   struct isc_135_struct {
          char  isc_136 [32];	/* RDB$CHARACTER_SET_NAME */
   } isc_135;
   struct isc_132_struct {
          char  isc_133 [32];	/* RDB$CHARACTER_SET_NAME */
          short isc_134;	/* isc_utility */
   } isc_132;
   struct isc_145_struct {
          short isc_146;	/* isc_utility */
   } isc_145;
   struct isc_143_struct {
          ISC_QUAD isc_144;	/* RDB$DESCRIPTION */
   } isc_143;
   struct isc_140_struct {
          ISC_QUAD isc_141;	/* RDB$DESCRIPTION */
          short isc_142;	/* isc_utility */
   } isc_140;
/**************************************
 *
 *	r e s t o r e
 *
 **************************************
 *
 * Functional description
 *	Perform the body of restore.
 *
 **************************************/

	// Read burp record first

	MVOL_init_read (file_name, &tdgbl->RESTORE_format, &tdgbl->io_cnt, &tdgbl->io_ptr);

	if (tdgbl->gbl_sw_transportable)
		BURP_verbose (133);
		// msg 133 transportable backup -- data in XDR format
	if (tdgbl->gbl_sw_compress)
		BURP_verbose (61);
		// msg 61 backup file is compressed


	// restore only from those backup files created by current or previous GBAK

	if (tdgbl->RESTORE_format < 1 || tdgbl->RESTORE_format > ATT_BACKUP_FORMAT)
	{
		BURP_error(44, true, SafeArg() << tdgbl->RESTORE_format);
		// msg 44 Expected backup version 1..8.  Found %ld
	}

	create_database(tdgbl, database_name);

	/*EXEC SQL SET TRANSACTION NO_AUTO_UNDO;*/
	{
	isc_start_transaction (isc_status, (FB_API_HANDLE*) &gds_trans, (short) 1, &DB, (short) 5, isc_tpb_21);
	SQLCODE = isc_sqlcode(isc_status);
	}
	if (gds_status[1])
		/*EXEC SQL SET TRANSACTION;*/
		{
		isc_start_transaction (isc_status, (FB_API_HANDLE*) &gds_trans, (short) 1, &DB, (short) 4, isc_tpb_22);
		SQLCODE = isc_sqlcode(isc_status);
		}

	// For V4.0, start a read commited transaction.  This will be used
	// to create blobs for global fields and update the record in the
	// RDB$FIELDS table.

	/*EXEC SQL SET TRANSACTION NAME tdgbl->global_trans ISOLATION LEVEL READ COMMITTED;*/
	{
	isc_start_transaction (isc_status, (FB_API_HANDLE*) &tdgbl->global_trans, (short) 1, &DB, (short) 5, isc_tpb_23);
	SQLCODE = isc_sqlcode(isc_status);
	}

	check_db_version(tdgbl);
	if (tdgbl->RESTORE_ods < DB_VERSION_OLDEST_SUPPORTED)
	{
		BURP_error(51, true, SafeArg() << tdgbl->RESTORE_ods);
		// msg 51 database format %ld is too old to restore to
	}

	BURP_verbose (129);
	// msg 129 started transaction

	att_type	attribute;
	isc_req_handle  req_handle2 = 0, req_handle3 = 0;

	while (get_attribute(&attribute, tdgbl) != att_end)
	{
		switch (attribute)
		{
		case att_database_security_class:
			// Instead of updating the security class in RDB$DATABASE,
			// just store the value in tdgbl. It will be updated at
			// the very end to prevent security class validation
			// failures during change table ownership operation
			GET_TEXT(tdgbl->database_security_class);
			break;

		case att_database_description:
		case att_database_description2:
			/*FOR (REQUEST_HANDLE req_handle2)
				X IN RDB$DATABASE*/
			{
                        if (!req_handle2)
                           isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &req_handle2, (short) sizeof(isc_139), (char*) isc_139);
			if (req_handle2)
			   {
                           isc_start_request (isc_status, (FB_API_HANDLE*) &req_handle2, (FB_API_HANDLE*) &gds_trans, (short) 0);
			   }
			if (!isc_status [1]) {
			while (1)
			   {
                           isc_receive (isc_status, (FB_API_HANDLE*) &req_handle2, (short) 0, (short) 10, &isc_140, (short) 0);
			   if (!isc_140.isc_142 || isc_status [1]) break;
				/*MODIFY X USING*/
				{
					if (attribute == att_database_description2)
						get_source_blob (tdgbl, /*X.RDB$DESCRIPTION*/
									isc_140.isc_141, false);
					else
						get_misc_blob (tdgbl, /*X.RDB$DESCRIPTION*/
								      isc_140.isc_141, false);
				/*END_MODIFY;*/
				isc_143.isc_144 = isc_140.isc_141;
                                isc_send (isc_status, (FB_API_HANDLE*) &req_handle2, (short) 1, (short) 8, &isc_143, (short) 0);;
				/*ON_ERROR*/
				if (isc_status [1])
				   {
					general_on_error ();
				/*END_ERROR;*/
				   }
				}
			/*END_FOR;*/
                           isc_send (isc_status, (FB_API_HANDLE*) &req_handle2, (short) 2, (short) 2, &isc_145, (short) 0);
			   }
			   };
			/*ON_ERROR*/
			if (isc_status [1])
			   {
				general_on_error ();
			/*END_ERROR;*/
			   }
			}
			break;

		case att_database_dfl_charset:
			/*FOR (REQUEST_HANDLE req_handle3)
				X IN RDB$DATABASE*/
			{
                        if (!req_handle3)
                           isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &req_handle3, (short) sizeof(isc_131), (char*) isc_131);
			if (req_handle3)
			   {
                           isc_start_request (isc_status, (FB_API_HANDLE*) &req_handle3, (FB_API_HANDLE*) &gds_trans, (short) 0);
			   }
			if (!isc_status [1]) {
			while (1)
			   {
                           isc_receive (isc_status, (FB_API_HANDLE*) &req_handle3, (short) 0, (short) 34, &isc_132, (short) 0);
			   if (!isc_132.isc_134 || isc_status [1]) break;
				/*MODIFY X USING*/
				{
					GET_TEXT(/*X.RDB$CHARACTER_SET_NAME*/
						 isc_132.isc_133);
				/*END_MODIFY;*/
				isc_ftof (isc_132.isc_133, 32, isc_135.isc_136, 32);
                                isc_send (isc_status, (FB_API_HANDLE*) &req_handle3, (short) 1, (short) 32, &isc_135, (short) 0);;
				/*ON_ERROR*/
				if (isc_status [1])
				   {
					general_on_error ();
				/*END_ERROR;*/
				   }
				}
			/*END_FOR;*/
                           isc_send (isc_status, (FB_API_HANDLE*) &req_handle3, (short) 2, (short) 2, &isc_137, (short) 0);
			   }
			   };
			/*ON_ERROR*/
			if (isc_status [1])
			   {
				general_on_error ();
			/*END_ERROR;*/
			   }
			}
			break;

		default:
			{
			SSHORT l = get(tdgbl);
			if (l)
				get_skip(tdgbl, l);
			break;
			}
		}
	}

	MISC_release_request_silent(req_handle2);
	MISC_release_request_silent(req_handle3);

	if (tdgbl->gbl_sw_fix_fss_data)
	{
		bool found = false;
		Firebird::string name = tdgbl->gbl_sw_fix_fss_data;
		name.upper();

		req_handle3 = 0;

		/*FOR (REQUEST_HANDLE req_handle3)
			X IN RDB$CHARACTER_SETS
			WITH X.RDB$CHARACTER_SET_NAME EQ name.c_str()*/
		{
                if (!req_handle3)
                   isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &req_handle3, (short) sizeof(isc_125), (char*) isc_125);
		isc_vtov ((const char*) name.c_str(), (char*) isc_126.isc_127, 32);
		if (req_handle3)
		   {
                   isc_start_and_send (isc_status, (FB_API_HANDLE*) &req_handle3, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 32, &isc_126, (short) 0);
		   }
		if (!isc_status [1]) {
		while (1)
		   {
                   isc_receive (isc_status, (FB_API_HANDLE*) &req_handle3, (short) 1, (short) 4, &isc_128, (short) 0);
		   if (!isc_128.isc_129 || isc_status [1]) break;

			tdgbl->gbl_sw_fix_fss_data_id = /*X.RDB$CHARACTER_SET_ID*/
							isc_128.isc_130;
			found = true;

		/*END_FOR;*/
		   }
		   };
		/*ON_ERROR*/
		if (isc_status [1])
		   {
			general_on_error ();
		/*END_ERROR;*/
		   }
		}

		MISC_release_request_silent(req_handle3);

		if (!found)
			BURP_error(305, true, SafeArg() << tdgbl->gbl_sw_fix_fss_data);
	}

	if (tdgbl->gbl_sw_fix_fss_metadata)
	{
		bool found = false;
		Firebird::string name = tdgbl->gbl_sw_fix_fss_metadata;
		name.upper();

		req_handle3 = 0;

		/*FOR (REQUEST_HANDLE req_handle3)
			X IN RDB$CHARACTER_SETS
			WITH X.RDB$CHARACTER_SET_NAME EQ name.c_str()*/
		{
                if (!req_handle3)
                   isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &req_handle3, (short) sizeof(isc_119), (char*) isc_119);
		isc_vtov ((const char*) name.c_str(), (char*) isc_120.isc_121, 32);
		if (req_handle3)
		   {
                   isc_start_and_send (isc_status, (FB_API_HANDLE*) &req_handle3, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 32, &isc_120, (short) 0);
		   }
		if (!isc_status [1]) {
		while (1)
		   {
                   isc_receive (isc_status, (FB_API_HANDLE*) &req_handle3, (short) 1, (short) 4, &isc_122, (short) 0);
		   if (!isc_122.isc_123 || isc_status [1]) break;

			tdgbl->gbl_sw_fix_fss_metadata_id = /*X.RDB$CHARACTER_SET_ID*/
							    isc_122.isc_124;
			found = true;

		/*END_FOR;*/
		   }
		   };
		/*ON_ERROR*/
		if (isc_status [1])
		   {
			general_on_error ();
		/*END_ERROR;*/
		   }
		}

		MISC_release_request_silent(req_handle3);

		if (!found)
			BURP_error(305, true, SafeArg() << tdgbl->gbl_sw_fix_fss_metadata);
	}

	// If this should be a multi-file database, add the files

	if (tdgbl->gbl_sw_files && tdgbl->gbl_sw_files->fil_next)
		add_files(tdgbl, database_name);

	// Get global fields and relations

	bool flag_norel = true;	// To fix bug 10098
	bool flag = false;
	rec_type record;

	while (get_record(&record, tdgbl) != rec_end)
	{
		switch (record)
		{
		case rec_charset:
			if (!get_character_set(tdgbl))
				return false;
			flag = true;
			break;

		case rec_collation:
			if (!get_collation(tdgbl))
				return false;
			flag = true;
			break;

		case rec_chk_constraint:
			if (!get_chk_constraint(tdgbl))
				return false;
			flag = true;
			break;

		case rec_global_field:
			if (!get_global_field(tdgbl))
				return false;
			flag = true;
			break;

		case rec_field_dimensions:
			if (!get_field_dimensions(tdgbl))
				return false;
			flag = true;
			break;

		case rec_relation:
			if (!get_relation(tdgbl))
				return false;
			flag = true;
			flag_norel = false;
			break;

		case rec_ref_constraint:
			if (!get_ref_constraint(tdgbl))
				return false;
			flag = true;
			break;

		case rec_rel_constraint:
			if (!get_rel_constraint(tdgbl))
				return false;
			flag = true;
			break;

		case rec_function:
			if (!get_function(tdgbl))
				return false;
			flag = true;
			break;

		case rec_procedure:
			if (!get_procedure(tdgbl))
				return false;
			flag = true;
			break;

		case rec_exception:
			if (!get_exception(tdgbl))
				return false;
			flag = true;
			break;

		case rec_system_type:  // rdb$types
			if (!get_type(tdgbl))
				return false;
			flag = true;
			break;

		case rec_filter:  // rdb$filters
			if (!get_filter(tdgbl))
				return false;
			flag = true;
			break;

		case rec_generator:
			if (!get_generator(tdgbl))
				return false;
			flag = true;
			break;

		case rec_relation_data:
			if (flag)
			{
				BURP_verbose (68);
				// msg 68 committing meta data
				/*COMMIT;*/
				{
				isc_commit_transaction (isc_status, (FB_API_HANDLE*) &gds_trans);;
				/*ON_ERROR*/
				if (isc_status [1])
				   {
					general_on_error ();
				/*END_ERROR;*/
				   }
				}
				/*EXEC SQL SET TRANSACTION NO_AUTO_UNDO;*/
				{
				isc_start_transaction (isc_status, (FB_API_HANDLE*) &gds_trans, (short) 1, &DB, (short) 5, isc_tpb_24);
				SQLCODE = isc_sqlcode(isc_status);
				}
				if (gds_status[1])
					/*EXEC SQL SET TRANSACTION;*/
					{
					isc_start_transaction (isc_status, (FB_API_HANDLE*) &gds_trans, (short) 1, &DB, (short) 4, isc_tpb_25);
					SQLCODE = isc_sqlcode(isc_status);
					}
				flag = false;
			}
			if (!get_relation_data(tdgbl))
				return false;
			break;

		case rec_trigger:  // new trigger type
			if (!get_trigger(tdgbl))
				return false;
			flag = true;
			break;

		case rec_trigger_message:
			if (!get_trigger_message(tdgbl))
				return false;
			flag = true;
			break;

		case rec_user_privilege:
			if (!get_user_privilege(tdgbl))
				return false;
			flag = true;
			break;

		case rec_security_class:
			if (!get_security_class(tdgbl))
				return false;
			flag = true;
			break;

		case rec_files:
			if (!get_files(tdgbl))
				return false;
			flag = true;
			break;

		case rec_sql_roles:
			if (!get_sql_roles(tdgbl))
				return false;
			flag = true;
			break;

		case rec_mapping:
			if (!get_mapping(tdgbl))
				return false;
			flag = true;
			break;

		default:
			BURP_error(43, true, SafeArg() << record);
			// msg 43 don't recognize record type %ld
			break;
		}
	}

	if (tdgbl->defaultCollations.getCount() > 0)
	{
		isc_req_handle req_handle4 = 0;

		/*FOR (REQUEST_HANDLE req_handle4)
			CS IN RDB$CHARACTER_SETS*/
		{
                if (!req_handle4)
                   isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &req_handle4, (short) sizeof(isc_108), (char*) isc_108);
		if (req_handle4)
		   {
                   isc_start_request (isc_status, (FB_API_HANDLE*) &req_handle4, (FB_API_HANDLE*) &gds_trans, (short) 0);
		   }
		if (!isc_status [1]) {
		while (1)
		   {
                   isc_receive (isc_status, (FB_API_HANDLE*) &req_handle4, (short) 0, (short) 68, &isc_109, (short) 0);
		   if (!isc_109.isc_112 || isc_status [1]) break;

			for (size_t i = 0; i < tdgbl->defaultCollations.getCount(); ++i)
			{
				if (tdgbl->defaultCollations[i].first == /*CS.RDB$CHARACTER_SET_NAME*/
									 isc_109.isc_111)
				{
					/*MODIFY CS*/
					{;
						/*CS.RDB$DEFAULT_COLLATE_NAME.NULL*/
						isc_109.isc_113 = FALSE;
						strcpy(/*CS.RDB$DEFAULT_COLLATE_NAME*/
						       isc_109.isc_110,
							tdgbl->defaultCollations[i].second.c_str());
					/*END_MODIFY;*/
					isc_ftof (isc_109.isc_110, 32, isc_114.isc_115, 32);
					isc_114.isc_116 = isc_109.isc_113;
                                        isc_send (isc_status, (FB_API_HANDLE*) &req_handle4, (short) 1, (short) 34, &isc_114, (short) 0);;
					/*ON_ERROR*/
					if (isc_status [1])
					   {
						general_on_error ();
					/*END_ERROR;*/
					   }
					}
				}
			}
		/*END_FOR;*/
                   isc_send (isc_status, (FB_API_HANDLE*) &req_handle4, (short) 2, (short) 2, &isc_117, (short) 0);
		   }
		   };
		/*ON_ERROR*/
		if (isc_status [1])
		   {
			general_on_error ();
		/*END_ERROR;*/
		   }
		}

		MISC_release_request_silent(req_handle4);
	}

	// This piece of code is to fix bug 10098: restore of database with
	// only domains and no relations aborts with the message ERROR: deadlock
	// This is because insertion of domains into RDB$FIELDS is happening in
	// the default transaction, whereas updation of RDB$FIELDS to add
	// constraints to the domains is done in tdgbl->global_trans. In case of
	// no relations, no COMMIT of default transaction occurs till this point
	// because of which rows in RDB$FIELDS for domains are still locked by
	// default transaction. The below code COMMITs the default transaction
	// in that particular situation

	if (flag_norel)
	{
		/*COMMIT;*/
		{
		isc_commit_transaction (isc_status, (FB_API_HANDLE*) &gds_trans);;
		/*ON_ERROR*/
		if (isc_status [1])
		   {
			general_on_error ();
		/*END_ERROR;*/
		   }
		}
		/*EXEC SQL SET TRANSACTION NO_AUTO_UNDO;*/
		{
		isc_start_transaction (isc_status, (FB_API_HANDLE*) &gds_trans, (short) 1, &DB, (short) 5, isc_tpb_26);
		SQLCODE = isc_sqlcode(isc_status);
		}
		if (gds_status[1])
			/*EXEC SQL SET TRANSACTION;*/
			{
			isc_start_transaction (isc_status, (FB_API_HANDLE*) &gds_trans, (short) 1, &DB, (short) 4, isc_tpb_27);
			SQLCODE = isc_sqlcode(isc_status);
			}
	}

	// put validation clauses for global fields

	update_global_field(tdgbl);

	// Purge shadow metadata if necessary

	if (tdgbl->gbl_sw_kill)
	{
		isc_req_handle req_handle4 = 0;

		/*FOR (REQUEST_HANDLE req_handle4)
			FIL IN RDB$FILES WITH FIL.RDB$SHADOW_NUMBER NOT MISSING
			AND FIL.RDB$SHADOW_NUMBER NE 0*/
		{
                if (!req_handle4)
                   isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &req_handle4, (short) sizeof(isc_101), (char*) isc_101);
		if (req_handle4)
		   {
                   isc_start_request (isc_status, (FB_API_HANDLE*) &req_handle4, (FB_API_HANDLE*) &gds_trans, (short) 0);
		   }
		if (!isc_status [1]) {
		while (1)
		   {
                   isc_receive (isc_status, (FB_API_HANDLE*) &req_handle4, (short) 0, (short) 2, &isc_102, (short) 0);
		   if (!isc_102.isc_103 || isc_status [1]) break;
		/*ERASE FIL;*/
		{
                isc_send (isc_status, (FB_API_HANDLE*) &req_handle4, (short) 1, (short) 2, &isc_104, (short) 0);
		/*ON_ERROR*/
		if (isc_status [1])
		   {
			general_on_error ();
		/*END_ERROR;*/
		   }
		}
		/*END_FOR;*/
                   isc_send (isc_status, (FB_API_HANDLE*) &req_handle4, (short) 2, (short) 2, &isc_106, (short) 0);
		   }
		   };
		/*ON_ERROR*/
		if (isc_status [1])
		   {
			general_on_error ();
		/*END_ERROR;*/
		   }
		}

		MISC_release_request_silent(req_handle4);
	}

	// update statistics for system indices
	isc_req_handle req_handle5 = 0;

	/*FOR (REQUEST_HANDLE req_handle5)
		IND IN RDB$INDICES WITH IND.RDB$SYSTEM_FLAG EQ 1*/
	{
        if (!req_handle5)
           isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &req_handle5, (short) sizeof(isc_91), (char*) isc_91);
	if (req_handle5)
	   {
           isc_start_request (isc_status, (FB_API_HANDLE*) &req_handle5, (FB_API_HANDLE*) &gds_trans, (short) 0);
	   }
	if (!isc_status [1]) {
	while (1)
	   {
           isc_receive (isc_status, (FB_API_HANDLE*) &req_handle5, (short) 0, (short) 12, &isc_92, (short) 0);
	   if (!isc_92.isc_94 || isc_status [1]) break;
		/*MODIFY IND*/
		{
			/*IND.RDB$STATISTICS.NULL*/
			isc_92.isc_95 = FALSE;
			/*IND.RDB$STATISTICS*/
			isc_92.isc_93 = -1;
		/*END_MODIFY*/
		isc_96.isc_97 = isc_92.isc_93;
		isc_96.isc_98 = isc_92.isc_95;
                isc_send (isc_status, (FB_API_HANDLE*) &req_handle5, (short) 1, (short) 10, &isc_96, (short) 0);;
		/*ON_ERROR*/
		if (isc_status [1])
		   {
			general_on_error ();
		/*END_ERROR;*/
		   }
		}
	/*END_FOR;*/
           isc_send (isc_status, (FB_API_HANDLE*) &req_handle5, (short) 2, (short) 2, &isc_99, (short) 0);
	   }
	   };
	/*ON_ERROR*/
	if (isc_status [1])
	   {
		general_on_error ();
	/*END_ERROR;*/
	   }
	}

	MISC_release_request_silent(req_handle5);

	return true;
}

void restore_security_class(BurpGlobals*	tdgbl,
							const TEXT*		owner_nm,
							const TEXT*		sec_class_nm)
{
   struct isc_89_struct {
          short isc_90;	/* isc_utility */
   } isc_89;
   struct isc_87_struct {
          ISC_QUAD isc_88;	/* RDB$ACL */
   } isc_87;
   struct isc_84_struct {
          ISC_QUAD isc_85;	/* RDB$ACL */
          short isc_86;	/* isc_utility */
   } isc_84;
   struct isc_82_struct {
          char  isc_83 [32];	/* RDB$SECURITY_CLASS */
   } isc_82;
/**************************************
 *
 *	r e s t o r e _ s e c u r i t y _ c l a s s
 *
 **************************************
 *
 * Functional description
 *	restore the ownership of the relation in the ACL list
 *
 **************************************/
	isc_req_handle  req_handle2 = 0;

	//isc_tr_handle local_trans = gds_trans;

	/*FOR (REQUEST_HANDLE req_handle2)
		X IN RDB$SECURITY_CLASSES WITH X.RDB$SECURITY_CLASS EQ sec_class_nm*/
	{
        if (!req_handle2)
           isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &req_handle2, (short) sizeof(isc_81), (char*) isc_81);
	isc_vtov ((const char*) sec_class_nm, (char*) isc_82.isc_83, 32);
	if (req_handle2)
	   {
           isc_start_and_send (isc_status, (FB_API_HANDLE*) &req_handle2, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 32, &isc_82, (short) 0);
	   }
	if (!isc_status [1]) {
	while (1)
	   {
           isc_receive (isc_status, (FB_API_HANDLE*) &req_handle2, (short) 1, (short) 10, &isc_84, (short) 0);
	   if (!isc_84.isc_86 || isc_status [1]) break;

		ISC_QUAD new_blob_id;
		new_blob_id.gds_quad_high = 0;
		new_blob_id.gds_quad_low  = 0;
		get_acl(tdgbl, owner_nm, &/*X.RDB$ACL*/
					  isc_84.isc_85, &new_blob_id);

		/*MODIFY X*/
		{;
			memcpy(&/*X.RDB$ACL*/
				isc_84.isc_85, &new_blob_id, sizeof(ISC_QUAD));
		/*END_MODIFY;*/
		isc_87.isc_88 = isc_84.isc_85;
                isc_send (isc_status, (FB_API_HANDLE*) &req_handle2, (short) 2, (short) 8, &isc_87, (short) 0);;
		/*ON_ERROR*/
		if (isc_status [1])
		   {
			MISC_release_request_silent(req_handle2);
			general_on_error ();
		/*END_ERROR;*/
		   }
		}

	/*END_FOR;*/
           isc_send (isc_status, (FB_API_HANDLE*) &req_handle2, (short) 3, (short) 2, &isc_89, (short) 0);
	   }
	   };

	/*ON_ERROR*/
	if (isc_status [1])
	   {
		MISC_release_request_silent(req_handle2);
		general_on_error ();
	/*END_ERROR;*/
	   }
	}

	MISC_release_request_silent(req_handle2);
}


USHORT get_view_base_relation_count(BurpGlobals*	tdgbl,
									const TEXT*		current_view_name,
									USHORT			depth)
{
   struct isc_76_struct {
          char  isc_77 [32];	/* RDB$RELATION_NAME */
          ISC_QUAD isc_78;	/* RDB$VIEW_BLR */
          short isc_79;	/* isc_utility */
          short isc_80;	/* gds__null_flag */
   } isc_76;
   struct isc_74_struct {
          char  isc_75 [32];	/* RDB$VIEW_NAME */
   } isc_74;
/**************************************
 *
 *	g e t _ v i e w _ b a s e _ r e l a t i o n _ c o u n t
 *
 **************************************
 *
 * Functional description
 *	Return the number of base relations
 *  (tables) from a view. When a view is
 *  referenced in the view this function
 *  is called recursively.
 *
 **************************************/

	depth++;
	if (depth > MAX_UPDATE_DBKEY_RECURSION_DEPTH) {
		return 0;
	}

	isc_req_handle  req_handle1 = 0;

	USHORT result = 0;

	/*FOR (REQUEST_HANDLE req_handle1)
		V IN RDB$VIEW_RELATIONS
		CROSS R IN RDB$RELATIONS
		WITH
		  V.RDB$VIEW_NAME EQ current_view_name AND
		  R.RDB$RELATION_NAME EQ V.RDB$RELATION_NAME*/
	{
        if (!req_handle1)
           isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &req_handle1, (short) sizeof(isc_73), (char*) isc_73);
	isc_vtov ((const char*) current_view_name, (char*) isc_74.isc_75, 32);
	if (req_handle1)
	   {
           isc_start_and_send (isc_status, (FB_API_HANDLE*) &req_handle1, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 32, &isc_74, (short) 0);
	   }
	if (!isc_status [1]) {
	while (1)
	   {
           isc_receive (isc_status, (FB_API_HANDLE*) &req_handle1, (short) 1, (short) 44, &isc_76, (short) 0);
	   if (!isc_76.isc_79 || isc_status [1]) break;

		if (/*R.RDB$VIEW_BLR.NULL*/
		    isc_76.isc_80) {
			// This relation is a table, so increment count
			result++;
		}
		else {
			// Call recursive for VIEWS that are referenced in VIEWS
			result += get_view_base_relation_count(tdgbl, /*V.RDB$RELATION_NAME*/
								      isc_76.isc_77, depth);
		}
	/*END_FOR;*/
	   }
	   };

	/*ON_ERROR*/
	if (isc_status [1])
	   {
		MISC_release_request_silent(req_handle1);
		general_on_error();
	/*END_ERROR;*/
	   }
	}

	MISC_release_request_silent(req_handle1);

	return result;
}


void store_blr_gen_id(BurpGlobals*		tdgbl,
					  const TEXT*		gen_name,	// TEXT GDS_NAME[GDS_NAME_LEN]
					  SINT64			value,
					  const ISC_QUAD*	gen_desc)
{
   struct isc_62_struct {
          char  isc_63 [32];	/* RDB$GENERATOR_NAME */
          short isc_64;	/* gds__null_flag */
          short isc_65;	/* RDB$SYSTEM_FLAG */
   } isc_62;
   struct isc_67_struct {
          ISC_QUAD isc_68;	/* RDB$DESCRIPTION */
          char  isc_69 [32];	/* RDB$GENERATOR_NAME */
          short isc_70;	/* gds__null_flag */
          short isc_71;	/* RDB$SYSTEM_FLAG */
          short isc_72;	/* gds__null_flag */
   } isc_67;
/**************************************
 *
 *	s t o r e _ b l r _ g e n _ i d
 *
 **************************************
 *
 * Functional description
 *	Store the blr_gen_id for the relation.
 *
 **************************************/
	if (tdgbl->RESTORE_ods >= DB_VERSION_DDL11)
	{
		/*STORE (REQUEST_HANDLE tdgbl->handles_store_blr_gen_id_req_handle1)
			X IN RDB$GENERATORS*/
		{
		
                if (!tdgbl->handles_store_blr_gen_id_req_handle1)
                   isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &tdgbl->handles_store_blr_gen_id_req_handle1, (short) sizeof(isc_66), (char*) isc_66);
		if (tdgbl->handles_store_blr_gen_id_req_handle1)
		   {
		   isc_67.isc_68 = isc_blob_null;
			strcpy (/*X.RDB$GENERATOR_NAME*/
				isc_67.isc_69, gen_name);
			/*X.RDB$DESCRIPTION.NULL*/
			isc_67.isc_72 = TRUE;
			/*X.RDB$SYSTEM_FLAG*/
			isc_67.isc_71 = 0;
			/*X.RDB$SYSTEM_FLAG.NULL*/
			isc_67.isc_70 = FALSE;
			if (gen_desc)
			{
				/*X.RDB$DESCRIPTION*/
				isc_67.isc_68 = *gen_desc;
				/*X.RDB$DESCRIPTION.NULL*/
				isc_67.isc_72 = FALSE;
			}
		/*END_STORE;*/
		   
                   isc_start_and_send (isc_status, (FB_API_HANDLE*) &tdgbl->handles_store_blr_gen_id_req_handle1, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 46, &isc_67, (short) 0);
		   };
		/*ON_ERROR*/
		if (isc_status [1])
		   {
			general_on_error ();
		/*END_ERROR;*/
		   }
		}
	}
	else
	{
		/*STORE (REQUEST_HANDLE tdgbl->handles_store_blr_gen_id_req_handle1)
			X IN RDB$GENERATORS*/
		{
		
                if (!tdgbl->handles_store_blr_gen_id_req_handle1)
                   isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &tdgbl->handles_store_blr_gen_id_req_handle1, (short) sizeof(isc_61), (char*) isc_61);
		if (tdgbl->handles_store_blr_gen_id_req_handle1)
		   {
			strcpy (/*X.RDB$GENERATOR_NAME*/
				isc_62.isc_63, gen_name);
			/*X.RDB$SYSTEM_FLAG*/
			isc_62.isc_65 = 0;
			/*X.RDB$SYSTEM_FLAG.NULL*/
			isc_62.isc_64 = FALSE;
		/*END_STORE;*/
		   
                   isc_start_and_send (isc_status, (FB_API_HANDLE*) &tdgbl->handles_store_blr_gen_id_req_handle1, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 36, &isc_62, (short) 0);
		   };
		/*ON_ERROR*/
		if (isc_status [1])
		   {
			general_on_error ();
		/*END_ERROR;*/
		   }
		}
	}

	if (!value)
	{
		BURP_verbose (185, SafeArg() << gen_name << 0);
		// msg 185 restoring generator %s value: %ld
		return;
	}


	FB_API_HANDLE gen_id_reqh = 0;
	UCHAR blr_buffer[100];  // enough to fit blr
	UCHAR* blr = blr_buffer;

	// build the blr with the right relation name

	if (tdgbl->RESTORE_ods >= DB_VERSION_DDL10)
	{
		add_byte(blr, blr_version5);
	}
	else
	{
		add_byte(blr, blr_version4);
	}
	add_byte(blr, blr_begin);
	if (tdgbl->RESTORE_ods >= DB_VERSION_DDL10)
	{
		add_byte(blr, blr_dcl_variable);
		add_word(blr, 0);
		add_byte(blr, blr_int64);
		add_byte(blr, 0);
	}
	else
	{
		add_byte(blr, blr_dcl_variable);
		add_word(blr, 0);
		add_byte(blr, blr_long);
		add_byte(blr, 0);
	}
	add_byte(blr, blr_begin);
	add_byte(blr, blr_assignment);
	add_byte(blr, blr_gen_id);
	add_string(blr, gen_name);
	if (tdgbl->RESTORE_ods >= DB_VERSION_DDL10)
	{
		add_byte(blr, blr_literal);
		add_byte(blr, blr_int64);
		add_byte(blr, 0);
		add_int64(blr, value);
	}
	else
	{
		add_byte(blr, blr_literal);
		add_byte(blr, blr_long);
		add_byte(blr, 0);
		add_long(blr, (SLONG)value);
	}
	add_byte(blr, blr_variable);
	add_word(blr, 0);
	add_byte(blr, blr_end);
	add_byte(blr, blr_end);
	add_byte(blr, blr_eoc);

	const USHORT blr_length = blr - blr_buffer;
	fb_assert(blr_length <= sizeof(blr_buffer));

	ISC_STATUS_ARRAY status_vector;
	if (isc_compile_request (status_vector, &DB, &gen_id_reqh,
							 blr_length, (const SCHAR*) blr_buffer))
	{
		fb_print_blr(blr_buffer, blr_length, NULL, NULL, 0);
		BURP_error_redirect (status_vector, 42);
		// msg 42 Failed in store_blr_gen_id
	}

	if (isc_start_request (status_vector, &gen_id_reqh,
						   &gds_trans, // use the same one generated by gpre
						   0))
	{
		fb_print_blr(blr_buffer, blr_length, NULL, NULL, 0);
		BURP_error_redirect (status_vector, 42);
		// msg 42 Failed in store_blr_gen_id
	}

	BURP_verbose (185, SafeArg() << gen_name << value);
	// msg 185 restoring generator %s value: %ld

	isc_release_request (status_vector, &gen_id_reqh);
}


void update_global_field(BurpGlobals* tdgbl)
{
   struct isc_59_struct {
          short isc_60;	/* isc_utility */
   } isc_59;
   struct isc_50_struct {
          ISC_QUAD isc_51;	/* RDB$VALIDATION_BLR */
          ISC_QUAD isc_52;	/* RDB$VALIDATION_SOURCE */
          ISC_QUAD isc_53;	/* RDB$COMPUTED_BLR */
          ISC_QUAD isc_54;	/* RDB$COMPUTED_SOURCE */
          short isc_55;	/* gds__null_flag */
          short isc_56;	/* gds__null_flag */
          short isc_57;	/* gds__null_flag */
          short isc_58;	/* gds__null_flag */
   } isc_50;
   struct isc_40_struct {
          ISC_QUAD isc_41;	/* RDB$COMPUTED_SOURCE */
          ISC_QUAD isc_42;	/* RDB$COMPUTED_BLR */
          ISC_QUAD isc_43;	/* RDB$VALIDATION_SOURCE */
          ISC_QUAD isc_44;	/* RDB$VALIDATION_BLR */
          short isc_45;	/* isc_utility */
          short isc_46;	/* gds__null_flag */
          short isc_47;	/* gds__null_flag */
          short isc_48;	/* gds__null_flag */
          short isc_49;	/* gds__null_flag */
   } isc_40;
   struct isc_38_struct {
          char  isc_39 [32];	/* RDB$FIELD_NAME */
   } isc_38;
/**************************************
 *
 *	u p d a t e _ g l o b a l _ f i e l d
 *
 **************************************
 *
 * Functional description
 *	Update the global field definition to add constraints.
 *	The blobs have been created already.
 *
 **************************************/
	isc_req_handle  req_handle1 = 0;

	for (gfld* gfield = tdgbl->gbl_global_fields; gfield; )
	{
		/*FOR (TRANSACTION_HANDLE tdgbl->global_trans REQUEST_HANDLE req_handle1)
			X IN RDB$FIELDS WITH X.RDB$FIELD_NAME EQ gfield->gfld_name*/
		{
                if (!req_handle1)
                   isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &req_handle1, (short) sizeof(isc_37), (char*) isc_37);
		isc_vtov ((const char*) gfield->gfld_name, (char*) isc_38.isc_39, 32);
		if (req_handle1)
		   {
                   isc_start_and_send (isc_status, (FB_API_HANDLE*) &req_handle1, (FB_API_HANDLE*) &tdgbl->global_trans, (short) 0, (short) 32, &isc_38, (short) 0);
		   }
		if (!isc_status [1]) {
		while (1)
		   {
                   isc_receive (isc_status, (FB_API_HANDLE*) &req_handle1, (short) 1, (short) 42, &isc_40, (short) 0);
		   if (!isc_40.isc_45 || isc_status [1]) break;
			/*MODIFY X*/
			{

				if (gfield->gfld_flags & GFLD_validation_blr)
				{
					/*X.RDB$VALIDATION_BLR.NULL*/
					isc_40.isc_49 = FALSE;
					memcpy(&/*X.RDB$VALIDATION_BLR*/
						isc_40.isc_44, &gfield->gfld_vb, sizeof(ISC_QUAD));
				}

				if (gfield->gfld_flags & GFLD_validation_source)
				{
					/*X.RDB$VALIDATION_SOURCE.NULL*/
					isc_40.isc_48 = FALSE;
					memcpy(&/*X.RDB$VALIDATION_SOURCE*/
						isc_40.isc_43, &gfield->gfld_vs, sizeof(ISC_QUAD));
				}

				if (gfield->gfld_flags & GFLD_validation_source2)
				{
					/*X.RDB$VALIDATION_SOURCE.NULL*/
					isc_40.isc_48 = FALSE;
					memcpy(&/*X.RDB$VALIDATION_SOURCE*/
						isc_40.isc_43, &gfield->gfld_vs2, sizeof(ISC_QUAD));
				}

				if (gfield->gfld_flags & GFLD_computed_blr)
				{
					/*X.RDB$COMPUTED_BLR.NULL*/
					isc_40.isc_47 = FALSE;
					memcpy(&/*X.RDB$COMPUTED_BLR*/
						isc_40.isc_42, &gfield->gfld_computed_blr, sizeof(ISC_QUAD));
				}

				if (gfield->gfld_flags & GFLD_computed_source)
				{
					/*X.RDB$COMPUTED_SOURCE.NULL*/
					isc_40.isc_46 = FALSE;
					memcpy(&/*X.RDB$COMPUTED_SOURCE*/
						isc_40.isc_41, &gfield->gfld_computed_source, sizeof(ISC_QUAD));
				}

				if (gfield->gfld_flags & GFLD_computed_source2)
				{
					/*X.RDB$COMPUTED_SOURCE.NULL*/
					isc_40.isc_46 = FALSE;
					memcpy(&/*X.RDB$COMPUTED_SOURCE*/
						isc_40.isc_41, &gfield->gfld_computed_source2, sizeof(ISC_QUAD));
				}

			/*END_MODIFY;*/
			isc_50.isc_51 = isc_40.isc_44;
			isc_50.isc_52 = isc_40.isc_43;
			isc_50.isc_53 = isc_40.isc_42;
			isc_50.isc_54 = isc_40.isc_41;
			isc_50.isc_55 = isc_40.isc_49;
			isc_50.isc_56 = isc_40.isc_48;
			isc_50.isc_57 = isc_40.isc_47;
			isc_50.isc_58 = isc_40.isc_46;
                        isc_send (isc_status, (FB_API_HANDLE*) &req_handle1, (short) 2, (short) 40, &isc_50, (short) 0);;
			/*ON_ERROR*/
			if (isc_status [1])
			   {
				general_on_error ();
			/*END_ERROR;*/
			   }
			}

		/*END_FOR;*/
                   isc_send (isc_status, (FB_API_HANDLE*) &req_handle1, (short) 3, (short) 2, &isc_59, (short) 0);
		   }
		   };
		/*ON_ERROR*/
		if (isc_status [1])
		   {
			general_on_error ();
		/*END_ERROR;*/
		   }
		}
		gfld* n_gfield = gfield->gfld_next;
		BURP_free (gfield);
		gfield = n_gfield;
	}
	MISC_release_request_silent(req_handle1);

	tdgbl->gbl_global_fields = NULL;
}


void update_view_dbkey_lengths(BurpGlobals* tdgbl)
{
   struct isc_35_struct {
          short isc_36;	/* isc_utility */
   } isc_35;
   struct isc_33_struct {
          short isc_34;	/* RDB$DBKEY_LENGTH */
   } isc_33;
   struct isc_29_struct {
          char  isc_30 [32];	/* RDB$RELATION_NAME */
          short isc_31;	/* isc_utility */
          short isc_32;	/* RDB$DBKEY_LENGTH */
   } isc_29;
/**************************************
 *
 *	u p d a t e _ v i e w _ d b k e y _ l e n g t h s
 *
 **************************************
 *
 * Functional description
 *	During the restore process VIEWs could
 *  be created that holds other VIEWs and
 *  which weren't restored yet.
 *  Then the RDB$DBKEY_LENGTH for VIEWs is
 *  calculated wrong. Therefore we need to
 *  recalculate the DBKEY_LENGTH else we
 *  get our famous "arithmetic exception,
 *  numeric overflow, or string truncation" error.
 *
 **************************************/
	isc_req_handle  req_handle2 = 0;

	/*FOR (REQUEST_HANDLE req_handle2)
		R IN RDB$RELATIONS
		WITH
		  R.RDB$VIEW_BLR NOT MISSING AND
		  (R.RDB$SYSTEM_FLAG NE 1 OR R.RDB$SYSTEM_FLAG MISSING)*/
	{
        if (!req_handle2)
           isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &req_handle2, (short) sizeof(isc_28), (char*) isc_28);
	if (req_handle2)
	   {
           isc_start_request (isc_status, (FB_API_HANDLE*) &req_handle2, (FB_API_HANDLE*) &gds_trans, (short) 0);
	   }
	if (!isc_status [1]) {
	while (1)
	   {
           isc_receive (isc_status, (FB_API_HANDLE*) &req_handle2, (short) 0, (short) 36, &isc_29, (short) 0);
	   if (!isc_29.isc_31 || isc_status [1]) break;

		const USHORT result = get_view_base_relation_count(tdgbl, /*R.RDB$RELATION_NAME*/
									  isc_29.isc_30, 0);

		/*MODIFY R*/
		{;
			/*R.RDB$DBKEY_LENGTH*/
			isc_29.isc_32 = (result * 8); // is a constant for DBKEY coded somewhere?
		/*END_MODIFY;*/
		isc_33.isc_34 = isc_29.isc_32;
                isc_send (isc_status, (FB_API_HANDLE*) &req_handle2, (short) 1, (short) 2, &isc_33, (short) 0);;
		/*ON_ERROR*/
		if (isc_status [1])
		   {
			MISC_release_request_silent(req_handle2);
			general_on_error();
		/*END_ERROR;*/
		   }
		}

	/*END_FOR;*/
           isc_send (isc_status, (FB_API_HANDLE*) &req_handle2, (short) 2, (short) 2, &isc_35, (short) 0);
	   }
	   };

	/*ON_ERROR*/
	if (isc_status [1])
	   {
		MISC_release_request_silent(req_handle2);
		general_on_error();
	/*END_ERROR;*/
	   }
	}

	MISC_release_request_silent(req_handle2);
}

struct FixGenerator
{
	const char* name;
	const char* table;
	const char* field;
	const char* prefix;
};

void fix_generator(BurpGlobals* tdgbl, const FixGenerator* g)
{
/**************************************
 *
 *	f i x G e n e r a t o r
 *
 **************************************
 *
 * Functional description
 *	Set value of system generator based on
 *	current state of related table.
 *
 **************************************/

	int start = strlen(g->prefix) + 1;

	Firebird::string sql;
	sql.printf("EXECUTE BLOCK AS "
			   "DECLARE VARIABLE maxInTable INT; "
			   "DECLARE VARIABLE currentGen INT; "
			   "BEGIN "
			   " SELECT FIRST(1) CAST(SUBSTRING(%s FROM %d FOR 32) AS INT) FROM %s "
			   " WHERE SUBSTRING(%s FROM %d FOR 32) SIMILAR TO '[0-9]+ *' "
			   "   AND %s STARTING WITH '%s' ORDER BY 1 DESC INTO :maxInTable; "
			   " "
			   " currentGen = gen_id(%s, 0); "
			   " IF (currentGen < maxInTable) THEN "
			   "  EXECUTE STATEMENT 'SET GENERATOR %s TO ' || maxInTable; "
			   "END",
			   /* SELECT 1 */ g->field, start, g->table, g->field, start, g->field, g->prefix,
			   /* SELECT 2 */ g->name,
			   /* SET GEN  */ g->name);

	if (isc_execute_immediate(isc_status, &DB, &gds_trans, 0, sql.c_str()) != 0)
		general_on_error();
}

const FixGenerator genToFix[] = 
{
	{  "RDB$CONSTRAINT_NAME",	"RDB$RELATION_CONSTRAINTS",	"RDB$CONSTRAINT_NAME",	"INTEG_" },
	{  "RDB$FIELD_NAME",		"RDB$FIELDS",				"RDB$FIELD_NAME",		"RDB$" },
	{  "RDB$INDEX_NAME",		"RDB$INDICES", 				"RDB$INDEX_NAME",		"RDB$" },
	{  "RDB$INDEX_NAME",		"RDB$INDICES", 				"RDB$INDEX_NAME",		"RDB$PRIMARY" },
	{  "RDB$INDEX_NAME",		"RDB$INDICES", 				"RDB$INDEX_NAME",		"RDB$FOREIGN" },
	{  "RDB$TRIGGER_NAME",		"RDB$TRIGGERS",				"RDB$TRIGGER_NAME",		"CHECK_" },
	{ NULL, NULL, NULL, NULL }
};

void fix_system_generators(BurpGlobals* tdgbl)
{
/**************************************
 *
 *	f i x A l l G e n e r a t o r s
 *
 **************************************
 *
 * Functional description
 *	Set value of system generators based on
 *	current state of related tables.
 *
 **************************************/

	for (const FixGenerator* g = genToFix; g->name; ++g)
	{
		fix_generator(tdgbl, g);
	}
}

} // namespace


