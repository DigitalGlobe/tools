/*********** Preprocessed module -- do not edit ***************/
/*********** Preprocessed module -- do not edit ***************/
/*********** Preprocessed module -- do not edit ***************/
/*********** Preprocessed module -- do not edit ***************/
/*********** Preprocessed module -- do not edit ***************/
/***************** gpre version WI-V2.5.7.27050 Firebird 2.5 **********************/
/*
 *	PROGRAM:	JRD Backup and Restore Program
 *	MODULE:		backup.epp
 *	DESCRIPTION:	Backup routine
 *
 * The contents of this file are subject to the Interbase Public
 * License Version 1.0 (the "License"); you may not use this file
 * except in compliance with the License. You may obtain a copy
 * of the License at http://www.Inprise.com/IPL.html
 *
 * Software distributed under the License is distributed on an
 * "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * rights and limitations under the License.
 *
 * The Original Code was created by Inprise Corporation
 * and its predecessors. Portions created by Inprise Corporation are
 * Copyright (C) Inprise Corporation.
 *
 * All Rights Reserved.
 * Contributor(s): ______________________________________.
 *
 * Toni Martir: Added verbose backup records as BACKUP_VERBOSE_INTERVAL
 * 2001.07.06 Sean Leyne - Code Cleanup, removed "#ifdef READONLY_DATABASE"
 *                         conditionals, as the engine now fully supports
 *                         readonly databases.
 * 2001.11.20 Claudio Valderrama: fix problem with embedded blanks in
 * generators and use symbol_length effective length calculation from put_text.
 * This minimizes code redundancy and fixes SF Bug #483276.
 * 2001.12.15 Claudio Valderrama: copy should run through symbol_length instead
 * of using just another length calculation algorithm. Callers of put_text, copy
 * and symbol_length (if used directly) should use sizeof. Changed all callers
 * and sizeof() works because the strings are local to the functions. This
 * eliminates the problem with harcoded limits in each call.
 * 2002.10.29 Mike Nordell: UINT64 backup message.
 * 2003.08.17 Claudio Valderrama: Fix SF Bug #750659.
 * 2005.04.29 Claudio Valderrama: Moved symbol_length to misc.cpp.
 */


#include "firebird.h"
#include <stdio.h>
#include <memory.h>
#include <string.h>
#include "../burp/burp.h"
#include "../jrd/ods.h"
#include "../jrd/align.h"
#include "../jrd/gdsassert.h"
#include "../jrd/constants.h"
#include "../common/stuff.h"
#include "../burp/backu_proto.h"
#include "../burp/burp_proto.h"
#include "../burp/canon_proto.h"
#include "../burp/mvol_proto.h"
#include "../remote/protocol.h"
#ifdef DEBUG
#include "../gpre/prett_proto.h"
#endif

#include "../common/classes/UserBlob.h"
#include "../common/classes/MsgPrint.h"

using MsgFormat::SafeArg;


// For service APIs the follow DB handle is a value stored
// in thread data.  This is also done for other statics generated by
// GPRE.  This is to avoid multiple threading problems with module
// level statics.

/*DATABASE DB = STATIC FILENAME "yachts.lnk" RUNTIME * dbb_file;*/
/**** GDS Preprocessor Definitions ****/
#ifndef JRD_IBASE_H
#include <ibase.h>
#endif

static const ISC_QUAD
   isc_blob_null = {0, 0};	/* initializer for blobs */
static isc_db_handle
   DB = 0;		/* database handle */

static isc_tr_handle
   gds_trans = 0;		/* default transaction handle */
static ISC_STATUS
   isc_status [20],	/* status vector */
   isc_status2 [20];	/* status vector */
static ISC_LONG
   isc_array_length, 	/* array return size */
   SQLCODE;		/* SQL status code */
static const char
   isc_tpb_3 [4] = {1,9,2,6};

static const char
   isc_tpb_2 [5] = {1,9,2,6,20};

static const char
   isc_tpb_1 [4] = {1,9,2,6};

static const char
   isc_tpb_0 [5] = {1,9,2,6,20};

static const short
   isc_4l = 226;
static const char
   isc_4 [] = {
   4,2,4,0,8,0,41,3,0,32,0,41,3,0,32,0,41,3,0,32,0,41,3,0,32,0,
   7,0,7,0,7,0,41,0,0,7,0,2,7,'C',1,'J',19,'R','D','B','$','U',
   'S','E','R','_','P','R','I','V','I','L','E','G','E','S',0,-1,
   14,0,2,1,23,0,14,'R','D','B','$','F','I','E','L','D','_','N',
   'A','M','E',41,0,0,0,5,0,1,23,0,17,'R','D','B','$','R','E','L',
   'A','T','I','O','N','_','N','A','M','E',25,0,1,0,1,23,0,11,'R',
   'D','B','$','G','R','A','N','T','O','R',25,0,2,0,1,23,0,8,'R',
   'D','B','$','U','S','E','R',25,0,3,0,1,21,8,0,1,0,0,0,25,0,4,
   0,1,23,0,16,'R','D','B','$','G','R','A','N','T','_','O','P',
   'T','I','O','N',25,0,6,0,1,23,0,13,'R','D','B','$','P','R','I',
   'V','I','L','E','G','E',25,0,7,0,-1,14,0,1,21,8,0,0,0,0,0,25,
   0,4,0,-1,-1,'L'
   };	/* end of blr string for request isc_4 */

static const short
   isc_14l = 274;
static const char
   isc_14 [] = {
   4,2,4,0,10,0,41,3,0,32,0,41,3,0,32,0,41,3,0,32,0,41,3,0,32,0,
   7,0,7,0,7,0,7,0,7,0,41,0,0,7,0,2,7,'C',1,'J',19,'R','D','B',
   '$','U','S','E','R','_','P','R','I','V','I','L','E','G','E',
   'S',0,-1,14,0,2,1,23,0,14,'R','D','B','$','F','I','E','L','D',
   '_','N','A','M','E',41,0,0,0,7,0,1,23,0,17,'R','D','B','$','R',
   'E','L','A','T','I','O','N','_','N','A','M','E',25,0,1,0,1,23,
   0,11,'R','D','B','$','G','R','A','N','T','O','R',25,0,2,0,1,
   23,0,8,'R','D','B','$','U','S','E','R',25,0,3,0,1,21,8,0,1,0,
   0,0,25,0,4,0,1,23,0,15,'R','D','B','$','O','B','J','E','C','T',
   '_','T','Y','P','E',25,0,5,0,1,23,0,13,'R','D','B','$','U','S',
   'E','R','_','T','Y','P','E',25,0,6,0,1,23,0,16,'R','D','B','$',
   'G','R','A','N','T','_','O','P','T','I','O','N',25,0,8,0,1,23,
   0,13,'R','D','B','$','P','R','I','V','I','L','E','G','E',25,
   0,9,0,-1,14,0,1,21,8,0,0,0,0,0,25,0,4,0,-1,-1,'L'
   };	/* end of blr string for request isc_14 */

static const short
   isc_26l = 226;
static const char
   isc_26 [] = {
   4,2,4,0,6,0,9,0,41,3,0,32,0,41,3,0,32,0,7,0,7,0,7,0,2,7,'C',
   1,'J',9,'R','D','B','$','T','Y','P','E','S',0,'G',57,48,23,0,
   15,'R','D','B','$','S','Y','S','T','E','M','_','F','L','A','G',
   21,8,0,1,0,0,0,61,23,0,15,'R','D','B','$','S','Y','S','T','E',
   'M','_','F','L','A','G',-1,14,0,2,1,23,0,15,'R','D','B','$',
   'D','E','S','C','R','I','P','T','I','O','N',25,0,0,0,1,23,0,
   14,'R','D','B','$','F','I','E','L','D','_','N','A','M','E',25,
   0,1,0,1,23,0,13,'R','D','B','$','T','Y','P','E','_','N','A',
   'M','E',25,0,2,0,1,21,8,0,1,0,0,0,25,0,3,0,1,23,0,15,'R','D',
   'B','$','S','Y','S','T','E','M','_','F','L','A','G',25,0,4,0,
   1,23,0,8,'R','D','B','$','T','Y','P','E',25,0,5,0,-1,14,0,1,
   21,8,0,0,0,0,0,25,0,3,0,-1,-1,'L'
   };	/* end of blr string for request isc_26 */

static const short
   isc_34l = 252;
static const char
   isc_34 [] = {
   4,2,4,0,4,0,41,0,0,0,4,41,3,0,32,0,7,0,7,0,2,7,'C',2,'J',12,
   'R','D','B','$','T','R','I','G','G','E','R','S',0,'J',20,'R',
   'D','B','$','T','R','I','G','G','E','R','_','M','E','S','S',
   'A','G','E','S',1,'G',58,47,23,1,16,'R','D','B','$','T','R',
   'I','G','G','E','R','_','N','A','M','E',23,0,16,'R','D','B',
   '$','T','R','I','G','G','E','R','_','N','A','M','E',57,48,23,
   0,15,'R','D','B','$','S','Y','S','T','E','M','_','F','L','A',
   'G',21,8,0,1,0,0,0,61,23,0,15,'R','D','B','$','S','Y','S','T',
   'E','M','_','F','L','A','G',-1,14,0,2,1,23,1,11,'R','D','B',
   '$','M','E','S','S','A','G','E',25,0,0,0,1,23,1,16,'R','D','B',
   '$','T','R','I','G','G','E','R','_','N','A','M','E',25,0,1,0,
   1,21,8,0,1,0,0,0,25,0,2,0,1,23,1,18,'R','D','B','$','M','E',
   'S','S','A','G','E','_','N','U','M','B','E','R',25,0,3,0,-1,
   14,0,1,21,8,0,0,0,0,0,25,0,2,0,-1,-1,'L'
   };	/* end of blr string for request isc_34 */

static const short
   isc_40l = 120;
static const char
   isc_40 [] = {
   4,2,4,1,3,0,7,0,7,0,7,0,4,0,1,0,41,3,0,32,0,12,0,2,7,'C',1,'J',
   12,'R','D','B','$','T','R','I','G','G','E','R','S',0,'G',47,
   25,0,0,0,23,0,16,'R','D','B','$','T','R','I','G','G','E','R',
   '_','N','A','M','E',-1,14,1,2,1,21,8,0,1,0,0,0,25,1,0,0,1,23,
   0,9,'R','D','B','$','F','L','A','G','S',41,1,2,0,1,0,-1,14,1,
   1,21,8,0,0,0,0,0,25,1,0,0,-1,-1,'L'
   };	/* end of blr string for request isc_40 */

static const short
   isc_47l = 360;
static const char
   isc_47 [] = {
   4,2,4,0,11,0,9,0,9,0,9,0,41,3,0,32,0,41,3,0,32,0,7,0,7,0,7,0,
   7,0,7,0,7,0,2,7,'C',1,'J',12,'R','D','B','$','T','R','I','G',
   'G','E','R','S',0,'G',57,48,23,0,15,'R','D','B','$','S','Y',
   'S','T','E','M','_','F','L','A','G',21,8,0,1,0,0,0,61,23,0,15,
   'R','D','B','$','S','Y','S','T','E','M','_','F','L','A','G',
   -1,14,0,2,1,23,0,15,'R','D','B','$','D','E','S','C','R','I',
   'P','T','I','O','N',25,0,0,0,1,23,0,18,'R','D','B','$','T','R',
   'I','G','G','E','R','_','S','O','U','R','C','E',25,0,1,0,1,23,
   0,15,'R','D','B','$','T','R','I','G','G','E','R','_','B','L',
   'R',25,0,2,0,1,23,0,17,'R','D','B','$','R','E','L','A','T','I',
   'O','N','_','N','A','M','E',41,0,3,0,10,0,1,23,0,16,'R','D',
   'B','$','T','R','I','G','G','E','R','_','N','A','M','E',25,0,
   4,0,1,21,8,0,1,0,0,0,25,0,5,0,1,23,0,20,'R','D','B','$','T',
   'R','I','G','G','E','R','_','I','N','A','C','T','I','V','E',
   25,0,6,0,1,23,0,15,'R','D','B','$','S','Y','S','T','E','M','_',
   'F','L','A','G',25,0,7,0,1,23,0,16,'R','D','B','$','T','R','I',
   'G','G','E','R','_','T','Y','P','E',25,0,8,0,1,23,0,20,'R','D',
   'B','$','T','R','I','G','G','E','R','_','S','E','Q','U','E',
   'N','C','E',25,0,9,0,-1,14,0,1,21,8,0,0,0,0,0,25,0,5,0,-1,-1,
   'L'
   };	/* end of blr string for request isc_47 */

static const short
   isc_60l = 383;
static const char
   isc_60 [] = {
   4,2,4,0,13,0,9,0,9,0,9,0,41,3,0,32,0,41,3,0,32,0,7,0,7,0,7,0,
   7,0,7,0,7,0,7,0,7,0,2,7,'C',1,'J',12,'R','D','B','$','T','R',
   'I','G','G','E','R','S',0,'G',57,48,23,0,15,'R','D','B','$',
   'S','Y','S','T','E','M','_','F','L','A','G',21,8,0,1,0,0,0,61,
   23,0,15,'R','D','B','$','S','Y','S','T','E','M','_','F','L',
   'A','G',-1,14,0,2,1,23,0,15,'R','D','B','$','D','E','S','C',
   'R','I','P','T','I','O','N',25,0,0,0,1,23,0,18,'R','D','B','$',
   'T','R','I','G','G','E','R','_','S','O','U','R','C','E',25,0,
   1,0,1,23,0,15,'R','D','B','$','T','R','I','G','G','E','R','_',
   'B','L','R',25,0,2,0,1,23,0,17,'R','D','B','$','R','E','L','A',
   'T','I','O','N','_','N','A','M','E',41,0,3,0,12,0,1,23,0,16,
   'R','D','B','$','T','R','I','G','G','E','R','_','N','A','M',
   'E',25,0,4,0,1,21,8,0,1,0,0,0,25,0,5,0,1,23,0,9,'R','D','B',
   '$','F','L','A','G','S',41,0,7,0,6,0,1,23,0,20,'R','D','B','$',
   'T','R','I','G','G','E','R','_','I','N','A','C','T','I','V',
   'E',25,0,8,0,1,23,0,15,'R','D','B','$','S','Y','S','T','E','M',
   '_','F','L','A','G',25,0,9,0,1,23,0,16,'R','D','B','$','T','R',
   'I','G','G','E','R','_','T','Y','P','E',25,0,10,0,1,23,0,20,
   'R','D','B','$','T','R','I','G','G','E','R','_','S','E','Q',
   'U','E','N','C','E',25,0,11,0,-1,14,0,1,21,8,0,0,0,0,0,25,0,
   5,0,-1,-1,'L'
   };	/* end of blr string for request isc_60 */

static const short
   isc_75l = 438;
static const char
   isc_75 [] = {
   4,2,4,0,17,0,9,0,9,0,9,0,9,0,41,3,0,32,0,41,3,0,32,0,7,0,7,0,
   7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,2,7,'C',1,'J',12,'R','D',
   'B','$','T','R','I','G','G','E','R','S',0,'G',57,48,23,0,15,
   'R','D','B','$','S','Y','S','T','E','M','_','F','L','A','G',
   21,8,0,1,0,0,0,61,23,0,15,'R','D','B','$','S','Y','S','T','E',
   'M','_','F','L','A','G',-1,14,0,2,1,23,0,14,'R','D','B','$',
   'D','E','B','U','G','_','I','N','F','O',41,0,0,0,7,0,1,23,0,
   15,'R','D','B','$','D','E','S','C','R','I','P','T','I','O','N',
   25,0,1,0,1,23,0,18,'R','D','B','$','T','R','I','G','G','E','R',
   '_','S','O','U','R','C','E',25,0,2,0,1,23,0,15,'R','D','B','$',
   'T','R','I','G','G','E','R','_','B','L','R',25,0,3,0,1,23,0,
   17,'R','D','B','$','R','E','L','A','T','I','O','N','_','N','A',
   'M','E',41,0,4,0,16,0,1,23,0,16,'R','D','B','$','T','R','I',
   'G','G','E','R','_','N','A','M','E',25,0,5,0,1,21,8,0,1,0,0,
   0,25,0,6,0,1,23,0,13,'R','D','B','$','V','A','L','I','D','_',
   'B','L','R',41,0,9,0,8,0,1,23,0,9,'R','D','B','$','F','L','A',
   'G','S',41,0,11,0,10,0,1,23,0,20,'R','D','B','$','T','R','I',
   'G','G','E','R','_','I','N','A','C','T','I','V','E',25,0,12,
   0,1,23,0,15,'R','D','B','$','S','Y','S','T','E','M','_','F',
   'L','A','G',25,0,13,0,1,23,0,16,'R','D','B','$','T','R','I',
   'G','G','E','R','_','T','Y','P','E',25,0,14,0,1,23,0,20,'R',
   'D','B','$','T','R','I','G','G','E','R','_','S','E','Q','U',
   'E','N','C','E',25,0,15,0,-1,14,0,1,21,8,0,0,0,0,0,25,0,6,0,
   -1,-1,'L'
   };	/* end of blr string for request isc_75 */

static const short
   isc_94l = 116;
static const char
   isc_94 [] = {
   4,2,4,1,2,0,7,0,7,0,4,0,1,0,41,3,0,32,0,12,0,2,7,'C',1,'J',9,
   'R','D','B','$','R','O','L','E','S',0,'G',47,23,0,13,'R','D',
   'B','$','R','O','L','E','_','N','A','M','E',25,0,0,0,-1,14,1,
   2,1,21,8,0,1,0,0,0,25,1,0,0,1,23,0,15,'R','D','B','$','S','Y',
   'S','T','E','M','_','F','L','A','G',25,1,1,0,-1,14,1,1,21,8,
   0,0,0,0,0,25,1,0,0,-1,-1,'L'
   };	/* end of blr string for request isc_94 */

static const short
   isc_100l = 111;
static const char
   isc_100 [] = {
   4,2,4,0,3,0,41,3,0,32,0,41,3,0,32,0,7,0,2,7,'C',1,'J',9,'R',
   'D','B','$','R','O','L','E','S',0,-1,14,0,2,1,23,0,14,'R','D',
   'B','$','O','W','N','E','R','_','N','A','M','E',25,0,0,0,1,23,
   0,13,'R','D','B','$','R','O','L','E','_','N','A','M','E',25,
   0,1,0,1,21,8,0,1,0,0,0,25,0,2,0,-1,14,0,1,21,8,0,0,0,0,0,25,
   0,2,0,-1,-1,'L'
   };	/* end of blr string for request isc_100 */

static const short
   isc_105l = 187;
static const char
   isc_105 [] = {
   4,2,4,0,5,0,9,0,41,3,0,32,0,41,3,0,32,0,7,0,7,0,2,7,'C',1,'J',
   9,'R','D','B','$','R','O','L','E','S',0,'G',57,47,23,0,15,'R',
   'D','B','$','S','Y','S','T','E','M','_','F','L','A','G',21,8,
   0,0,0,0,0,61,23,0,15,'R','D','B','$','S','Y','S','T','E','M',
   '_','F','L','A','G',-1,14,0,2,1,23,0,15,'R','D','B','$','D',
   'E','S','C','R','I','P','T','I','O','N',41,0,0,0,4,0,1,23,0,
   14,'R','D','B','$','O','W','N','E','R','_','N','A','M','E',25,
   0,1,0,1,23,0,13,'R','D','B','$','R','O','L','E','_','N','A',
   'M','E',25,0,2,0,1,21,8,0,1,0,0,0,25,0,3,0,-1,14,0,1,21,8,0,
   0,0,0,0,25,0,3,0,-1,-1,'L'
   };	/* end of blr string for request isc_105 */

static const short
   isc_112l = 263;
static const char
   isc_112 [] = {
   4,2,4,0,7,0,41,0,0,0,1,8,0,8,0,7,0,7,0,7,0,7,0,2,7,'C',1,'J',
   9,'R','D','B','$','F','I','L','E','S',0,'G',58,59,61,23,0,17,
   'R','D','B','$','S','H','A','D','O','W','_','N','U','M','B',
   'E','R',48,23,0,17,'R','D','B','$','S','H','A','D','O','W','_',
   'N','U','M','B','E','R',21,8,0,0,0,0,0,-1,14,0,2,1,23,0,13,'R',
   'D','B','$','F','I','L','E','_','N','A','M','E',25,0,0,0,1,23,
   0,15,'R','D','B','$','F','I','L','E','_','L','E','N','G','T',
   'H',25,0,1,0,1,23,0,14,'R','D','B','$','F','I','L','E','_','S',
   'T','A','R','T',25,0,2,0,1,21,8,0,1,0,0,0,25,0,3,0,1,23,0,17,
   'R','D','B','$','S','H','A','D','O','W','_','N','U','M','B',
   'E','R',25,0,4,0,1,23,0,14,'R','D','B','$','F','I','L','E','_',
   'F','L','A','G','S',25,0,5,0,1,23,0,17,'R','D','B','$','F','I',
   'L','E','_','S','E','Q','U','E','N','C','E',25,0,6,0,-1,14,0,
   1,21,8,0,0,0,0,0,25,0,3,0,-1,-1,'L'
   };	/* end of blr string for request isc_112 */

static const short
   isc_121l = 130;
static const char
   isc_121 [] = {
   4,2,4,1,3,0,7,0,7,0,7,0,4,0,1,0,41,3,0,32,0,12,0,2,7,'C',1,'J',
   13,'R','D','B','$','R','E','L','A','T','I','O','N','S',0,'G',
   47,23,0,17,'R','D','B','$','R','E','L','A','T','I','O','N','_',
   'N','A','M','E',25,0,0,0,-1,14,1,2,1,21,8,0,1,0,0,0,25,1,0,0,
   1,23,0,17,'R','D','B','$','R','E','L','A','T','I','O','N','_',
   'T','Y','P','E',41,1,2,0,1,0,-1,14,1,1,21,8,0,0,0,0,0,25,1,0,
   0,-1,-1,'L'
   };	/* end of blr string for request isc_121 */

static const short
   isc_128l = 194;
static const char
   isc_128 [] = {
   4,2,4,1,5,0,41,0,0,0,1,41,3,0,32,0,9,0,7,0,7,0,4,0,1,0,41,3,
   0,32,0,12,0,2,7,'C',1,'J',13,'R','D','B','$','R','E','L','A',
   'T','I','O','N','S',0,'G',47,23,0,17,'R','D','B','$','R','E',
   'L','A','T','I','O','N','_','N','A','M','E',25,0,0,0,-1,14,1,
   2,1,23,0,17,'R','D','B','$','E','X','T','E','R','N','A','L',
   '_','F','I','L','E',41,1,0,0,4,0,1,23,0,14,'R','D','B','$','O',
   'W','N','E','R','_','N','A','M','E',25,1,1,0,1,23,0,24,'R','D',
   'B','$','E','X','T','E','R','N','A','L','_','D','E','S','C',
   'R','I','P','T','I','O','N',25,1,2,0,1,21,8,0,1,0,0,0,25,1,3,
   0,-1,14,1,1,21,8,0,0,0,0,0,25,1,3,0,-1,-1,'L'
   };	/* end of blr string for request isc_128 */

static const short
   isc_137l = 134;
static const char
   isc_137 [] = {
   4,2,4,1,3,0,41,3,0,32,0,7,0,7,0,4,0,1,0,41,3,0,32,0,12,0,2,7,
   'C',1,'J',13,'R','D','B','$','R','E','L','A','T','I','O','N',
   'S',0,'G',47,23,0,17,'R','D','B','$','R','E','L','A','T','I',
   'O','N','_','N','A','M','E',25,0,0,0,-1,14,1,2,1,23,0,18,'R',
   'D','B','$','S','E','C','U','R','I','T','Y','_','C','L','A',
   'S','S',41,1,0,0,2,0,1,21,8,0,1,0,0,0,25,1,1,0,-1,14,1,1,21,
   8,0,0,0,0,0,25,1,1,0,-1,-1,'L'
   };	/* end of blr string for request isc_137 */

static const short
   isc_144l = 122;
static const char
   isc_144 [] = {
   4,2,4,1,3,0,7,0,7,0,7,0,4,0,1,0,41,3,0,32,0,12,0,2,7,'C',1,'J',
   13,'R','D','B','$','R','E','L','A','T','I','O','N','S',0,'G',
   47,23,0,17,'R','D','B','$','R','E','L','A','T','I','O','N','_',
   'N','A','M','E',25,0,0,0,-1,14,1,2,1,21,8,0,1,0,0,0,25,1,0,0,
   1,23,0,9,'R','D','B','$','F','L','A','G','S',41,1,2,0,1,0,-1,
   14,1,1,21,8,0,0,0,0,0,25,1,0,0,-1,-1,'L'
   };	/* end of blr string for request isc_144 */

static const short
   isc_151l = 261;
static const char
   isc_151 [] = {
   4,2,4,0,7,0,9,0,9,0,9,0,41,3,0,32,0,7,0,7,0,7,0,2,7,'C',1,'J',
   13,'R','D','B','$','R','E','L','A','T','I','O','N','S',0,'G',
   57,48,23,0,15,'R','D','B','$','S','Y','S','T','E','M','_','F',
   'L','A','G',21,8,0,1,0,0,0,61,23,0,15,'R','D','B','$','S','Y',
   'S','T','E','M','_','F','L','A','G',-1,14,0,2,1,23,0,15,'R',
   'D','B','$','V','I','E','W','_','S','O','U','R','C','E',25,0,
   0,0,1,23,0,15,'R','D','B','$','D','E','S','C','R','I','P','T',
   'I','O','N',25,0,1,0,1,23,0,12,'R','D','B','$','V','I','E','W',
   '_','B','L','R',25,0,2,0,1,23,0,17,'R','D','B','$','R','E','L',
   'A','T','I','O','N','_','N','A','M','E',25,0,3,0,1,21,8,0,1,
   0,0,0,25,0,4,0,1,23,0,15,'R','D','B','$','R','E','L','A','T',
   'I','O','N','_','I','D',25,0,5,0,1,23,0,15,'R','D','B','$','S',
   'Y','S','T','E','M','_','F','L','A','G',25,0,6,0,-1,14,0,1,21,
   8,0,0,0,0,0,25,0,4,0,-1,-1,'L'
   };	/* end of blr string for request isc_151 */

static const short
   isc_160l = 445;
static const char
   isc_160 [] = {
   4,2,4,0,17,0,41,0,0,0,1,41,3,0,32,0,9,0,9,0,9,0,41,3,0,32,0,
   9,0,41,3,0,32,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,2,7,'C',
   1,'J',13,'R','D','B','$','R','E','L','A','T','I','O','N','S',
   0,'G',57,48,23,0,15,'R','D','B','$','S','Y','S','T','E','M',
   '_','F','L','A','G',21,8,0,1,0,0,0,61,23,0,15,'R','D','B','$',
   'S','Y','S','T','E','M','_','F','L','A','G',-1,14,0,2,1,23,0,
   17,'R','D','B','$','E','X','T','E','R','N','A','L','_','F','I',
   'L','E',41,0,0,0,12,0,1,23,0,14,'R','D','B','$','O','W','N',
   'E','R','_','N','A','M','E',25,0,1,0,1,23,0,24,'R','D','B','$',
   'E','X','T','E','R','N','A','L','_','D','E','S','C','R','I',
   'P','T','I','O','N',25,0,2,0,1,23,0,15,'R','D','B','$','V','I',
   'E','W','_','S','O','U','R','C','E',25,0,3,0,1,23,0,15,'R','D',
   'B','$','D','E','S','C','R','I','P','T','I','O','N',25,0,4,0,
   1,23,0,18,'R','D','B','$','S','E','C','U','R','I','T','Y','_',
   'C','L','A','S','S',41,0,5,0,13,0,1,23,0,12,'R','D','B','$',
   'V','I','E','W','_','B','L','R',25,0,6,0,1,23,0,17,'R','D','B',
   '$','R','E','L','A','T','I','O','N','_','N','A','M','E',25,0,
   7,0,1,21,8,0,1,0,0,0,25,0,8,0,1,23,0,15,'R','D','B','$','R',
   'E','L','A','T','I','O','N','_','I','D',25,0,9,0,1,23,0,17,'R',
   'D','B','$','R','E','L','A','T','I','O','N','_','T','Y','P',
   'E',41,0,11,0,10,0,1,23,0,9,'R','D','B','$','F','L','A','G',
   'S',41,0,15,0,14,0,1,23,0,15,'R','D','B','$','S','Y','S','T',
   'E','M','_','F','L','A','G',25,0,16,0,-1,14,0,1,21,8,0,0,0,0,
   0,25,0,8,0,-1,-1,'L'
   };	/* end of blr string for request isc_160 */

static const short
   isc_179l = 365;
static const char
   isc_179 [] = {
   4,2,4,0,8,0,41,3,0,32,0,41,3,0,32,0,41,3,0,32,0,41,0,0,4,0,41,
   0,0,4,0,41,0,0,12,0,7,0,7,0,2,7,'C',2,'J',24,'R','D','B','$',
   'R','E','L','A','T','I','O','N','_','C','O','N','S','T','R',
   'A','I','N','T','S',0,'J',13,'R','D','B','$','R','E','L','A',
   'T','I','O','N','S',1,'G',58,47,23,1,17,'R','D','B','$','R',
   'E','L','A','T','I','O','N','_','N','A','M','E',23,0,17,'R',
   'D','B','$','R','E','L','A','T','I','O','N','_','N','A','M',
   'E',57,61,23,1,15,'R','D','B','$','S','Y','S','T','E','M','_',
   'F','L','A','G',48,23,1,15,'R','D','B','$','S','Y','S','T','E',
   'M','_','F','L','A','G',21,8,0,1,0,0,0,-1,14,0,2,1,23,0,14,'R',
   'D','B','$','I','N','D','E','X','_','N','A','M','E',41,0,0,0,
   7,0,1,23,0,17,'R','D','B','$','R','E','L','A','T','I','O','N',
   '_','N','A','M','E',25,0,1,0,1,23,0,19,'R','D','B','$','C','O',
   'N','S','T','R','A','I','N','T','_','N','A','M','E',25,0,2,0,
   1,23,0,22,'R','D','B','$','I','N','I','T','I','A','L','L','Y',
   '_','D','E','F','E','R','R','E','D',25,0,3,0,1,23,0,14,'R','D',
   'B','$','D','E','F','E','R','R','A','B','L','E',25,0,4,0,1,23,
   0,19,'R','D','B','$','C','O','N','S','T','R','A','I','N','T',
   '_','T','Y','P','E',25,0,5,0,1,21,8,0,1,0,0,0,25,0,6,0,-1,14,
   0,1,21,8,0,0,0,0,0,25,0,6,0,-1,-1,'L'
   };	/* end of blr string for request isc_179 */

static const short
   isc_189l = 215;
static const char
   isc_189 [] = {
   4,2,4,0,6,0,41,0,0,8,0,41,3,0,32,0,41,3,0,32,0,41,0,0,12,0,41,
   0,0,12,0,7,0,2,7,'C',1,'J',19,'R','D','B','$','R','E','F','_',
   'C','O','N','S','T','R','A','I','N','T','S',0,-1,14,0,2,1,23,
   0,16,'R','D','B','$','M','A','T','C','H','_','O','P','T','I',
   'O','N',25,0,0,0,1,23,0,17,'R','D','B','$','C','O','N','S','T',
   '_','N','A','M','E','_','U','Q',25,0,1,0,1,23,0,19,'R','D','B',
   '$','C','O','N','S','T','R','A','I','N','T','_','N','A','M',
   'E',25,0,2,0,1,23,0,15,'R','D','B','$','D','E','L','E','T','E',
   '_','R','U','L','E',25,0,3,0,1,23,0,15,'R','D','B','$','U','P',
   'D','A','T','E','_','R','U','L','E',25,0,4,0,1,21,8,0,1,0,0,
   0,25,0,5,0,-1,14,0,1,21,8,0,0,0,0,0,25,0,5,0,-1,-1,'L'
   };	/* end of blr string for request isc_189 */

static const short
   isc_197l = 254;
static const char
   isc_197 [] = {
   4,2,4,1,6,0,9,0,41,3,0,32,0,41,3,0,32,0,7,0,7,0,7,0,4,0,1,0,
   41,3,0,32,0,12,0,2,7,'C',1,'J',24,'R','D','B','$','P','R','O',
   'C','E','D','U','R','E','_','P','A','R','A','M','E','T','E',
   'R','S',0,'G',47,23,0,18,'R','D','B','$','P','R','O','C','E',
   'D','U','R','E','_','N','A','M','E',25,0,0,0,-1,14,1,2,1,23,
   0,15,'R','D','B','$','D','E','S','C','R','I','P','T','I','O',
   'N',25,1,0,0,1,23,0,16,'R','D','B','$','F','I','E','L','D','_',
   'S','O','U','R','C','E',25,1,1,0,1,23,0,18,'R','D','B','$','P',
   'A','R','A','M','E','T','E','R','_','N','A','M','E',25,1,2,0,
   1,21,8,0,1,0,0,0,25,1,3,0,1,23,0,18,'R','D','B','$','P','A',
   'R','A','M','E','T','E','R','_','T','Y','P','E',25,1,4,0,1,23,
   0,20,'R','D','B','$','P','A','R','A','M','E','T','E','R','_',
   'N','U','M','B','E','R',25,1,5,0,-1,14,1,1,21,8,0,0,0,0,0,25,
   1,3,0,-1,-1,'L'
   };	/* end of blr string for request isc_197 */

static const short
   isc_207l = 468;
static const char
   isc_207 [] = {
   4,2,4,1,18,0,41,3,0,32,0,41,3,0,32,0,9,0,9,0,9,0,41,3,0,32,0,
   41,3,0,32,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,4,0,
   1,0,41,3,0,32,0,12,0,2,7,'C',1,'J',24,'R','D','B','$','P','R',
   'O','C','E','D','U','R','E','_','P','A','R','A','M','E','T',
   'E','R','S',0,'G',47,23,0,18,'R','D','B','$','P','R','O','C',
   'E','D','U','R','E','_','N','A','M','E',25,0,0,0,-1,14,1,2,1,
   23,0,17,'R','D','B','$','R','E','L','A','T','I','O','N','_',
   'N','A','M','E',41,1,0,0,8,0,1,23,0,14,'R','D','B','$','F','I',
   'E','L','D','_','N','A','M','E',41,1,1,0,9,0,1,23,0,18,'R','D',
   'B','$','D','E','F','A','U','L','T','_','S','O','U','R','C',
   'E',25,1,2,0,1,23,0,17,'R','D','B','$','D','E','F','A','U','L',
   'T','_','V','A','L','U','E',25,1,3,0,1,23,0,15,'R','D','B','$',
   'D','E','S','C','R','I','P','T','I','O','N',25,1,4,0,1,23,0,
   16,'R','D','B','$','F','I','E','L','D','_','S','O','U','R','C',
   'E',25,1,5,0,1,23,0,18,'R','D','B','$','P','A','R','A','M','E',
   'T','E','R','_','N','A','M','E',25,1,6,0,1,21,8,0,1,0,0,0,25,
   1,7,0,1,23,0,23,'R','D','B','$','P','A','R','A','M','E','T',
   'E','R','_','M','E','C','H','A','N','I','S','M',41,1,11,0,10,
   0,1,23,0,13,'R','D','B','$','N','U','L','L','_','F','L','A',
   'G',41,1,13,0,12,0,1,23,0,16,'R','D','B','$','C','O','L','L',
   'A','T','I','O','N','_','I','D',41,1,15,0,14,0,1,23,0,18,'R',
   'D','B','$','P','A','R','A','M','E','T','E','R','_','T','Y',
   'P','E',25,1,16,0,1,23,0,20,'R','D','B','$','P','A','R','A',
   'M','E','T','E','R','_','N','U','M','B','E','R',25,1,17,0,-1,
   14,1,1,21,8,0,0,0,0,0,25,1,7,0,-1,-1,'L'
   };	/* end of blr string for request isc_207 */

static const short
   isc_229l = 346;
static const char
   isc_229 [] = {
   4,2,4,0,10,0,41,3,0,32,0,41,3,0,32,0,9,0,9,0,9,0,41,3,0,32,0,
   7,0,7,0,7,0,7,0,2,7,'C',1,'J',14,'R','D','B','$','P','R','O',
   'C','E','D','U','R','E','S',0,'G',57,61,23,0,15,'R','D','B',
   '$','S','Y','S','T','E','M','_','F','L','A','G',48,23,0,15,'R',
   'D','B','$','S','Y','S','T','E','M','_','F','L','A','G',21,8,
   0,1,0,0,0,-1,14,0,2,1,23,0,14,'R','D','B','$','O','W','N','E',
   'R','_','N','A','M','E',25,0,0,0,1,23,0,18,'R','D','B','$','S',
   'E','C','U','R','I','T','Y','_','C','L','A','S','S',41,0,1,0,
   7,0,1,23,0,17,'R','D','B','$','P','R','O','C','E','D','U','R',
   'E','_','B','L','R',25,0,2,0,1,23,0,20,'R','D','B','$','P','R',
   'O','C','E','D','U','R','E','_','S','O','U','R','C','E',25,0,
   3,0,1,23,0,15,'R','D','B','$','D','E','S','C','R','I','P','T',
   'I','O','N',25,0,4,0,1,23,0,18,'R','D','B','$','P','R','O','C',
   'E','D','U','R','E','_','N','A','M','E',25,0,5,0,1,21,8,0,1,
   0,0,0,25,0,6,0,1,23,0,21,'R','D','B','$','P','R','O','C','E',
   'D','U','R','E','_','O','U','T','P','U','T','S',25,0,8,0,1,23,
   0,20,'R','D','B','$','P','R','O','C','E','D','U','R','E','_',
   'I','N','P','U','T','S',25,0,9,0,-1,14,0,1,21,8,0,0,0,0,0,25,
   0,6,0,-1,-1,'L'
   };	/* end of blr string for request isc_229 */

static const short
   isc_241l = 437;
static const char
   isc_241 [] = {
   4,2,4,0,17,0,9,0,41,3,0,32,0,41,3,0,32,0,9,0,9,0,9,0,41,3,0,
   32,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,2,7,'C',1,'J',14,
   'R','D','B','$','P','R','O','C','E','D','U','R','E','S',0,'G',
   57,61,23,0,15,'R','D','B','$','S','Y','S','T','E','M','_','F',
   'L','A','G',48,23,0,15,'R','D','B','$','S','Y','S','T','E','M',
   '_','F','L','A','G',21,8,0,1,0,0,0,-1,14,0,2,1,23,0,14,'R','D',
   'B','$','D','E','B','U','G','_','I','N','F','O',41,0,0,0,8,0,
   1,23,0,14,'R','D','B','$','O','W','N','E','R','_','N','A','M',
   'E',41,0,1,0,13,0,1,23,0,18,'R','D','B','$','S','E','C','U',
   'R','I','T','Y','_','C','L','A','S','S',41,0,2,0,14,0,1,23,0,
   17,'R','D','B','$','P','R','O','C','E','D','U','R','E','_','B',
   'L','R',25,0,3,0,1,23,0,20,'R','D','B','$','P','R','O','C','E',
   'D','U','R','E','_','S','O','U','R','C','E',25,0,4,0,1,23,0,
   15,'R','D','B','$','D','E','S','C','R','I','P','T','I','O','N',
   25,0,5,0,1,23,0,18,'R','D','B','$','P','R','O','C','E','D','U',
   'R','E','_','N','A','M','E',25,0,6,0,1,21,8,0,1,0,0,0,25,0,7,
   0,1,23,0,13,'R','D','B','$','V','A','L','I','D','_','B','L',
   'R',41,0,10,0,9,0,1,23,0,18,'R','D','B','$','P','R','O','C',
   'E','D','U','R','E','_','T','Y','P','E',41,0,12,0,11,0,1,23,
   0,21,'R','D','B','$','P','R','O','C','E','D','U','R','E','_',
   'O','U','T','P','U','T','S',25,0,15,0,1,23,0,20,'R','D','B',
   '$','P','R','O','C','E','D','U','R','E','_','I','N','P','U',
   'T','S',25,0,16,0,-1,14,0,1,21,8,0,0,0,0,0,25,0,7,0,-1,-1,'L'
   
   };	/* end of blr string for request isc_241 */

static const short
   isc_260l = 126;
static const char
   isc_260 [] = {
   4,2,4,1,3,0,7,0,7,0,7,0,4,0,1,0,41,3,0,32,0,12,0,2,7,'C',1,'J',
   10,'R','D','B','$','F','I','E','L','D','S',0,'G',47,23,0,14,
   'R','D','B','$','F','I','E','L','D','_','N','A','M','E',25,0,
   0,0,-1,14,1,2,1,21,8,0,1,0,0,0,25,1,0,0,1,23,0,19,'R','D','B',
   '$','F','I','E','L','D','_','P','R','E','C','I','S','I','O',
   'N',41,1,2,0,1,0,-1,14,1,1,21,8,0,0,0,0,0,25,1,0,0,-1,-1,'L'
   
   };	/* end of blr string for request isc_260 */

static const short
   isc_267l = 282;
static const char
   isc_267 [] = {
   4,2,4,1,13,0,9,0,9,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,
   7,0,4,0,1,0,41,3,0,32,0,12,0,2,7,'C',1,'J',10,'R','D','B','$',
   'F','I','E','L','D','S',0,'G',47,23,0,14,'R','D','B','$','F',
   'I','E','L','D','_','N','A','M','E',25,0,0,0,-1,14,1,2,1,23,
   0,18,'R','D','B','$','M','I','S','S','I','N','G','_','S','O',
   'U','R','C','E',41,1,0,0,7,0,1,23,0,18,'R','D','B','$','D','E',
   'F','A','U','L','T','_','S','O','U','R','C','E',41,1,1,0,8,0,
   1,21,8,0,1,0,0,0,25,1,2,0,1,23,0,16,'R','D','B','$','C','O',
   'L','L','A','T','I','O','N','_','I','D',41,1,4,0,3,0,1,23,0,
   20,'R','D','B','$','C','H','A','R','A','C','T','E','R','_','S',
   'E','T','_','I','D',41,1,6,0,5,0,1,23,0,20,'R','D','B','$','C',
   'H','A','R','A','C','T','E','R','_','L','E','N','G','T','H',
   41,1,10,0,9,0,1,23,0,13,'R','D','B','$','N','U','L','L','_',
   'F','L','A','G',41,1,12,0,11,0,-1,14,1,1,21,8,0,0,0,0,0,25,1,
   2,0,-1,-1,'L'
   };	/* end of blr string for request isc_267 */

static const short
   isc_284l = 201;
static const char
   isc_284 [] = {
   4,2,4,1,5,0,7,0,7,0,7,0,7,0,7,0,4,0,1,0,41,3,0,32,0,12,0,2,7,
   'C',1,'J',10,'R','D','B','$','F','I','E','L','D','S',0,'G',47,
   23,0,14,'R','D','B','$','F','I','E','L','D','_','N','A','M',
   'E',25,0,0,0,-1,14,1,2,1,21,8,0,1,0,0,0,25,1,0,0,1,23,0,14,'R',
   'D','B','$','D','I','M','E','N','S','I','O','N','S',25,1,1,0,
   1,23,0,18,'R','D','B','$','E','X','T','E','R','N','A','L','_',
   'S','C','A','L','E',25,1,2,0,1,23,0,17,'R','D','B','$','E','X',
   'T','E','R','N','A','L','_','T','Y','P','E',25,1,3,0,1,23,0,
   19,'R','D','B','$','E','X','T','E','R','N','A','L','_','L','E',
   'N','G','T','H',25,1,4,0,-1,14,1,1,21,8,0,0,0,0,0,25,1,0,0,-1,
   -1,'L'
   };	/* end of blr string for request isc_284 */

static const short
   isc_293l = 571;
static const char
   isc_293 [] = {
   4,2,4,0,20,0,9,0,9,0,9,0,9,0,9,0,9,0,9,0,9,0,41,0,0,-128,0,41,
   3,0,32,0,41,3,0,32,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,2,7,
   'C',1,'J',10,'R','D','B','$','F','I','E','L','D','S',0,'G',57,
   48,23,0,15,'R','D','B','$','S','Y','S','T','E','M','_','F','L',
   'A','G',21,8,0,1,0,0,0,61,23,0,15,'R','D','B','$','S','Y','S',
   'T','E','M','_','F','L','A','G',-1,14,0,2,1,23,0,15,'R','D',
   'B','$','D','E','S','C','R','I','P','T','I','O','N',25,0,0,0,
   1,23,0,19,'R','D','B','$','C','O','M','P','U','T','E','D','_',
   'S','O','U','R','C','E',25,0,1,0,1,23,0,16,'R','D','B','$','C',
   'O','M','P','U','T','E','D','_','B','L','R',25,0,2,0,1,23,0,
   21,'R','D','B','$','V','A','L','I','D','A','T','I','O','N','_',
   'S','O','U','R','C','E',25,0,3,0,1,23,0,18,'R','D','B','$','V',
   'A','L','I','D','A','T','I','O','N','_','B','L','R',25,0,4,0,
   1,23,0,17,'R','D','B','$','D','E','F','A','U','L','T','_','V',
   'A','L','U','E',25,0,5,0,1,23,0,17,'R','D','B','$','M','I','S',
   'S','I','N','G','_','V','A','L','U','E',25,0,6,0,1,23,0,16,'R',
   'D','B','$','Q','U','E','R','Y','_','H','E','A','D','E','R',
   25,0,7,0,1,23,0,15,'R','D','B','$','E','D','I','T','_','S','T',
   'R','I','N','G',41,0,8,0,18,0,1,23,0,14,'R','D','B','$','Q',
   'U','E','R','Y','_','N','A','M','E',41,0,9,0,19,0,1,23,0,14,
   'R','D','B','$','F','I','E','L','D','_','N','A','M','E',25,0,
   10,0,1,21,8,0,1,0,0,0,25,0,11,0,1,23,0,15,'R','D','B','$','S',
   'Y','S','T','E','M','_','F','L','A','G',25,0,12,0,1,23,0,18,
   'R','D','B','$','S','E','G','M','E','N','T','_','L','E','N',
   'G','T','H',25,0,13,0,1,23,0,15,'R','D','B','$','F','I','E',
   'L','D','_','S','C','A','L','E',25,0,14,0,1,23,0,18,'R','D',
   'B','$','F','I','E','L','D','_','S','U','B','_','T','Y','P',
   'E',25,0,15,0,1,23,0,16,'R','D','B','$','F','I','E','L','D',
   '_','L','E','N','G','T','H',25,0,16,0,1,23,0,14,'R','D','B',
   '$','F','I','E','L','D','_','T','Y','P','E',25,0,17,0,-1,14,
   0,1,21,8,0,0,0,0,0,25,0,11,0,-1,-1,'L'
   };	/* end of blr string for request isc_293 */

static const short
   isc_315l = 901;
static const char
   isc_315 [] = {
   4,2,4,0,38,0,9,0,9,0,9,0,9,0,9,0,9,0,9,0,9,0,9,0,9,0,41,0,0,
   -128,0,41,3,0,32,0,41,3,0,32,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,
   0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,
   0,7,0,7,0,2,7,'C',1,'J',10,'R','D','B','$','F','I','E','L','D',
   'S',0,'G',57,48,23,0,15,'R','D','B','$','S','Y','S','T','E',
   'M','_','F','L','A','G',21,8,0,1,0,0,0,61,23,0,15,'R','D','B',
   '$','S','Y','S','T','E','M','_','F','L','A','G',-1,14,0,2,1,
   23,0,18,'R','D','B','$','M','I','S','S','I','N','G','_','S',
   'O','U','R','C','E',41,0,0,0,20,0,1,23,0,18,'R','D','B','$',
   'D','E','F','A','U','L','T','_','S','O','U','R','C','E',41,0,
   1,0,21,0,1,23,0,15,'R','D','B','$','D','E','S','C','R','I','P',
   'T','I','O','N',25,0,2,0,1,23,0,19,'R','D','B','$','C','O','M',
   'P','U','T','E','D','_','S','O','U','R','C','E',25,0,3,0,1,23,
   0,16,'R','D','B','$','C','O','M','P','U','T','E','D','_','B',
   'L','R',25,0,4,0,1,23,0,21,'R','D','B','$','V','A','L','I','D',
   'A','T','I','O','N','_','S','O','U','R','C','E',25,0,5,0,1,23,
   0,18,'R','D','B','$','V','A','L','I','D','A','T','I','O','N',
   '_','B','L','R',25,0,6,0,1,23,0,17,'R','D','B','$','D','E','F',
   'A','U','L','T','_','V','A','L','U','E',25,0,7,0,1,23,0,17,'R',
   'D','B','$','M','I','S','S','I','N','G','_','V','A','L','U',
   'E',25,0,8,0,1,23,0,16,'R','D','B','$','Q','U','E','R','Y','_',
   'H','E','A','D','E','R',25,0,9,0,1,23,0,15,'R','D','B','$','E',
   'D','I','T','_','S','T','R','I','N','G',41,0,10,0,'$',0,1,23,
   0,14,'R','D','B','$','Q','U','E','R','Y','_','N','A','M','E',
   41,0,11,0,37,0,1,23,0,14,'R','D','B','$','F','I','E','L','D',
   '_','N','A','M','E',25,0,12,0,1,21,8,0,1,0,0,0,25,0,13,0,1,23,
   0,19,'R','D','B','$','F','I','E','L','D','_','P','R','E','C',
   'I','S','I','O','N',41,0,15,0,14,0,1,23,0,16,'R','D','B','$',
   'C','O','L','L','A','T','I','O','N','_','I','D',41,0,17,0,16,
   0,1,23,0,20,'R','D','B','$','C','H','A','R','A','C','T','E',
   'R','_','S','E','T','_','I','D',41,0,19,0,18,0,1,23,0,20,'R',
   'D','B','$','C','H','A','R','A','C','T','E','R','_','L','E',
   'N','G','T','H',41,0,23,0,22,0,1,23,0,13,'R','D','B','$','N',
   'U','L','L','_','F','L','A','G',41,0,25,0,24,0,1,23,0,14,'R',
   'D','B','$','D','I','M','E','N','S','I','O','N','S',25,0,26,
   0,1,23,0,18,'R','D','B','$','E','X','T','E','R','N','A','L',
   '_','S','C','A','L','E',25,0,27,0,1,23,0,17,'R','D','B','$',
   'E','X','T','E','R','N','A','L','_','T','Y','P','E',25,0,28,
   0,1,23,0,19,'R','D','B','$','E','X','T','E','R','N','A','L',
   '_','L','E','N','G','T','H',25,0,29,0,1,23,0,15,'R','D','B',
   '$','S','Y','S','T','E','M','_','F','L','A','G',25,0,30,0,1,
   23,0,18,'R','D','B','$','S','E','G','M','E','N','T','_','L',
   'E','N','G','T','H',25,0,31,0,1,23,0,15,'R','D','B','$','F',
   'I','E','L','D','_','S','C','A','L','E',25,0,32,0,1,23,0,18,
   'R','D','B','$','F','I','E','L','D','_','S','U','B','_','T',
   'Y','P','E',25,0,33,0,1,23,0,16,'R','D','B','$','F','I','E',
   'L','D','_','L','E','N','G','T','H',25,0,34,0,1,23,0,14,'R',
   'D','B','$','F','I','E','L','D','_','T','Y','P','E',25,0,35,
   0,-1,14,0,1,21,8,0,0,0,0,0,25,0,13,0,-1,-1,'L'
   };	/* end of blr string for request isc_315 */

static const short
   isc_355l = 141;
static const char
   isc_355 [] = {
   4,2,4,0,2,0,41,3,0,32,0,7,0,2,7,'C',1,'J',14,'R','D','B','$',
   'G','E','N','E','R','A','T','O','R','S',0,'G',57,61,23,0,15,
   'R','D','B','$','S','Y','S','T','E','M','_','F','L','A','G',
   48,23,0,15,'R','D','B','$','S','Y','S','T','E','M','_','F','L',
   'A','G',21,8,0,1,0,0,0,-1,14,0,2,1,23,0,18,'R','D','B','$','G',
   'E','N','E','R','A','T','O','R','_','N','A','M','E',25,0,0,0,
   1,21,8,0,1,0,0,0,25,0,1,0,-1,14,0,1,21,8,0,0,0,0,0,25,0,1,0,
   -1,-1,'L'
   };	/* end of blr string for request isc_355 */

static const short
   isc_359l = 170;
static const char
   isc_359 [] = {
   4,2,4,0,4,0,9,0,41,3,0,32,0,7,0,7,0,2,7,'C',1,'J',14,'R','D',
   'B','$','G','E','N','E','R','A','T','O','R','S',0,'G',57,61,
   23,0,15,'R','D','B','$','S','Y','S','T','E','M','_','F','L',
   'A','G',48,23,0,15,'R','D','B','$','S','Y','S','T','E','M','_',
   'F','L','A','G',21,8,0,1,0,0,0,-1,14,0,2,1,23,0,15,'R','D','B',
   '$','D','E','S','C','R','I','P','T','I','O','N',41,0,0,0,3,0,
   1,23,0,18,'R','D','B','$','G','E','N','E','R','A','T','O','R',
   '_','N','A','M','E',25,0,1,0,1,21,8,0,1,0,0,0,25,0,2,0,-1,14,
   0,1,21,8,0,0,0,0,0,25,0,2,0,-1,-1,'L'
   };	/* end of blr string for request isc_359 */

static const short
   isc_365l = 174;
static const char
   isc_365 [] = {
   4,2,4,1,3,0,7,0,7,0,7,0,4,0,2,0,41,3,0,32,0,7,0,12,0,2,7,'C',
   1,'J',22,'R','D','B','$','F','U','N','C','T','I','O','N','_',
   'A','R','G','U','M','E','N','T','S',0,'G',58,47,23,0,17,'R',
   'D','B','$','F','U','N','C','T','I','O','N','_','N','A','M',
   'E',25,0,0,0,47,23,0,21,'R','D','B','$','A','R','G','U','M',
   'E','N','T','_','P','O','S','I','T','I','O','N',25,0,1,0,-1,
   14,1,2,1,21,8,0,1,0,0,0,25,1,0,0,1,23,0,20,'R','D','B','$','C',
   'H','A','R','A','C','T','E','R','_','S','E','T','_','I','D',
   41,1,2,0,1,0,-1,14,1,1,21,8,0,0,0,0,0,25,1,0,0,-1,-1,'L'
   };	/* end of blr string for request isc_365 */

static const short
   isc_373l = 295;
static const char
   isc_373 [] = {
   4,2,4,1,8,0,41,3,0,32,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,4,0,1,0,
   41,3,0,32,0,12,0,2,7,'C',1,'J',22,'R','D','B','$','F','U','N',
   'C','T','I','O','N','_','A','R','G','U','M','E','N','T','S',
   0,'G',47,23,0,17,'R','D','B','$','F','U','N','C','T','I','O',
   'N','_','N','A','M','E',25,0,0,0,-1,14,1,2,1,23,0,17,'R','D',
   'B','$','F','U','N','C','T','I','O','N','_','N','A','M','E',
   25,1,0,0,1,21,8,0,1,0,0,0,25,1,1,0,1,23,0,18,'R','D','B','$',
   'F','I','E','L','D','_','S','U','B','_','T','Y','P','E',25,1,
   2,0,1,23,0,16,'R','D','B','$','F','I','E','L','D','_','L','E',
   'N','G','T','H',25,1,3,0,1,23,0,15,'R','D','B','$','F','I','E',
   'L','D','_','S','C','A','L','E',25,1,4,0,1,23,0,14,'R','D','B',
   '$','F','I','E','L','D','_','T','Y','P','E',25,1,5,0,1,23,0,
   13,'R','D','B','$','M','E','C','H','A','N','I','S','M',25,1,
   6,0,1,23,0,21,'R','D','B','$','A','R','G','U','M','E','N','T',
   '_','P','O','S','I','T','I','O','N',25,1,7,0,-1,14,1,1,21,8,
   0,0,0,0,0,25,1,1,0,-1,-1,'L'
   };	/* end of blr string for request isc_373 */

static const short
   isc_385l = 362;
static const char
   isc_385 [] = {
   4,2,4,1,12,0,41,3,0,32,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,
   7,0,7,0,4,0,1,0,41,3,0,32,0,12,0,2,7,'C',1,'J',22,'R','D','B',
   '$','F','U','N','C','T','I','O','N','_','A','R','G','U','M',
   'E','N','T','S',0,'G',47,23,0,17,'R','D','B','$','F','U','N',
   'C','T','I','O','N','_','N','A','M','E',25,0,0,0,-1,14,1,2,1,
   23,0,17,'R','D','B','$','F','U','N','C','T','I','O','N','_',
   'N','A','M','E',25,1,0,0,1,21,8,0,1,0,0,0,25,1,1,0,1,23,0,19,
   'R','D','B','$','F','I','E','L','D','_','P','R','E','C','I',
   'S','I','O','N',41,1,3,0,2,0,1,23,0,20,'R','D','B','$','C','H',
   'A','R','A','C','T','E','R','_','S','E','T','_','I','D',41,1,
   5,0,4,0,1,23,0,18,'R','D','B','$','F','I','E','L','D','_','S',
   'U','B','_','T','Y','P','E',25,1,6,0,1,23,0,16,'R','D','B','$',
   'F','I','E','L','D','_','L','E','N','G','T','H',25,1,7,0,1,23,
   0,15,'R','D','B','$','F','I','E','L','D','_','S','C','A','L',
   'E',25,1,8,0,1,23,0,14,'R','D','B','$','F','I','E','L','D','_',
   'T','Y','P','E',25,1,9,0,1,23,0,13,'R','D','B','$','M','E','C',
   'H','A','N','I','S','M',25,1,10,0,1,23,0,21,'R','D','B','$',
   'A','R','G','U','M','E','N','T','_','P','O','S','I','T','I',
   'O','N',25,1,11,0,-1,14,1,1,21,8,0,0,0,0,0,25,1,1,0,-1,-1,'L'
   
   };	/* end of blr string for request isc_385 */

static const short
   isc_401l = 302;
static const char
   isc_401 [] = {
   4,2,4,0,8,0,41,3,0,32,0,41,0,0,32,0,41,0,0,0,1,9,0,41,3,0,32,
   0,7,0,7,0,7,0,2,7,'C',1,'J',13,'R','D','B','$','F','U','N','C',
   'T','I','O','N','S',0,'G',57,61,23,0,15,'R','D','B','$','S',
   'Y','S','T','E','M','_','F','L','A','G',48,23,0,15,'R','D','B',
   '$','S','Y','S','T','E','M','_','F','L','A','G',21,8,0,1,0,0,
   0,-1,14,0,2,1,23,0,14,'R','D','B','$','Q','U','E','R','Y','_',
   'N','A','M','E',25,0,0,0,1,23,0,14,'R','D','B','$','E','N','T',
   'R','Y','P','O','I','N','T',25,0,1,0,1,23,0,15,'R','D','B','$',
   'M','O','D','U','L','E','_','N','A','M','E',25,0,2,0,1,23,0,
   15,'R','D','B','$','D','E','S','C','R','I','P','T','I','O','N',
   25,0,3,0,1,23,0,17,'R','D','B','$','F','U','N','C','T','I','O',
   'N','_','N','A','M','E',25,0,4,0,1,21,8,0,1,0,0,0,25,0,5,0,1,
   23,0,17,'R','D','B','$','F','U','N','C','T','I','O','N','_',
   'T','Y','P','E',25,0,6,0,1,23,0,19,'R','D','B','$','R','E','T',
   'U','R','N','_','A','R','G','U','M','E','N','T',25,0,7,0,-1,
   14,0,1,21,8,0,0,0,0,0,25,0,5,0,-1,-1,'L'
   };	/* end of blr string for request isc_401 */

static const short
   isc_411l = 274;
static const char
   isc_411 [] = {
   4,2,4,0,7,0,41,0,0,32,0,41,0,0,0,1,9,0,41,3,0,32,0,7,0,7,0,7,
   0,2,7,'C',1,'J',11,'R','D','B','$','F','I','L','T','E','R','S',
   0,'G',57,61,23,0,15,'R','D','B','$','S','Y','S','T','E','M',
   '_','F','L','A','G',48,23,0,15,'R','D','B','$','S','Y','S','T',
   'E','M','_','F','L','A','G',21,8,0,1,0,0,0,-1,14,0,2,1,23,0,
   14,'R','D','B','$','E','N','T','R','Y','P','O','I','N','T',25,
   0,0,0,1,23,0,15,'R','D','B','$','M','O','D','U','L','E','_',
   'N','A','M','E',25,0,1,0,1,23,0,15,'R','D','B','$','D','E','S',
   'C','R','I','P','T','I','O','N',25,0,2,0,1,23,0,17,'R','D','B',
   '$','F','U','N','C','T','I','O','N','_','N','A','M','E',25,0,
   3,0,1,21,8,0,1,0,0,0,25,0,4,0,1,23,0,19,'R','D','B','$','O',
   'U','T','P','U','T','_','S','U','B','_','T','Y','P','E',25,0,
   5,0,1,23,0,18,'R','D','B','$','I','N','P','U','T','_','S','U',
   'B','_','T','Y','P','E',25,0,6,0,-1,14,0,1,21,8,0,0,0,0,0,25,
   0,4,0,-1,-1,'L'
   };	/* end of blr string for request isc_411 */

static const short
   isc_420l = 169;
static const char
   isc_420 [] = {
   4,2,4,0,5,0,41,3,0,32,0,8,0,8,0,7,0,7,0,2,7,'C',1,'J',20,'R',
   'D','B','$','F','I','E','L','D','_','D','I','M','E','N','S',
   'I','O','N','S',0,-1,14,0,2,1,23,0,14,'R','D','B','$','F','I',
   'E','L','D','_','N','A','M','E',25,0,0,0,1,23,0,15,'R','D','B',
   '$','U','P','P','E','R','_','B','O','U','N','D',25,0,1,0,1,23,
   0,15,'R','D','B','$','L','O','W','E','R','_','B','O','U','N',
   'D',25,0,2,0,1,21,8,0,1,0,0,0,25,0,3,0,1,23,0,13,'R','D','B',
   '$','D','I','M','E','N','S','I','O','N',25,0,4,0,-1,14,0,1,21,
   8,0,0,0,0,0,25,0,3,0,-1,-1,'L'
   };	/* end of blr string for request isc_420 */

static const short
   isc_427l = 190;
static const char
   isc_427 [] = {
   4,2,4,0,4,0,9,0,41,0,0,0,4,41,3,0,32,0,7,0,2,7,'C',1,'J',14,
   'R','D','B','$','E','X','C','E','P','T','I','O','N','S',0,'G',
   57,61,23,0,15,'R','D','B','$','S','Y','S','T','E','M','_','F',
   'L','A','G',48,23,0,15,'R','D','B','$','S','Y','S','T','E','M',
   '_','F','L','A','G',21,8,0,1,0,0,0,-1,14,0,2,1,23,0,15,'R','D',
   'B','$','D','E','S','C','R','I','P','T','I','O','N',25,0,0,0,
   1,23,0,11,'R','D','B','$','M','E','S','S','A','G','E',25,0,1,
   0,1,23,0,18,'R','D','B','$','E','X','C','E','P','T','I','O',
   'N','_','N','A','M','E',25,0,2,0,1,21,8,0,1,0,0,0,25,0,3,0,-1,
   14,0,1,21,8,0,0,0,0,0,25,0,3,0,-1,-1,'L'
   };	/* end of blr string for request isc_427 */

static const short
   isc_433l = 100;
static const char
   isc_433 [] = {
   4,2,4,0,3,0,41,3,0,32,0,7,0,7,0,2,7,'C',1,'J',12,'R','D','B',
   '$','D','A','T','A','B','A','S','E',0,-1,14,0,2,1,23,0,22,'R',
   'D','B','$','C','H','A','R','A','C','T','E','R','_','S','E',
   'T','_','N','A','M','E',41,0,0,0,2,0,1,21,8,0,1,0,0,0,25,0,1,
   0,-1,14,0,1,21,8,0,0,0,0,0,25,0,1,0,-1,-1,'L'
   };	/* end of blr string for request isc_433 */

static const short
   isc_438l = 86;
static const char
   isc_438 [] = {
   4,2,4,0,2,0,9,0,7,0,2,7,'C',1,'J',12,'R','D','B','$','D','A',
   'T','A','B','A','S','E',0,-1,14,0,2,1,23,0,15,'R','D','B','$',
   'D','E','S','C','R','I','P','T','I','O','N',25,0,0,0,1,21,8,
   0,1,0,0,0,25,0,1,0,-1,14,0,1,21,8,0,0,0,0,0,25,0,1,0,-1,-1,'L'
   
   };	/* end of blr string for request isc_438 */

static const short
   isc_442l = 96;
static const char
   isc_442 [] = {
   4,2,4,0,3,0,41,3,0,32,0,7,0,7,0,2,7,'C',1,'J',12,'R','D','B',
   '$','D','A','T','A','B','A','S','E',0,-1,14,0,2,1,23,0,18,'R',
   'D','B','$','S','E','C','U','R','I','T','Y','_','C','L','A',
   'S','S',41,0,0,0,2,0,1,21,8,0,1,0,0,0,25,0,1,0,-1,14,0,1,21,
   8,0,0,0,0,0,25,0,1,0,-1,-1,'L'
   };	/* end of blr string for request isc_442 */

static const short
   isc_447l = 160;
static const char
   isc_447 [] = {
   4,2,4,0,6,0,41,3,0,32,0,9,0,41,3,0,32,0,7,0,7,0,7,0,2,7,'C',
   1,'J',12,'R','D','B','$','D','A','T','A','B','A','S','E',0,-1,
   14,0,2,1,23,0,22,'R','D','B','$','C','H','A','R','A','C','T',
   'E','R','_','S','E','T','_','N','A','M','E',41,0,0,0,4,0,1,23,
   0,15,'R','D','B','$','D','E','S','C','R','I','P','T','I','O',
   'N',25,0,1,0,1,23,0,18,'R','D','B','$','S','E','C','U','R','I',
   'T','Y','_','C','L','A','S','S',41,0,2,0,5,0,1,21,8,0,1,0,0,
   0,25,0,3,0,-1,14,0,1,21,8,0,0,0,0,0,25,0,3,0,-1,-1,'L'
   };	/* end of blr string for request isc_447 */

static const short
   isc_455l = 319;
static const char
   isc_455 [] = {
   4,2,4,0,10,0,41,3,0,32,0,9,0,41,3,0,32,0,7,0,7,0,7,0,7,0,7,0,
   7,0,7,0,2,7,'C',1,'J',14,'R','D','B','$','C','O','L','L','A',
   'T','I','O','N','S',0,'G',57,61,23,0,15,'R','D','B','$','S',
   'Y','S','T','E','M','_','F','L','A','G',48,23,0,15,'R','D','B',
   '$','S','Y','S','T','E','M','_','F','L','A','G',21,8,0,1,0,0,
   0,-1,14,0,2,1,23,0,17,'R','D','B','$','F','U','N','C','T','I',
   'O','N','_','N','A','M','E',41,0,0,0,4,0,1,23,0,15,'R','D','B',
   '$','D','E','S','C','R','I','P','T','I','O','N',41,0,1,0,5,0,
   1,23,0,18,'R','D','B','$','C','O','L','L','A','T','I','O','N',
   '_','N','A','M','E',25,0,2,0,1,21,8,0,1,0,0,0,25,0,3,0,1,23,
   0,15,'R','D','B','$','S','Y','S','T','E','M','_','F','L','A',
   'G',25,0,6,0,1,23,0,24,'R','D','B','$','C','O','L','L','A','T',
   'I','O','N','_','A','T','T','R','I','B','U','T','E','S',25,0,
   7,0,1,23,0,20,'R','D','B','$','C','H','A','R','A','C','T','E',
   'R','_','S','E','T','_','I','D',25,0,8,0,1,23,0,16,'R','D','B',
   '$','C','O','L','L','A','T','I','O','N','_','I','D',25,0,9,0,
   -1,14,0,1,21,8,0,0,0,0,0,25,0,3,0,-1,-1,'L'
   };	/* end of blr string for request isc_455 */

static const short
   isc_467l = 396;
static const char
   isc_467 [] = {
   4,2,4,0,14,0,9,0,41,3,0,32,0,41,3,0,32,0,9,0,41,3,0,32,0,7,0,
   7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,2,7,'C',1,'J',14,'R','D','B',
   '$','C','O','L','L','A','T','I','O','N','S',0,'G',57,61,23,0,
   15,'R','D','B','$','S','Y','S','T','E','M','_','F','L','A','G',
   48,23,0,15,'R','D','B','$','S','Y','S','T','E','M','_','F','L',
   'A','G',21,8,0,1,0,0,0,-1,14,0,2,1,23,0,23,'R','D','B','$','S',
   'P','E','C','I','F','I','C','_','A','T','T','R','I','B','U',
   'T','E','S',41,0,0,0,6,0,1,23,0,23,'R','D','B','$','B','A','S',
   'E','_','C','O','L','L','A','T','I','O','N','_','N','A','M',
   'E',41,0,1,0,7,0,1,23,0,17,'R','D','B','$','F','U','N','C','T',
   'I','O','N','_','N','A','M','E',41,0,2,0,8,0,1,23,0,15,'R','D',
   'B','$','D','E','S','C','R','I','P','T','I','O','N',41,0,3,0,
   9,0,1,23,0,18,'R','D','B','$','C','O','L','L','A','T','I','O',
   'N','_','N','A','M','E',25,0,4,0,1,21,8,0,1,0,0,0,25,0,5,0,1,
   23,0,15,'R','D','B','$','S','Y','S','T','E','M','_','F','L',
   'A','G',25,0,10,0,1,23,0,24,'R','D','B','$','C','O','L','L',
   'A','T','I','O','N','_','A','T','T','R','I','B','U','T','E',
   'S',25,0,11,0,1,23,0,20,'R','D','B','$','C','H','A','R','A',
   'C','T','E','R','_','S','E','T','_','I','D',25,0,12,0,1,23,0,
   16,'R','D','B','$','C','O','L','L','A','T','I','O','N','_','I',
   'D',25,0,13,0,-1,14,0,1,21,8,0,0,0,0,0,25,0,5,0,-1,-1,'L'
   };	/* end of blr string for request isc_467 */

static const short
   isc_483l = 135;
static const char
   isc_483 [] = {
   4,2,4,0,4,0,41,3,0,32,0,41,3,0,32,0,7,0,7,0,2,7,'C',1,'J',21,
   'R','D','B','$','C','H','E','C','K','_','C','O','N','S','T',
   'R','A','I','N','T','S',0,-1,14,0,2,1,23,0,16,'R','D','B','$',
   'T','R','I','G','G','E','R','_','N','A','M','E',41,0,0,0,3,0,
   1,23,0,19,'R','D','B','$','C','O','N','S','T','R','A','I','N',
   'T','_','N','A','M','E',25,0,1,0,1,21,8,0,1,0,0,0,25,0,2,0,-1,
   14,0,1,21,8,0,0,0,0,0,25,0,2,0,-1,-1,'L'
   };	/* end of blr string for request isc_483 */

static const short
   isc_489l = 465;
static const char
   isc_489 [] = {
   4,2,4,0,15,0,41,3,0,32,0,41,3,0,32,0,9,0,41,3,0,32,0,41,3,0,
   32,0,8,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,2,7,'C',1,'J',18,
   'R','D','B','$','C','H','A','R','A','C','T','E','R','_','S',
   'E','T','S',0,'G',57,61,23,0,15,'R','D','B','$','S','Y','S',
   'T','E','M','_','F','L','A','G',57,48,23,0,15,'R','D','B','$',
   'S','Y','S','T','E','M','_','F','L','A','G',21,8,0,1,0,0,0,48,
   23,0,24,'R','D','B','$','D','E','F','A','U','L','T','_','C',
   'O','L','L','A','T','E','_','N','A','M','E',23,0,22,'R','D',
   'B','$','C','H','A','R','A','C','T','E','R','_','S','E','T',
   '_','N','A','M','E',-1,14,0,2,1,23,0,24,'R','D','B','$','D',
   'E','F','A','U','L','T','_','C','O','L','L','A','T','E','_',
   'N','A','M','E',25,0,0,0,1,23,0,17,'R','D','B','$','F','U','N',
   'C','T','I','O','N','_','N','A','M','E',41,0,1,0,8,0,1,23,0,
   15,'R','D','B','$','D','E','S','C','R','I','P','T','I','O','N',
   41,0,2,0,9,0,1,23,0,15,'R','D','B','$','F','O','R','M','_','O',
   'F','_','U','S','E',41,0,3,0,12,0,1,23,0,22,'R','D','B','$',
   'C','H','A','R','A','C','T','E','R','_','S','E','T','_','N',
   'A','M','E',25,0,4,0,1,23,0,24,'R','D','B','$','N','U','M','B',
   'E','R','_','O','F','_','C','H','A','R','A','C','T','E','R',
   'S',41,0,5,0,11,0,1,21,8,0,1,0,0,0,25,0,6,0,1,23,0,23,'R','D',
   'B','$','B','Y','T','E','S','_','P','E','R','_','C','H','A',
   'R','A','C','T','E','R',25,0,7,0,1,23,0,20,'R','D','B','$','C',
   'H','A','R','A','C','T','E','R','_','S','E','T','_','I','D',
   25,0,10,0,1,23,0,15,'R','D','B','$','S','Y','S','T','E','M',
   '_','F','L','A','G',41,0,14,0,13,0,-1,14,0,1,21,8,0,0,0,0,0,
   25,0,6,0,-1,-1,'L'
   };	/* end of blr string for request isc_489 */

static const short
   isc_506l = 133;
static const char
   isc_506 [] = {
   4,2,4,1,1,0,7,0,4,0,2,0,41,3,0,32,0,41,3,0,32,0,12,0,2,7,'C',
   1,'J',19,'R','D','B','$','R','E','L','A','T','I','O','N','_',
   'F','I','E','L','D','S',0,'G',58,47,23,0,17,'R','D','B','$',
   'R','E','L','A','T','I','O','N','_','N','A','M','E',25,0,1,0,
   47,23,0,14,'R','D','B','$','F','I','E','L','D','_','N','A','M',
   'E',25,0,0,0,-1,14,1,2,1,21,8,0,1,0,0,0,25,1,0,0,-1,14,1,1,21,
   8,0,0,0,0,0,25,1,0,0,-1,-1,'L'
   };	/* end of blr string for request isc_506 */

static const short
   isc_512l = 156;
static const char
   isc_512 [] = {
   4,2,4,1,3,0,41,3,0,32,0,7,0,7,0,4,0,1,0,41,3,0,32,0,12,0,2,7,
   'C',1,'J',18,'R','D','B','$','V','I','E','W','_','R','E','L',
   'A','T','I','O','N','S',0,'G',47,23,0,13,'R','D','B','$','V',
   'I','E','W','_','N','A','M','E',25,0,0,0,-1,14,1,2,1,23,0,17,
   'R','D','B','$','R','E','L','A','T','I','O','N','_','N','A',
   'M','E',25,1,0,0,1,21,8,0,1,0,0,0,25,1,1,0,1,23,0,16,'R','D',
   'B','$','V','I','E','W','_','C','O','N','T','E','X','T',25,1,
   2,0,-1,14,1,1,21,8,0,0,0,0,0,25,1,1,0,-1,-1,'L'
   };	/* end of blr string for request isc_512 */

static const short
   isc_519l = 185;
static const char
   isc_519 [] = {
   4,2,4,1,4,0,41,3,0,0,1,41,3,0,32,0,7,0,7,0,4,0,1,0,41,3,0,32,
   0,12,0,2,7,'C',1,'J',18,'R','D','B','$','V','I','E','W','_',
   'R','E','L','A','T','I','O','N','S',0,'G',47,23,0,13,'R','D',
   'B','$','V','I','E','W','_','N','A','M','E',25,0,0,0,-1,14,1,
   2,1,23,0,16,'R','D','B','$','C','O','N','T','E','X','T','_',
   'N','A','M','E',25,1,0,0,1,23,0,17,'R','D','B','$','R','E','L',
   'A','T','I','O','N','_','N','A','M','E',25,1,1,0,1,21,8,0,1,
   0,0,0,25,1,2,0,1,23,0,16,'R','D','B','$','V','I','E','W','_',
   'C','O','N','T','E','X','T',25,1,3,0,-1,14,1,1,21,8,0,0,0,0,
   0,25,1,2,0,-1,-1,'L'
   };	/* end of blr string for request isc_519 */

static const short
   isc_527l = 193;
static const char
   isc_527 [] = {
   4,2,4,1,7,0,41,3,0,32,0,9,0,9,0,7,0,7,0,7,0,7,0,4,0,1,0,41,3,
   0,32,0,12,0,2,7,'C',1,'J',11,'R','D','B','$','I','N','D','I',
   'C','E','S',0,'G',47,23,0,14,'R','D','B','$','I','N','D','E',
   'X','_','N','A','M','E',25,0,0,0,-1,14,1,2,1,23,0,15,'R','D',
   'B','$','F','O','R','E','I','G','N','_','K','E','Y',41,1,0,0,
   4,0,1,23,0,18,'R','D','B','$','E','X','P','R','E','S','S','I',
   'O','N','_','B','L','R',41,1,1,0,5,0,1,23,0,21,'R','D','B','$',
   'E','X','P','R','E','S','S','I','O','N','_','S','O','U','R',
   'C','E',41,1,2,0,6,0,1,21,8,0,1,0,0,0,25,1,3,0,-1,14,1,1,21,
   8,0,0,0,0,0,25,1,3,0,-1,-1,'L'
   };	/* end of blr string for request isc_527 */

static const short
   isc_538l = 118;
static const char
   isc_538 [] = {
   4,2,4,1,2,0,7,0,7,0,4,0,1,0,41,3,0,32,0,12,0,2,7,'C',1,'J',11,
   'R','D','B','$','I','N','D','I','C','E','S',0,'G',47,23,0,14,
   'R','D','B','$','I','N','D','E','X','_','N','A','M','E',25,0,
   0,0,-1,14,1,2,1,21,8,0,1,0,0,0,25,1,0,0,1,23,0,14,'R','D','B',
   '$','I','N','D','E','X','_','T','Y','P','E',25,1,1,0,-1,14,1,
   1,21,8,0,0,0,0,0,25,1,0,0,-1,-1,'L'
   };	/* end of blr string for request isc_538 */

static const short
   isc_544l = 152;
static const char
   isc_544 [] = {
   4,2,4,1,2,0,41,3,0,32,0,7,0,4,0,1,0,41,3,0,32,0,12,0,2,7,'C',
   1,'J',18,'R','D','B','$','I','N','D','E','X','_','S','E','G',
   'M','E','N','T','S',0,'G',47,23,0,14,'R','D','B','$','I','N',
   'D','E','X','_','N','A','M','E',25,0,0,0,'F',1,'H',23,0,18,'R',
   'D','B','$','F','I','E','L','D','_','P','O','S','I','T','I',
   'O','N',-1,14,1,2,1,23,0,14,'R','D','B','$','F','I','E','L',
   'D','_','N','A','M','E',25,1,0,0,1,21,8,0,1,0,0,0,25,1,1,0,-1,
   14,1,1,21,8,0,0,0,0,0,25,1,1,0,-1,-1,'L'
   };	/* end of blr string for request isc_544 */

static const short
   isc_550l = 122;
static const char
   isc_550 [] = {
   4,2,4,1,2,0,7,0,7,0,4,0,1,0,41,3,0,32,0,12,0,2,7,'C',1,'J',11,
   'R','D','B','$','I','N','D','I','C','E','S',0,'G',47,23,0,14,
   'R','D','B','$','I','N','D','E','X','_','N','A','M','E',25,0,
   0,0,-1,14,1,2,1,21,8,0,1,0,0,0,25,1,0,0,1,23,0,18,'R','D','B',
   '$','I','N','D','E','X','_','I','N','A','C','T','I','V','E',
   25,1,1,0,-1,14,1,1,21,8,0,0,0,0,0,25,1,0,0,-1,-1,'L'
   };	/* end of blr string for request isc_550 */

static const short
   isc_556l = 133;
static const char
   isc_556 [] = {
   4,2,4,1,1,0,7,0,4,0,2,0,41,3,0,32,0,41,3,0,32,0,12,0,2,7,'C',
   1,'J',19,'R','D','B','$','R','E','L','A','T','I','O','N','_',
   'F','I','E','L','D','S',0,'G',58,47,25,0,1,0,23,0,14,'R','D',
   'B','$','F','I','E','L','D','_','N','A','M','E',47,23,0,17,'R',
   'D','B','$','R','E','L','A','T','I','O','N','_','N','A','M',
   'E',25,0,0,0,-1,14,1,2,1,21,8,0,1,0,0,0,25,1,0,0,-1,14,1,1,21,
   8,0,0,0,0,0,25,1,0,0,-1,-1,'L'
   };	/* end of blr string for request isc_556 */

static const short
   isc_562l = 128;
static const char
   isc_562 [] = {
   4,2,4,1,2,0,41,3,0,32,0,7,0,4,0,1,0,41,3,0,32,0,12,0,2,7,'C',
   1,'J',18,'R','D','B','$','I','N','D','E','X','_','S','E','G',
   'M','E','N','T','S',0,'G',47,23,0,14,'R','D','B','$','I','N',
   'D','E','X','_','N','A','M','E',25,0,0,0,-1,14,1,2,1,23,0,14,
   'R','D','B','$','F','I','E','L','D','_','N','A','M','E',25,1,
   0,0,1,21,8,0,1,0,0,0,25,1,1,0,-1,14,1,1,21,8,0,0,0,0,0,25,1,
   1,0,-1,-1,'L'
   };	/* end of blr string for request isc_562 */

static const short
   isc_568l = 201;
static const char
   isc_568 [] = {
   4,2,4,1,5,0,9,0,41,3,0,32,0,7,0,7,0,7,0,4,0,1,0,41,3,0,32,0,
   12,0,2,7,'C',1,'J',11,'R','D','B','$','I','N','D','I','C','E',
   'S',0,'G',47,23,0,17,'R','D','B','$','R','E','L','A','T','I',
   'O','N','_','N','A','M','E',25,0,0,0,-1,14,1,2,1,23,0,15,'R',
   'D','B','$','D','E','S','C','R','I','P','T','I','O','N',25,1,
   0,0,1,23,0,14,'R','D','B','$','I','N','D','E','X','_','N','A',
   'M','E',25,1,1,0,1,21,8,0,1,0,0,0,25,1,2,0,1,23,0,15,'R','D',
   'B','$','U','N','I','Q','U','E','_','F','L','A','G',25,1,3,0,
   1,23,0,17,'R','D','B','$','S','E','G','M','E','N','T','_','C',
   'O','U','N','T',25,1,4,0,-1,14,1,1,21,8,0,0,0,0,0,25,1,2,0,-1,
   -1,'L'
   };	/* end of blr string for request isc_568 */

static const short
   isc_577l = 152;
static const char
   isc_577 [] = {
   4,2,4,1,2,0,41,3,0,32,0,7,0,4,0,1,0,41,3,0,32,0,12,0,2,7,'C',
   1,'J',18,'R','D','B','$','I','N','D','E','X','_','S','E','G',
   'M','E','N','T','S',0,'G',47,23,0,14,'R','D','B','$','I','N',
   'D','E','X','_','N','A','M','E',25,0,0,0,'F',1,'H',23,0,18,'R',
   'D','B','$','F','I','E','L','D','_','P','O','S','I','T','I',
   'O','N',-1,14,1,2,1,23,0,14,'R','D','B','$','F','I','E','L',
   'D','_','N','A','M','E',25,1,0,0,1,21,8,0,1,0,0,0,25,1,1,0,-1,
   14,1,1,21,8,0,0,0,0,0,25,1,1,0,-1,-1,'L'
   };	/* end of blr string for request isc_577 */

static const short
   isc_583l = 190;
static const char
   isc_583 [] = {
   4,2,4,1,1,0,7,0,4,0,2,0,41,3,0,32,0,41,3,0,32,0,12,0,2,7,'C',
   2,'J',18,'R','D','B','$','I','N','D','E','X','_','S','E','G',
   'M','E','N','T','S',0,'J',19,'R','D','B','$','R','E','L','A',
   'T','I','O','N','_','F','I','E','L','D','S',1,'G',58,47,23,0,
   14,'R','D','B','$','F','I','E','L','D','_','N','A','M','E',23,
   1,14,'R','D','B','$','F','I','E','L','D','_','N','A','M','E',
   58,47,23,0,14,'R','D','B','$','I','N','D','E','X','_','N','A',
   'M','E',25,0,1,0,47,23,1,17,'R','D','B','$','R','E','L','A',
   'T','I','O','N','_','N','A','M','E',25,0,0,0,-1,14,1,2,1,21,
   8,0,1,0,0,0,25,1,0,0,-1,14,1,1,21,8,0,0,0,0,0,25,1,0,0,-1,-1,
   'L'
   };	/* end of blr string for request isc_583 */

static const short
   isc_589l = 352;
static const char
   isc_589 [] = {
   4,2,4,1,13,0,41,3,0,32,0,9,0,9,0,9,0,41,3,0,32,0,7,0,7,0,7,0,
   7,0,7,0,7,0,7,0,7,0,4,0,1,0,41,3,0,32,0,12,0,2,7,'C',1,'J',11,
   'R','D','B','$','I','N','D','I','C','E','S',0,'G',47,23,0,17,
   'R','D','B','$','R','E','L','A','T','I','O','N','_','N','A',
   'M','E',25,0,0,0,-1,14,1,2,1,23,0,15,'R','D','B','$','F','O',
   'R','E','I','G','N','_','K','E','Y',41,1,0,0,6,0,1,23,0,18,'R',
   'D','B','$','E','X','P','R','E','S','S','I','O','N','_','B',
   'L','R',41,1,1,0,7,0,1,23,0,21,'R','D','B','$','E','X','P','R',
   'E','S','S','I','O','N','_','S','O','U','R','C','E',41,1,2,0,
   8,0,1,23,0,15,'R','D','B','$','D','E','S','C','R','I','P','T',
   'I','O','N',25,1,3,0,1,23,0,14,'R','D','B','$','I','N','D','E',
   'X','_','N','A','M','E',25,1,4,0,1,21,8,0,1,0,0,0,25,1,5,0,1,
   23,0,14,'R','D','B','$','I','N','D','E','X','_','T','Y','P',
   'E',25,1,9,0,1,23,0,15,'R','D','B','$','U','N','I','Q','U','E',
   '_','F','L','A','G',25,1,10,0,1,23,0,18,'R','D','B','$','I',
   'N','D','E','X','_','I','N','A','C','T','I','V','E',25,1,11,
   0,1,23,0,17,'R','D','B','$','S','E','G','M','E','N','T','_',
   'C','O','U','N','T',25,1,12,0,-1,14,1,1,21,8,0,0,0,0,0,25,1,
   5,0,-1,-1,'L'
   };	/* end of blr string for request isc_589 */

static const short
   isc_606l = 195;
static const char
   isc_606 [] = {
   4,2,4,1,4,0,8,0,8,0,7,0,7,0,4,0,1,0,41,3,0,32,0,12,0,2,7,'C',
   1,'J',20,'R','D','B','$','F','I','E','L','D','_','D','I','M',
   'E','N','S','I','O','N','S',0,'G',47,23,0,14,'R','D','B','$',
   'F','I','E','L','D','_','N','A','M','E',25,0,0,0,'F',1,'H',23,
   0,13,'R','D','B','$','D','I','M','E','N','S','I','O','N',-1,
   14,1,2,1,23,0,15,'R','D','B','$','U','P','P','E','R','_','B',
   'O','U','N','D',25,1,0,0,1,23,0,15,'R','D','B','$','L','O','W',
   'E','R','_','B','O','U','N','D',25,1,1,0,1,21,8,0,1,0,0,0,25,
   1,2,0,1,23,0,13,'R','D','B','$','D','I','M','E','N','S','I',
   'O','N',25,1,3,0,-1,14,1,1,21,8,0,0,0,0,0,25,1,2,0,-1,-1,'L'
   
   };	/* end of blr string for request isc_606 */

static const short
   isc_614l = 338;
static const char
   isc_614 [] = {
   4,2,4,1,11,0,9,0,9,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,4,0,
   2,0,41,3,0,32,0,41,3,0,32,0,12,0,2,7,'C',2,'J',19,'R','D','B',
   '$','R','E','L','A','T','I','O','N','_','F','I','E','L','D',
   'S',0,'J',10,'R','D','B','$','F','I','E','L','D','S',1,'G',58,
   47,23,0,14,'R','D','B','$','F','I','E','L','D','_','N','A','M',
   'E',25,0,1,0,58,47,23,0,17,'R','D','B','$','R','E','L','A','T',
   'I','O','N','_','N','A','M','E',25,0,0,0,47,23,0,16,'R','D',
   'B','$','F','I','E','L','D','_','S','O','U','R','C','E',23,1,
   14,'R','D','B','$','F','I','E','L','D','_','N','A','M','E',-1,
   14,1,2,1,23,0,18,'R','D','B','$','D','E','F','A','U','L','T',
   '_','S','O','U','R','C','E',41,1,0,0,7,0,1,23,0,17,'R','D','B',
   '$','D','E','F','A','U','L','T','_','V','A','L','U','E',41,1,
   1,0,8,0,1,21,8,0,1,0,0,0,25,1,2,0,1,23,0,16,'R','D','B','$',
   'C','O','L','L','A','T','I','O','N','_','I','D',41,1,4,0,3,0,
   1,23,1,20,'R','D','B','$','C','H','A','R','A','C','T','E','R',
   '_','S','E','T','_','I','D',41,1,6,0,5,0,1,23,0,13,'R','D','B',
   '$','N','U','L','L','_','F','L','A','G',41,1,10,0,9,0,-1,14,
   1,1,21,8,0,0,0,0,0,25,1,2,0,-1,-1,'L'
   };	/* end of blr string for request isc_614 */

static const short
   isc_630l = 117;
static const char
   isc_630 [] = {
   4,2,4,1,2,0,7,0,7,0,4,0,1,0,41,3,0,32,0,12,0,2,7,'C',1,'J',10,
   'R','D','B','$','F','I','E','L','D','S',0,'G',47,23,0,14,'R',
   'D','B','$','F','I','E','L','D','_','N','A','M','E',25,0,0,0,
   -1,14,1,2,1,21,8,0,1,0,0,0,25,1,0,0,1,23,0,14,'R','D','B','$',
   'D','I','M','E','N','S','I','O','N','S',25,1,1,0,-1,14,1,1,21,
   8,0,0,0,0,0,25,1,0,0,-1,-1,'L'
   };	/* end of blr string for request isc_630 */

static const short
   isc_636l = 164;
static const char
   isc_636 [] = {
   4,2,4,1,2,0,41,3,0,32,0,7,0,4,0,2,0,41,3,0,32,0,41,3,0,32,0,
   12,0,2,7,'C',1,'J',19,'R','D','B','$','R','E','L','A','T','I',
   'O','N','_','F','I','E','L','D','S',0,'G',58,47,23,0,17,'R',
   'D','B','$','R','E','L','A','T','I','O','N','_','N','A','M',
   'E',25,0,1,0,47,23,0,14,'R','D','B','$','F','I','E','L','D',
   '_','N','A','M','E',25,0,0,0,-1,14,1,2,1,23,0,18,'R','D','B',
   '$','S','E','C','U','R','I','T','Y','_','C','L','A','S','S',
   25,1,0,0,1,21,8,0,1,0,0,0,25,1,1,0,-1,14,1,1,21,8,0,0,0,0,0,
   25,1,1,0,-1,-1,'L'
   };	/* end of blr string for request isc_636 */

static const short
   isc_643l = 158;
static const char
   isc_643 [] = {
   4,2,4,1,2,0,7,0,7,0,4,0,2,0,41,3,0,32,0,41,3,0,32,0,12,0,2,7,
   'C',1,'J',19,'R','D','B','$','R','E','L','A','T','I','O','N',
   '_','F','I','E','L','D','S',0,'G',58,47,23,0,17,'R','D','B',
   '$','R','E','L','A','T','I','O','N','_','N','A','M','E',25,0,
   1,0,47,23,0,14,'R','D','B','$','F','I','E','L','D','_','N','A',
   'M','E',25,0,0,0,-1,14,1,2,1,21,8,0,1,0,0,0,25,1,0,0,1,23,0,
   15,'R','D','B','$','S','Y','S','T','E','M','_','F','L','A','G',
   25,1,1,0,-1,14,1,1,21,8,0,0,0,0,0,25,1,0,0,-1,-1,'L'
   };	/* end of blr string for request isc_643 */

static const short
   isc_650l = 162;
static const char
   isc_650 [] = {
   4,2,4,1,2,0,41,3,0,32,0,7,0,4,0,2,0,41,3,0,32,0,41,3,0,32,0,
   12,0,2,7,'C',1,'J',19,'R','D','B','$','R','E','L','A','T','I',
   'O','N','_','F','I','E','L','D','S',0,'G',58,47,23,0,14,'R',
   'D','B','$','F','I','E','L','D','_','N','A','M','E',25,0,1,0,
   47,23,0,17,'R','D','B','$','R','E','L','A','T','I','O','N','_',
   'N','A','M','E',25,0,0,0,-1,14,1,2,1,23,0,16,'R','D','B','$',
   'C','O','M','P','L','E','X','_','N','A','M','E',25,1,0,0,1,21,
   8,0,1,0,0,0,25,1,1,0,-1,14,1,1,21,8,0,0,0,0,0,25,1,1,0,-1,-1,
   'L'
   };	/* end of blr string for request isc_650 */

static const short
   isc_657l = 621;
static const char
   isc_657 [] = {
   4,2,4,1,22,0,9,0,41,3,0,32,0,41,0,0,-128,0,41,3,0,32,0,41,3,
   0,32,0,41,3,0,32,0,41,3,0,32,0,9,0,9,0,7,0,7,0,7,0,7,0,7,0,7,
   0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,4,0,1,0,41,3,0,32,0,12,0,2,7,'C',
   2,'J',19,'R','D','B','$','R','E','L','A','T','I','O','N','_',
   'F','I','E','L','D','S',0,'J',10,'R','D','B','$','F','I','E',
   'L','D','S',1,'G',58,47,23,0,16,'R','D','B','$','F','I','E',
   'L','D','_','S','O','U','R','C','E',23,1,14,'R','D','B','$',
   'F','I','E','L','D','_','N','A','M','E',47,23,0,17,'R','D','B',
   '$','R','E','L','A','T','I','O','N','_','N','A','M','E',25,0,
   0,0,-1,14,1,2,1,23,1,16,'R','D','B','$','C','O','M','P','U',
   'T','E','D','_','B','L','R',25,1,0,0,1,23,0,17,'R','D','B','$',
   'R','E','L','A','T','I','O','N','_','N','A','M','E',25,1,1,0,
   1,23,0,15,'R','D','B','$','E','D','I','T','_','S','T','R','I',
   'N','G',25,1,2,0,1,23,0,14,'R','D','B','$','Q','U','E','R','Y',
   '_','N','A','M','E',25,1,3,0,1,23,0,14,'R','D','B','$','B','A',
   'S','E','_','F','I','E','L','D',25,1,4,0,1,23,0,16,'R','D','B',
   '$','F','I','E','L','D','_','S','O','U','R','C','E',25,1,5,0,
   1,23,0,14,'R','D','B','$','F','I','E','L','D','_','N','A','M',
   'E',25,1,6,0,1,23,0,16,'R','D','B','$','Q','U','E','R','Y','_',
   'H','E','A','D','E','R',41,1,7,0,15,0,1,23,0,15,'R','D','B',
   '$','D','E','S','C','R','I','P','T','I','O','N',41,1,8,0,16,
   0,1,21,8,0,1,0,0,0,25,1,9,0,1,23,0,15,'R','D','B','$','U','P',
   'D','A','T','E','_','F','L','A','G',41,1,11,0,10,0,1,23,0,16,
   'R','D','B','$','V','I','E','W','_','C','O','N','T','E','X',
   'T',25,1,12,0,1,23,0,18,'R','D','B','$','F','I','E','L','D',
   '_','P','O','S','I','T','I','O','N',41,1,14,0,13,0,1,23,0,12,
   'R','D','B','$','F','I','E','L','D','_','I','D',25,1,17,0,1,
   23,1,15,'R','D','B','$','F','I','E','L','D','_','S','C','A',
   'L','E',25,1,18,0,1,23,1,16,'R','D','B','$','F','I','E','L',
   'D','_','L','E','N','G','T','H',25,1,19,0,1,23,1,18,'R','D',
   'B','$','F','I','E','L','D','_','S','U','B','_','T','Y','P',
   'E',25,1,20,0,1,23,1,14,'R','D','B','$','F','I','E','L','D',
   '_','T','Y','P','E',25,1,21,0,-1,14,1,1,21,8,0,0,0,0,0,25,1,
   9,0,-1,-1,'L'
   };	/* end of blr string for request isc_657 */

static const short
   isc_683l = 854;
static const char
   isc_683 [] = {
   4,2,4,1,35,0,9,0,9,0,41,3,0,32,0,9,0,41,3,0,32,0,41,0,0,-128,
   0,41,3,0,32,0,41,3,0,32,0,41,3,0,32,0,41,3,0,32,0,9,0,9,0,7,
   0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,
   0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,4,0,1,0,41,3,0,32,0,12,0,2,7,'C',
   2,'J',19,'R','D','B','$','R','E','L','A','T','I','O','N','_',
   'F','I','E','L','D','S',0,'J',10,'R','D','B','$','F','I','E',
   'L','D','S',1,'G',58,47,23,0,16,'R','D','B','$','F','I','E',
   'L','D','_','S','O','U','R','C','E',23,1,14,'R','D','B','$',
   'F','I','E','L','D','_','N','A','M','E',47,23,0,17,'R','D','B',
   '$','R','E','L','A','T','I','O','N','_','N','A','M','E',25,0,
   0,0,-1,14,1,2,1,23,0,18,'R','D','B','$','D','E','F','A','U',
   'L','T','_','S','O','U','R','C','E',41,1,0,0,17,0,1,23,0,17,
   'R','D','B','$','D','E','F','A','U','L','T','_','V','A','L',
   'U','E',41,1,1,0,18,0,1,23,0,18,'R','D','B','$','S','E','C',
   'U','R','I','T','Y','_','C','L','A','S','S',25,1,2,0,1,23,1,
   16,'R','D','B','$','C','O','M','P','U','T','E','D','_','B','L',
   'R',25,1,3,0,1,23,0,16,'R','D','B','$','C','O','M','P','L','E',
   'X','_','N','A','M','E',25,1,4,0,1,23,0,15,'R','D','B','$','E',
   'D','I','T','_','S','T','R','I','N','G',25,1,5,0,1,23,0,14,'R',
   'D','B','$','Q','U','E','R','Y','_','N','A','M','E',25,1,6,0,
   1,23,0,14,'R','D','B','$','B','A','S','E','_','F','I','E','L',
   'D',25,1,7,0,1,23,0,16,'R','D','B','$','F','I','E','L','D','_',
   'S','O','U','R','C','E',25,1,8,0,1,23,0,14,'R','D','B','$','F',
   'I','E','L','D','_','N','A','M','E',25,1,9,0,1,23,0,16,'R','D',
   'B','$','Q','U','E','R','Y','_','H','E','A','D','E','R',41,1,
   10,0,28,0,1,23,0,15,'R','D','B','$','D','E','S','C','R','I',
   'P','T','I','O','N',41,1,11,0,29,0,1,21,8,0,1,0,0,0,25,1,12,
   0,1,23,0,16,'R','D','B','$','C','O','L','L','A','T','I','O',
   'N','_','I','D',41,1,14,0,13,0,1,23,1,20,'R','D','B','$','C',
   'H','A','R','A','C','T','E','R','_','S','E','T','_','I','D',
   41,1,16,0,15,0,1,23,0,13,'R','D','B','$','N','U','L','L','_',
   'F','L','A','G',41,1,20,0,19,0,1,23,1,14,'R','D','B','$','D',
   'I','M','E','N','S','I','O','N','S',25,1,21,0,1,23,0,15,'R',
   'D','B','$','S','Y','S','T','E','M','_','F','L','A','G',25,1,
   22,0,1,23,0,15,'R','D','B','$','U','P','D','A','T','E','_','F',
   'L','A','G',41,1,24,0,23,0,1,23,0,16,'R','D','B','$','V','I',
   'E','W','_','C','O','N','T','E','X','T',25,1,25,0,1,23,0,18,
   'R','D','B','$','F','I','E','L','D','_','P','O','S','I','T',
   'I','O','N',41,1,27,0,26,0,1,23,0,12,'R','D','B','$','F','I',
   'E','L','D','_','I','D',25,1,30,0,1,23,1,15,'R','D','B','$',
   'F','I','E','L','D','_','S','C','A','L','E',25,1,31,0,1,23,1,
   16,'R','D','B','$','F','I','E','L','D','_','L','E','N','G','T',
   'H',25,1,32,0,1,23,1,18,'R','D','B','$','F','I','E','L','D',
   '_','S','U','B','_','T','Y','P','E',25,1,33,0,1,23,1,14,'R',
   'D','B','$','F','I','E','L','D','_','T','Y','P','E',25,1,34,
   0,-1,14,1,1,21,8,0,0,0,0,0,25,1,12,0,-1,-1,'L'
   };	/* end of blr string for request isc_683 */

static const short
   isc_722l = 176;
static const char
   isc_722 [] = {
   4,2,4,0,4,0,9,0,9,0,41,3,0,32,0,7,0,2,7,'C',1,'J',20,'R','D',
   'B','$','S','E','C','U','R','I','T','Y','_','C','L','A','S',
   'S','E','S',0,'G',59,55,23,0,18,'R','D','B','$','S','E','C',
   'U','R','I','T','Y','_','C','L','A','S','S',21,15,3,0,4,0,'S',
   'Q','L','$',-1,14,0,2,1,23,0,15,'R','D','B','$','D','E','S',
   'C','R','I','P','T','I','O','N',25,0,0,0,1,23,0,7,'R','D','B',
   '$','A','C','L',25,0,1,0,1,23,0,18,'R','D','B','$','S','E','C',
   'U','R','I','T','Y','_','C','L','A','S','S',25,0,2,0,1,21,8,
   0,1,0,0,0,25,0,3,0,-1,14,0,1,21,8,0,0,0,0,0,25,0,3,0,-1,-1,'L'
   
   };	/* end of blr string for request isc_722 */


#define gds_blob_null	isc_blob_null	/* compatibility symbols */
#define gds_status	isc_status
#define gds_status2	isc_status2
#define gds_array_length	isc_array_length
#define gds_count	isc_count
#define gds_slack	isc_slack
#define gds_utility	isc_utility	/* end of compatibility symbols */

#ifndef isc_version4
    Generate a compile-time error.
    Picking up a V3 include file after preprocessing with V4 GPRE.
#endif

/**** end of GPRE definitions ****/


#define DB			tdgbl->db_handle
#define gds_trans	tdgbl->tr_handle
#define isc_status	tdgbl->status_vector

namespace // unnamed, private
{

// VERBOSE INTERVAL WHEN BACKING RECORDS
const ULONG BACKUP_VERBOSE_INTERVAL = 20000;

#define PUT_MESSAGE(attrib, attrib2, message) put_message((attrib), (attrib2), (message), sizeof(message))
#define PUT_TEXT(attribute, text)	put_text ((attribute), (text), sizeof(text))
#define COPY(source, target)       copy ((source), (target), sizeof(target))

inline void put(BurpGlobals* tdgbl, const UCHAR c)
{
	if (--(tdgbl->io_cnt) >= 0)
		*(tdgbl->io_ptr)++ = c;
	else
		MVOL_write(c, &tdgbl->io_cnt, &tdgbl->io_ptr);
}

inline void put(BurpGlobals* tdgbl, const att_type c)
{
	if (--tdgbl->io_cnt >= 0)
		*(tdgbl->io_ptr)++ = UCHAR(c);
	else
		MVOL_write(UCHAR(c), &tdgbl->io_cnt, &tdgbl->io_ptr);
}

inline const UCHAR* put_block(BurpGlobals* tdgbl, const UCHAR* p, ULONG n)
{
	return MVOL_write_block (tdgbl, p, n);
}


void compress(const UCHAR*, ULONG);
int copy(const TEXT *, TEXT *, ULONG);
burp_fld* get_fields(burp_rel*);
SINT64 get_gen_id(const TEXT *, SSHORT);
void get_ranges(burp_fld*);
void put_array(burp_fld*, burp_rel*, ISC_QUAD*);
void put_asciz(const att_type, const TEXT*);
void put_blob(burp_fld*, ISC_QUAD&);
bool put_blr_blob(att_type, ISC_QUAD&);
void put_data(burp_rel*);
void put_index(burp_rel*);
int put_message(att_type, att_type, const TEXT*, const ULONG);
void put_numeric(att_type, SLONG);
void put_int64( att_type attribute, SINT64 value);
void put_relation(burp_rel*);
bool put_source_blob(att_type, att_type, ISC_QUAD&);
int put_text(att_type, const TEXT *, SSHORT);
void set_capabilities();
void write_character_sets();
void write_check_constraints();
void write_collations();
void write_database(const TEXT*);
void write_exceptions();
void write_field_dimensions();
void write_filters();
void write_functions();
void write_function_args(GDS_NAME);
void write_generators();
void write_sql_roles();
void write_mapping();
void write_global_fields();
void write_procedures();
void write_procedure_prms(GDS_NAME);
void write_ref_constraints();
void write_rel_constraints();
void write_relations();
void write_shadow_files();
void write_triggers();
void write_trigger_messages();
void write_types();
void write_user_privileges();
void general_on_error();

enum backup_capabilities
{
	BCK_security		= 1,
	BCK_files			= 2,
	BCK_external		= 4,
	BCK_idx_inactive	= 8,
	BCK_triggers		= 16,	// Obsolete - 1996-Aug-05
	BCK_context_name	= 32,
	BCK_db_description	= 64,
	BCK_ffmptt			= 128,	// rdb$functions, rdb$filters, rdb$trigger_messages,
								// rdb$user_privileges, rdb$triggers, rdb$types
	BCK_attributes_v3	= 256,	// attributes in various system relations new to v3
	BCK_rfr_sys_flag	= 512,	// system flag is missing from Rdb/VMS V3 RFR relation
	BCK_ods6			= 1024,	// rdb$field_dimensions and shadow files
	BCK_ods8			= 2048,	// stored procedures & exceptions & constraints
	BCK_ods9			= 4096,	// SQL roles
	BCK_ods10			= 8192,	// FIELD_PRECISION
	BCK_ods11			= 16384,// rdb$description in rdb$roles and rdb$generators
								// rdb$base_collation_name and rdb$specific_attributes in rdb$collations
								// rdb$message enlarged to 1021.
	BCK_ods11_1			= 32768,// rdb$relation_type in rdb$relations
								// rdb$procedure_type in rdb$procedures
								// rdb$valid_blr in rdb$triggers
								// rdb$valid_blr in rdb$procedures
								// rdb$default_value, rdb$default_source, rdb$collation_id,
								// rdb$null_flag and rdb$parameter_mechanism in rdb$procedure_parameters
	BCK_ods11_2			= 65536	// rdb$field_name and rdb$relation_name in rdb$procedure_parameters
								// rdb$admin system role
								// rdb$message enlarged to 1023.
};
// ASF: Engine that works with ODS11.1 supports access to non-existent system fields.
// Reads returns NULL and writes do nothing.

#ifdef DEBUG
UCHAR debug_on = 0;		// able to turn this on in debug mode
#endif


// table used to determine capabilities, checking for specific
// fields in system relations

struct rfr_tab_t
{
	const TEXT* relation;
	const TEXT* field;
	// Let's be compatible with BurpGlobals.BCK_capabilities, although we could follow
	// the enumeration backup_capabilities but the enum then should be defined
	// in burp.h instead so BCK_capabilities isn't anymore a simple SLONG.
	SLONG bit_mask;
};

const rfr_tab_t rfr_table[] =
{
	{"RDB$INDICES", "RDB$INDEX_INACTIVE", BCK_idx_inactive},
	// Backup of V2 triggers no longer supported 1996-Aug-05 David Schnepper
	// {"RDB$RELATIONS",	"RDB$STORE_TRIGGER",	BCK_triggers},
	{"RDB$RELATIONS", "RDB$EXTERNAL_FILE", BCK_external},
	{"RDB$SECURITY_CLASSES", "RDB$SECURITY_CLASS", BCK_security},
	{"RDB$FILES", "RDB$FILE_NAME", BCK_files},
	{"RDB$VIEW_RELATIONS", "RDB$CONTEXT_NAME", BCK_context_name},
	{"RDB$DATABASE", "RDB$DESCRIPTION", BCK_db_description},
	{"RDB$FUNCTIONS", "RDB$FUNCTION_NAME", BCK_ffmptt},
	{"RDB$FIELDS", "RDB$EXTERNAL_LENGTH", BCK_attributes_v3},
	{"RDB$RELATION_FIELDS", "RDB$SYSTEM_FLAG", BCK_rfr_sys_flag},
	{"RDB$FIELD_DIMENSIONS", "RDB$DIMENSION", BCK_ods6},
	{"RDB$PROCEDURES", "RDB$PROCEDURE_NAME", BCK_ods8},
	{"RDB$ROLES", "RDB$ROLE_NAME", BCK_ods9},
	{"RDB$FIELDS", "RDB$FIELD_PRECISION", BCK_ods10},
	{"RDB$ROLES", "RDB$DESCRIPTION", BCK_ods11},
	//{"RDB$ROLES", "RDB$SYSTEM_FLAG", BCK_ods11},
	//{"RDB$COLLATIONS", "RDB$BASE_COLLATION_NAME", BCK_ods11},
	//{"RDB$COLLATIONS", "RDB$SPECIFIC_ATTRIBUTES", BCK_ods11},
	{"RDB$RELATIONS", "RDB$RELATION_TYPE", BCK_ods11_1},
	//{"RDB$PROCEDURES", "RDB$PROCEDURE_TYPE", BCK_ods11_1},
	//{"RDB$TRIGGERS", "RDB$VALID_BLR", BCK_ods11_1},
	//{"RDB$PROCEDURES", "RDB$VALID_BLR", BCK_ods11_1},
	//{"RDB$PROCEDURE_PARAMETERS", "RDB$DEFAULT_VALUE", BCK_ods11_1},
	//{"RDB$PROCEDURE_PARAMETERS", "RDB$DEFAULT_SOURCE", BCK_ods11_1},
	//{"RDB$PROCEDURE_PARAMETERS", "RDB$COLLATION_ID", BCK_ods11_1},
	//{"RDB$PROCEDURE_PARAMETERS", "RDB$NULL_FLAG", BCK_ods11_1},
	//{"RDB$PROCEDURE_PARAMETERS", "RDB$PARAMETER_MECHANISM", BCK_ods11_1},
	{"RDB$PROCEDURE_PARAMETERS", "RDB$FIELD_NAME", BCK_ods11_2},
	//{"RDB$PROCEDURE_PARAMETERS", "RDB$RELATION_NAME", BCK_ods11_2},
	{0, 0, 0}
};

const UCHAR blob_items[] =
{
	isc_info_blob_max_segment,
	isc_info_blob_num_segments,
	isc_info_blob_type,
	isc_info_blob_total_length
};
const UCHAR blr_items[] =
{
	isc_info_blob_max_segment,
	isc_info_blob_total_length
};
const UCHAR source_items[] =
{
	isc_info_blob_max_segment,
	isc_info_blob_total_length,
	isc_info_blob_num_segments
};
const SCHAR db_info_items[] =
{
	isc_info_db_sql_dialect,
	isc_info_page_size,
	isc_info_sweep_interval,
	isc_info_forced_writes,
	isc_info_no_reserve,
	isc_info_set_page_buffers,
	isc_info_db_read_only,
	isc_info_end
};
const SCHAR limbo_tpb[] =
{
	isc_tpb_version1,
	isc_tpb_ignore_limbo
};
const SCHAR limbo_nau_tpb[] =
{
	isc_tpb_version1,
	isc_tpb_ignore_limbo,
	isc_tpb_no_auto_undo
};

} // namespace


int BACKUP_backup(const TEXT* dbb_file, const TEXT* file_name)
{
   struct isc_723_struct {
          ISC_QUAD isc_724;	/* RDB$DESCRIPTION */
          ISC_QUAD isc_725;	/* RDB$ACL */
          char  isc_726 [32];	/* RDB$SECURITY_CLASS */
          short isc_727;	/* isc_utility */
   } isc_723;
/**************************************
 *
 *	B A C K U P _ b a c k u p
 *
 **************************************
 *
 * Functional description
 *	Backup a database.
 *
 **************************************/
	ISC_STATUS_ARRAY status_vector;
	TEXT temp[GDS_NAME_LEN];

	BurpGlobals* tdgbl = BurpGlobals::getSpecific();

	tdgbl->gbl_database_file_name = dbb_file;

	tdgbl->io_ptr = NULL;
	tdgbl->io_cnt = 0;
	tdgbl->relations = NULL;
	tdgbl->BCK_capabilities = 0;

	gds_trans = 0;

	BURP_verbose(130);
	// msg 130 starting transaction

	if (tdgbl->gbl_sw_ignore_limbo)
	{
		if (isc_start_transaction(status_vector, &gds_trans, 1, &DB,
								  sizeof(limbo_nau_tpb), limbo_nau_tpb))
		{
			isc_start_transaction(status_vector, &gds_trans, 1, &DB, sizeof(limbo_tpb), limbo_tpb);
		}
	}
	else
	{
		/*EXEC SQL SET TRANSACTION NO_AUTO_UNDO;*/
		{
		isc_start_transaction (isc_status, (FB_API_HANDLE*) &gds_trans, (short) 1, &DB, (short) 5, isc_tpb_0);
		SQLCODE = isc_sqlcode(isc_status);
		}
		if (isc_status[1])
			/*EXEC SQL SET TRANSACTION;*/
			{
			isc_start_transaction (isc_status, (FB_API_HANDLE*) &gds_trans, (short) 1, &DB, (short) 4, isc_tpb_1);
			SQLCODE = isc_sqlcode(isc_status);
			}
	}

	if (!gds_trans)
	{
		/*EXEC SQL SET TRANSACTION NAME gds_trans NO_AUTO_UNDO;*/
		{
		isc_start_transaction (isc_status, (FB_API_HANDLE*) &gds_trans, (short) 1, &DB, (short) 5, isc_tpb_2);
		SQLCODE = isc_sqlcode(isc_status);
		}
		if (isc_status[1])
			/*EXEC SQL SET TRANSACTION NAME gds_trans;*/
			{
			isc_start_transaction (isc_status, (FB_API_HANDLE*) &gds_trans, (short) 1, &DB, (short) 4, isc_tpb_3);
			SQLCODE = isc_sqlcode(isc_status);
			}
	}




	// decide what type of database we've got

	set_capabilities();

	// Write burp record first with other valuable information
	// In case of split operation, write a 'split' header first to all the files

	if (tdgbl->action->act_action == ACT_backup_split)
	{
		for (burp_fil* fil = tdgbl->gbl_sw_files; fil; fil = fil->fil_next)
		{
			tdgbl->action->act_file = fil;
			if (!MVOL_split_hdr_write())
			{
				BURP_error(269, true, tdgbl->action->act_file->fil_name.c_str());
				// msg 269 can't write a header record to file %s
			}
		}
		tdgbl->action->act_file = tdgbl->gbl_sw_files;
	}

	MVOL_init_write(file_name, &tdgbl->io_cnt, &tdgbl->io_ptr);

	// Write database record

	write_database(dbb_file);

	// Write global fields

	BURP_verbose(150);
	// msg 150  writing global fields
	write_global_fields();

	if (tdgbl->BCK_capabilities & BCK_ods6)
	{
		write_field_dimensions();

		BURP_verbose(162);
		// msg 162  writing shadow files
		write_shadow_files();
	}

	if (tdgbl->BCK_capabilities & BCK_ods8)
	{
		// Write Character Sets
		BURP_verbose(msgVerbose_write_charsets);
		write_character_sets();

		// Write Collations
		BURP_verbose(msgVerbose_write_collations);
		write_collations();
	}

	if (tdgbl->BCK_capabilities & BCK_ffmptt)
	{
		// Write functions
		BURP_verbose(148);
		// msg 148 writing functions
		write_functions();
	}

	// Write relations

	BURP_verbose(154);
	// msg 154 writing relations

	write_relations();

	if (tdgbl->BCK_capabilities & BCK_ffmptt)
	{
		// Write types
		BURP_verbose(161);
		// msg 161  writing types
		write_types();

		// Write filters
		BURP_verbose(146);
		// msg 146 writing filters
		write_filters();

		// Write generators

		BURP_verbose(164);
		// msg 164  writing id generators
		write_generators();
	}

	if (tdgbl->BCK_capabilities & BCK_ods8)
	{
		// Write procedures
		BURP_verbose(192);
		// msg 192 writing stored procedures
		write_procedures();

		// Write exceptions
		BURP_verbose(197);
		// msg 197 writing exceptions
		write_exceptions();
	}

	// Now go back and write all data

	for (burp_rel* relation = tdgbl->relations; relation; relation = relation->rel_next)
	{
		put(tdgbl, (UCHAR) rec_relation_data);
		PUT_TEXT(att_relation_name, relation->rel_name);
		put(tdgbl, att_end);

		if (!(relation->rel_flags & REL_view) && !(relation->rel_flags & REL_external))
		{
			put_index(relation);
			if (!tdgbl->gbl_sw_meta)
				put_data(relation);
		}

		put(tdgbl, (UCHAR) rec_relation_end);
	}

	// now for the new triggers in rdb$triggers
	if (tdgbl->BCK_capabilities & BCK_ffmptt) {
		BURP_verbose(159);
		// msg 159  writing triggers
		write_triggers();
		BURP_verbose(158);
		// msg 158 writing trigger messages
		write_trigger_messages();
		write_user_privileges();
	}

	// Last, but not least, go back and add any access control lists

	if (tdgbl->BCK_capabilities & BCK_security)
	{
		isc_req_handle req_handle1 = 0;
		/*FOR (REQUEST_HANDLE req_handle1)
			X IN RDB$SECURITY_CLASSES WITH X.RDB$SECURITY_CLASS NOT STARTING "SQL$"*/
		{
                if (!req_handle1)
                   isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &req_handle1, (short) sizeof(isc_722), (char*) isc_722);
		if (req_handle1)
		   {
                   isc_start_request (isc_status, (FB_API_HANDLE*) &req_handle1, (FB_API_HANDLE*) &gds_trans, (short) 0);
		   }
		if (!isc_status [1]) {
		while (1)
		   {
                   isc_receive (isc_status, (FB_API_HANDLE*) &req_handle1, (short) 0, (short) 50, &isc_723, (short) 0);
		   if (!isc_723.isc_727 || isc_status [1]) break;
			put(tdgbl, rec_security_class);
			const ULONG l = PUT_TEXT (att_class_security_class, /*X.RDB$SECURITY_CLASS*/
									    isc_723.isc_726);
			MISC_terminate (/*X.RDB$SECURITY_CLASS*/
					isc_723.isc_726, temp, l, sizeof(temp));
			BURP_verbose (155, temp);
			// msg 155 writing security class %s
			put_blr_blob (att_class_acl, /*X.RDB$ACL*/
						     isc_723.isc_725);
			put_source_blob (att_class_description2, att_class_description, /*X.RDB$DESCRIPTION*/
											isc_723.isc_724);
			put(tdgbl, att_end);
		/*END_FOR;*/
		   }
		   };
		/*ON_ERROR*/
		if (isc_status [1])
		   {
			general_on_error();
		/*END_ERROR;*/
		   }
		}

		MISC_release_request_silent(req_handle1);
	}

	if (tdgbl->BCK_capabilities & BCK_ods8)
	{
		// Write relation constraints
		BURP_verbose(206);
		// msg 206 writing relation constraints
		write_rel_constraints();

		// Write referential constraints
		BURP_verbose(209);
		// msg 209 writing referential constraints
		write_ref_constraints();

		// Write check constraints
		BURP_verbose(210);
		// msg 210 writing check constraints
		write_check_constraints();

	}

	if (tdgbl->BCK_capabilities & BCK_ods9)
	{
		// Write SQL roles
		BURP_verbose(248);
		// msg 248 writing SQL roles
		write_sql_roles();
	}

	if (tdgbl->BCK_capabilities & BCK_ods11)
	{
		// Write names mapping
		BURP_verbose(296);
		// msg 296 writing mapping
		write_mapping();
	}

	// Finish up

	put(tdgbl, (UCHAR) rec_end);
	FB_UINT64 cumul_count = MVOL_fini_write(&tdgbl->io_cnt, &tdgbl->io_ptr);
	tdgbl->action->act_action = ACT_backup_fini;
	BURP_verbose(176, SafeArg() << cumul_count);
	// msg 176 closing file, committing, and finishing.  %ld bytes written

	/*COMMIT;*/
	{
	isc_commit_transaction (isc_status, (FB_API_HANDLE*) &gds_trans);;
	/*ON_ERROR*/
	if (isc_status [1])
	   {
		general_on_error();
	/*END_ERROR;*/
	   }
	}

	if (gds_trans)
		/*COMMIT gds_trans;*/
		{
		isc_commit_transaction (isc_status, (FB_API_HANDLE*) &gds_trans);;
	/*ON_ERROR*/
	if (isc_status [1])
	   {
		general_on_error();
	/*END_ERROR;*/
	   }
	}

	if (tdgbl->gbl_stat_flags)
		BURP_verbose(369);
	// msg 369 total statistics

	/*FINISH*/
	{
	if (DB)
	   isc_detach_database (isc_status, &DB);;
	/*ON_ERROR*/
	if (isc_status [1])
	   {
		general_on_error();
	/*END_ERROR;*/
	   }
	}

	return FINI_OK;
}

namespace // unnamed, private
{

void compress(const UCHAR* data, ULONG length)
{
/**************************************
 *
 *	c o m p r e s s
 *
 **************************************
 *
 * Functional description
 *	Write out data in compressed form.
 *
 **************************************/
	BurpGlobals* tdgbl = BurpGlobals::getSpecific();

	const UCHAR* p = data;
	const UCHAR* end = p + length;
	const UCHAR* q = NULL;

	while (p < end)
	{
		for (q = p + 2; q < end && (q[-2] != q[-1] || q[-1] != q[0]); q++)
			;
		USHORT run = (q < end) ? q - p - 2 : end - p;
		if (run)
		{
			for (; run > 127; run -= 127)
			{
				USHORT len = 127;
				put(tdgbl, (UCHAR) len);
				p = put_block(tdgbl, p, len);
			}
			if (run)
			{
				put(tdgbl, (UCHAR) run);
				p = put_block(tdgbl, p, run);
			}
		}
		for (q = p; q < end && *q == *p; q++)
			;
		if ((run = q - p) != 0)
		{
			for (; run > 127; run -= 127)
			{
				put(tdgbl, (UCHAR) (-127));
				put(tdgbl, (UCHAR) (*p));
			}
			if (run)
			{
				put(tdgbl, (UCHAR) (-run));
				put(tdgbl, (UCHAR) (*p));
			}
			p = q;
		}
	}
}


int copy( const TEXT* from, TEXT* to, ULONG size_len)
{
/**************************************
 *
 *	c o p y
 *
 **************************************
 *
 * Functional description
 *	Copy a blank or null terminated string into a null terminated
 *	string. It assumes there's enough room in the target.
 *
 **************************************/

	const ULONG len = (ULONG) MISC_symbol_length(from, size_len);

	memcpy(to, from, len);
	to[len] = '\0';

	return (int) len;
}


void general_on_error()
{
/**************************************
 *
 *	g e n e r a l _ o n _ e r r o r
 *
 **************************************
 *
 * Functional description
 *	Handle any general ON_ERROR clause during backup.
 *
 **************************************/
	BurpGlobals* tdgbl = BurpGlobals::getSpecific();

	BURP_print_status(true, isc_status);
	BURP_abort();
}


burp_fld* get_fields( burp_rel* relation)
{
   struct isc_618_struct {
          ISC_QUAD isc_619;	/* RDB$DEFAULT_SOURCE */
          ISC_QUAD isc_620;	/* RDB$DEFAULT_VALUE */
          short isc_621;	/* isc_utility */
          short isc_622;	/* gds__null_flag */
          short isc_623;	/* RDB$COLLATION_ID */
          short isc_624;	/* gds__null_flag */
          short isc_625;	/* RDB$CHARACTER_SET_ID */
          short isc_626;	/* gds__null_flag */
          short isc_627;	/* gds__null_flag */
          short isc_628;	/* gds__null_flag */
          short isc_629;	/* RDB$NULL_FLAG */
   } isc_618;
   struct isc_615_struct {
          char  isc_616 [32];	/* RDB$RELATION_NAME */
          char  isc_617 [32];	/* RDB$FIELD_NAME */
   } isc_615;
   struct isc_633_struct {
          short isc_634;	/* isc_utility */
          short isc_635;	/* RDB$DIMENSIONS */
   } isc_633;
   struct isc_631_struct {
          char  isc_632 [32];	/* RDB$FIELD_SOURCE */
   } isc_631;
   struct isc_640_struct {
          char  isc_641 [32];	/* RDB$SECURITY_CLASS */
          short isc_642;	/* isc_utility */
   } isc_640;
   struct isc_637_struct {
          char  isc_638 [32];	/* RDB$FIELD_NAME */
          char  isc_639 [32];	/* RDB$RELATION_NAME */
   } isc_637;
   struct isc_647_struct {
          short isc_648;	/* isc_utility */
          short isc_649;	/* RDB$SYSTEM_FLAG */
   } isc_647;
   struct isc_644_struct {
          char  isc_645 [32];	/* RDB$FIELD_NAME */
          char  isc_646 [32];	/* RDB$RELATION_NAME */
   } isc_644;
   struct isc_654_struct {
          char  isc_655 [32];	/* RDB$COMPLEX_NAME */
          short isc_656;	/* isc_utility */
   } isc_654;
   struct isc_651_struct {
          char  isc_652 [32];	/* RDB$RELATION_NAME */
          char  isc_653 [32];	/* RDB$FIELD_NAME */
   } isc_651;
   struct isc_660_struct {
          ISC_QUAD isc_661;	/* RDB$COMPUTED_BLR */
          char  isc_662 [32];	/* RDB$RELATION_NAME */
          char  isc_663 [128];	/* RDB$EDIT_STRING */
          char  isc_664 [32];	/* RDB$QUERY_NAME */
          char  isc_665 [32];	/* RDB$BASE_FIELD */
          char  isc_666 [32];	/* RDB$FIELD_SOURCE */
          char  isc_667 [32];	/* RDB$FIELD_NAME */
          ISC_QUAD isc_668;	/* RDB$QUERY_HEADER */
          ISC_QUAD isc_669;	/* RDB$DESCRIPTION */
          short isc_670;	/* isc_utility */
          short isc_671;	/* gds__null_flag */
          short isc_672;	/* RDB$UPDATE_FLAG */
          short isc_673;	/* RDB$VIEW_CONTEXT */
          short isc_674;	/* gds__null_flag */
          short isc_675;	/* RDB$FIELD_POSITION */
          short isc_676;	/* gds__null_flag */
          short isc_677;	/* gds__null_flag */
          short isc_678;	/* RDB$FIELD_ID */
          short isc_679;	/* RDB$FIELD_SCALE */
          short isc_680;	/* RDB$FIELD_LENGTH */
          short isc_681;	/* RDB$FIELD_SUB_TYPE */
          short isc_682;	/* RDB$FIELD_TYPE */
   } isc_660;
   struct isc_658_struct {
          char  isc_659 [32];	/* RDB$RELATION_NAME */
   } isc_658;
   struct isc_686_struct {
          ISC_QUAD isc_687;	/* RDB$DEFAULT_SOURCE */
          ISC_QUAD isc_688;	/* RDB$DEFAULT_VALUE */
          char  isc_689 [32];	/* RDB$SECURITY_CLASS */
          ISC_QUAD isc_690;	/* RDB$COMPUTED_BLR */
          char  isc_691 [32];	/* RDB$COMPLEX_NAME */
          char  isc_692 [128];	/* RDB$EDIT_STRING */
          char  isc_693 [32];	/* RDB$QUERY_NAME */
          char  isc_694 [32];	/* RDB$BASE_FIELD */
          char  isc_695 [32];	/* RDB$FIELD_SOURCE */
          char  isc_696 [32];	/* RDB$FIELD_NAME */
          ISC_QUAD isc_697;	/* RDB$QUERY_HEADER */
          ISC_QUAD isc_698;	/* RDB$DESCRIPTION */
          short isc_699;	/* isc_utility */
          short isc_700;	/* gds__null_flag */
          short isc_701;	/* RDB$COLLATION_ID */
          short isc_702;	/* gds__null_flag */
          short isc_703;	/* RDB$CHARACTER_SET_ID */
          short isc_704;	/* gds__null_flag */
          short isc_705;	/* gds__null_flag */
          short isc_706;	/* gds__null_flag */
          short isc_707;	/* RDB$NULL_FLAG */
          short isc_708;	/* RDB$DIMENSIONS */
          short isc_709;	/* RDB$SYSTEM_FLAG */
          short isc_710;	/* gds__null_flag */
          short isc_711;	/* RDB$UPDATE_FLAG */
          short isc_712;	/* RDB$VIEW_CONTEXT */
          short isc_713;	/* gds__null_flag */
          short isc_714;	/* RDB$FIELD_POSITION */
          short isc_715;	/* gds__null_flag */
          short isc_716;	/* gds__null_flag */
          short isc_717;	/* RDB$FIELD_ID */
          short isc_718;	/* RDB$FIELD_SCALE */
          short isc_719;	/* RDB$FIELD_LENGTH */
          short isc_720;	/* RDB$FIELD_SUB_TYPE */
          short isc_721;	/* RDB$FIELD_TYPE */
   } isc_686;
   struct isc_684_struct {
          char  isc_685 [32];	/* RDB$RELATION_NAME */
   } isc_684;
/**************************************
 *
 *	g e t _ f i e l d s
 *
 **************************************
 *
 * Functional description
 *	Get fields for a relation.  Test
 *	capabilities and get system specific
 *
 **************************************/
	burp_fld* field;
	ISC_QUAD* blob_id;

	BurpGlobals* tdgbl = BurpGlobals::getSpecific();

	USHORT count = 1;

	Firebird::HalfStaticArray<burp_fld*, 16> field_list;

	// if we have all capabilities, use the first request to get the
	// most performance out of the latest engine; if we don't
	// have one of the capabilities we must use the second set of
	// requests--this requires more code but it is well worth it
	// for the performance benefits, especially remotely--deej

	if ((tdgbl->BCK_capabilities & BCK_attributes_v3) && (tdgbl->BCK_capabilities & BCK_ods8) &&
		(tdgbl->BCK_capabilities & BCK_rfr_sys_flag) && (tdgbl->BCK_capabilities & BCK_security))
	{
		/*FOR (REQUEST_HANDLE tdgbl->handles_get_fields_req_handle1)
			X IN RDB$RELATION_FIELDS CROSS
			Y IN RDB$FIELDS WITH
			X.RDB$FIELD_SOURCE = Y.RDB$FIELD_NAME AND
			X.RDB$RELATION_NAME EQ relation->rel_name*/
		{
                if (!tdgbl->handles_get_fields_req_handle1)
                   isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &tdgbl->handles_get_fields_req_handle1, (short) sizeof(isc_683), (char*) isc_683);
		isc_vtov ((const char*) relation->rel_name, (char*) isc_684.isc_685, 32);
		if (tdgbl->handles_get_fields_req_handle1)
		   {
                   isc_start_and_send (isc_status, (FB_API_HANDLE*) &tdgbl->handles_get_fields_req_handle1, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 32, &isc_684, (short) 0);
		   }
		if (!isc_status [1]) {
		while (1)
		   {
                   isc_receive (isc_status, (FB_API_HANDLE*) &tdgbl->handles_get_fields_req_handle1, (short) 1, (short) 406, &isc_686, (short) 0);
		   if (!isc_686.isc_699 || isc_status [1]) break;

			field = (burp_fld*) BURP_alloc_zero(sizeof(burp_fld));
			field->fld_number = count++;
			field->fld_type = /*Y.RDB$FIELD_TYPE*/
					  isc_686.isc_721;
			field->fld_sub_type = /*Y.RDB$FIELD_SUB_TYPE*/
					      isc_686.isc_720;
			field->fld_length = /*Y.RDB$FIELD_LENGTH*/
					    isc_686.isc_719;
			field->fld_scale = /*Y.RDB$FIELD_SCALE*/
					   isc_686.isc_718;
			field->fld_id = /*X.RDB$FIELD_ID*/
					isc_686.isc_717;

			if (!/*X.RDB$DESCRIPTION.NULL*/
			     isc_686.isc_716)
			{
				blob_id = &/*X.RDB$DESCRIPTION*/
					   isc_686.isc_698;
				if (blob_id->gds_quad_low || blob_id->gds_quad_high)
					field->fld_description = /*X.RDB$DESCRIPTION*/
								 isc_686.isc_698;
			}

			if (!/*X.RDB$QUERY_HEADER.NULL*/
			     isc_686.isc_715)
			{
				blob_id = &/*X.RDB$QUERY_HEADER*/
					   isc_686.isc_697;
				if (blob_id->gds_quad_low || blob_id->gds_quad_high)
					field->fld_query_header = /*X.RDB$QUERY_HEADER*/
								  isc_686.isc_697;
			}

			if (/*X.RDB$FIELD_POSITION.NULL*/
			    isc_686.isc_713)
				field->fld_flags |= FLD_position_missing;
			else
				field->fld_position = /*X.RDB$FIELD_POSITION*/
						      isc_686.isc_714;
			field->fld_view_context = /*X.RDB$VIEW_CONTEXT*/
						  isc_686.isc_712;
			if (/*X.RDB$UPDATE_FLAG.NULL*/
			    isc_686.isc_710)
				field->fld_flags |= FLD_update_missing;
			else
				field->fld_update_flag = /*X.RDB$UPDATE_FLAG*/
							 isc_686.isc_711;

			COPY (/*X.RDB$FIELD_NAME*/
			      isc_686.isc_696, field->fld_name);
			COPY (/*X.RDB$FIELD_SOURCE*/
			      isc_686.isc_695, field->fld_source);
			COPY (/*X.RDB$BASE_FIELD*/
			      isc_686.isc_694, field->fld_base);
			COPY (/*X.RDB$QUERY_NAME*/
			      isc_686.isc_693, field->fld_query_name);
			COPY (/*X.RDB$EDIT_STRING*/
			      isc_686.isc_692, field->fld_edit_string);
			COPY (/*X.RDB$COMPLEX_NAME*/
			      isc_686.isc_691, field->fld_complex_name);

			blob_id = &/*Y.RDB$COMPUTED_BLR*/
				   isc_686.isc_690;

			if (blob_id->gds_quad_low || blob_id->gds_quad_high) {
				field->fld_flags |= FLD_computed;
			}

			field->fld_system_flag = /*X.RDB$SYSTEM_FLAG*/
						 isc_686.isc_709;

			COPY (/*X.RDB$SECURITY_CLASS*/
			      isc_686.isc_689, field->fld_security_class);

			// use the fld_flags to mark the field as an array and
			// to differentiate it from other blobs

			if (/*Y.RDB$DIMENSIONS*/
			    isc_686.isc_708) {
				field->fld_flags |= FLD_array;
				field->fld_dimensions = /*Y.RDB$DIMENSIONS*/
							isc_686.isc_708;
				if (field->fld_dimensions < 0) {
					BURP_error_redirect (NULL, 52, SafeArg() << field->fld_name);
				}
				// msg 52 array dimension for field %s is invalid
				get_ranges (field);
			}

			if (!/*X.RDB$NULL_FLAG.NULL*/
			     isc_686.isc_706) {
				field->fld_null_flag = /*X.RDB$NULL_FLAG*/
						       isc_686.isc_707;
				field->fld_flags |= FLD_null_flag;
			}

			if (!/*X.RDB$DEFAULT_VALUE.NULL*/
			     isc_686.isc_705) {
				blob_id = &/*X.RDB$DEFAULT_VALUE*/
					   isc_686.isc_688;
				if (blob_id->gds_quad_low || blob_id->gds_quad_high) {
					field->fld_default_value = /*X.RDB$DEFAULT_VALUE*/
								   isc_686.isc_688;
				}
			}

			if (!/*X.RDB$DEFAULT_SOURCE.NULL*/
			     isc_686.isc_704) {
				blob_id = &/*X.RDB$DEFAULT_SOURCE*/
					   isc_686.isc_687;
				if (blob_id->gds_quad_low || blob_id->gds_quad_high) {
					field->fld_default_source = /*X.RDB$DEFAULT_SOURCE*/
								    isc_686.isc_687;
				}
			}

			if (!/*Y.RDB$CHARACTER_SET_ID.NULL*/
			     isc_686.isc_702) {
				field->fld_character_set_id = /*Y.RDB$CHARACTER_SET_ID*/
							      isc_686.isc_703;
				field->fld_flags |= FLD_charset_flag;
			}

			if (!/*X.RDB$COLLATION_ID.NULL*/
			     isc_686.isc_700) {
				field->fld_collation_id = /*X.RDB$COLLATION_ID*/
							  isc_686.isc_701;
				field->fld_flags |= FLD_collate_flag;
			}

			field_list.add(field);

		/*END_FOR;*/
		   }
		   };
		/*ON_ERROR*/
		if (isc_status [1])
		   {
			general_on_error();
		/*END_ERROR;*/
		   }
		}
	}
	else {
		/*FOR (REQUEST_HANDLE tdgbl->handles_get_fields_req_handle1)
			X IN RDB$RELATION_FIELDS CROSS Y IN RDB$FIELDS
			WITH X.RDB$FIELD_SOURCE = Y.RDB$FIELD_NAME AND
			X.RDB$RELATION_NAME EQ relation->rel_name*/
		{
                if (!tdgbl->handles_get_fields_req_handle1)
                   isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &tdgbl->handles_get_fields_req_handle1, (short) sizeof(isc_657), (char*) isc_657);
		isc_vtov ((const char*) relation->rel_name, (char*) isc_658.isc_659, 32);
		if (tdgbl->handles_get_fields_req_handle1)
		   {
                   isc_start_and_send (isc_status, (FB_API_HANDLE*) &tdgbl->handles_get_fields_req_handle1, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 32, &isc_658, (short) 0);
		   }
		if (!isc_status [1]) {
		while (1)
		   {
                   isc_receive (isc_status, (FB_API_HANDLE*) &tdgbl->handles_get_fields_req_handle1, (short) 1, (short) 338, &isc_660, (short) 0);
		   if (!isc_660.isc_670 || isc_status [1]) break;

			field = (burp_fld*) BURP_alloc_zero (sizeof(burp_fld));
			field->fld_number = count++;
			field->fld_type = /*Y.RDB$FIELD_TYPE*/
					  isc_660.isc_682;
			field->fld_sub_type = /*Y.RDB$FIELD_SUB_TYPE*/
					      isc_660.isc_681;
			field->fld_length = /*Y.RDB$FIELD_LENGTH*/
					    isc_660.isc_680;
			field->fld_scale = /*Y.RDB$FIELD_SCALE*/
					   isc_660.isc_679;
			field->fld_id = /*X.RDB$FIELD_ID*/
					isc_660.isc_678;
			if (!/*X.RDB$DESCRIPTION.NULL*/
			     isc_660.isc_677) {
				blob_id = &/*X.RDB$DESCRIPTION*/
					   isc_660.isc_669;
				if (blob_id->gds_quad_low || blob_id->gds_quad_high)
					field->fld_description = /*X.RDB$DESCRIPTION*/
								 isc_660.isc_669;
			}
			if (!/*X.RDB$QUERY_HEADER.NULL*/
			     isc_660.isc_676) {
				blob_id = &/*X.RDB$QUERY_HEADER*/
					   isc_660.isc_668;
				if (blob_id->gds_quad_low || blob_id->gds_quad_high)
					field->fld_query_header = /*X.RDB$QUERY_HEADER*/
								  isc_660.isc_668;
			}
			if (/*X.RDB$FIELD_POSITION.NULL*/
			    isc_660.isc_674)
				field->fld_flags |= FLD_position_missing;
			else
				field->fld_position = /*X.RDB$FIELD_POSITION*/
						      isc_660.isc_675;
			field->fld_view_context = /*X.RDB$VIEW_CONTEXT*/
						  isc_660.isc_673;
			if (/*X.RDB$UPDATE_FLAG.NULL*/
			    isc_660.isc_671)
				field->fld_flags |= FLD_update_missing;
			else
				field->fld_update_flag = /*X.RDB$UPDATE_FLAG*/
							 isc_660.isc_672;
			COPY (/*X.RDB$FIELD_NAME*/
			      isc_660.isc_667, field->fld_name);
			COPY (/*X.RDB$FIELD_SOURCE*/
			      isc_660.isc_666, field->fld_source);
			COPY (/*X.RDB$BASE_FIELD*/
			      isc_660.isc_665, field->fld_base);
			COPY (/*X.RDB$QUERY_NAME*/
			      isc_660.isc_664, field->fld_query_name);
			COPY (/*X.RDB$EDIT_STRING*/
			      isc_660.isc_663, field->fld_edit_string);
			if (tdgbl->BCK_capabilities & BCK_attributes_v3)
			{
				/*FOR (REQUEST_HANDLE tdgbl->handles_get_fields_req_handle2)
					RFR IN RDB$RELATION_FIELDS WITH RFR.RDB$FIELD_NAME = X.RDB$FIELD_NAME AND
					RFR.RDB$RELATION_NAME = X.RDB$RELATION_NAME*/
				{
                                if (!tdgbl->handles_get_fields_req_handle2)
                                   isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &tdgbl->handles_get_fields_req_handle2, (short) sizeof(isc_650), (char*) isc_650);
				isc_vtov ((const char*) isc_660.isc_662, (char*) isc_651.isc_652, 32);
				isc_vtov ((const char*) isc_660.isc_667, (char*) isc_651.isc_653, 32);
				if (tdgbl->handles_get_fields_req_handle2)
				   {
                                   isc_start_and_send (isc_status, (FB_API_HANDLE*) &tdgbl->handles_get_fields_req_handle2, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 64, &isc_651, (short) 0);
				   }
				if (!isc_status [1]) {
				while (1)
				   {
                                   isc_receive (isc_status, (FB_API_HANDLE*) &tdgbl->handles_get_fields_req_handle2, (short) 1, (short) 34, &isc_654, (short) 0);
				   if (!isc_654.isc_656 || isc_status [1]) break;
					COPY (/*RFR.RDB$COMPLEX_NAME*/
					      isc_654.isc_655, field->fld_complex_name);
				/*END_FOR;*/
				   }
				   };
				/*ON_ERROR*/
				if (isc_status [1])
				   {
					general_on_error();
				/*END_ERROR;*/
				   }
				}
			}
			blob_id = &/*Y.RDB$COMPUTED_BLR*/
				   isc_660.isc_661;
			if (blob_id->gds_quad_low || blob_id->gds_quad_high)
				field->fld_flags |= FLD_computed;
			if (tdgbl->BCK_capabilities & BCK_rfr_sys_flag)
			{
				/*FOR (REQUEST_HANDLE tdgbl->handles_get_fields_req_handle3)
					RFR IN RDB$RELATION_FIELDS WITH
					RFR.RDB$RELATION_NAME = relation->rel_name
					AND RFR.RDB$FIELD_NAME = X.RDB$FIELD_NAME*/
				{
                                if (!tdgbl->handles_get_fields_req_handle3)
                                   isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &tdgbl->handles_get_fields_req_handle3, (short) sizeof(isc_643), (char*) isc_643);
				isc_vtov ((const char*) isc_660.isc_667, (char*) isc_644.isc_645, 32);
				isc_vtov ((const char*) relation->rel_name, (char*) isc_644.isc_646, 32);
				if (tdgbl->handles_get_fields_req_handle3)
				   {
                                   isc_start_and_send (isc_status, (FB_API_HANDLE*) &tdgbl->handles_get_fields_req_handle3, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 64, &isc_644, (short) 0);
				   }
				if (!isc_status [1]) {
				while (1)
				   {
                                   isc_receive (isc_status, (FB_API_HANDLE*) &tdgbl->handles_get_fields_req_handle3, (short) 1, (short) 4, &isc_647, (short) 0);
				   if (!isc_647.isc_648 || isc_status [1]) break;
					field->fld_system_flag = /*RFR.RDB$SYSTEM_FLAG*/
								 isc_647.isc_649;
				/*END_FOR;*/
				   }
				   };
				/*ON_ERROR*/
				if (isc_status [1])
				   {
					general_on_error();
				/*END_ERROR;*/
				   }
				}
			}
			if (tdgbl->BCK_capabilities & BCK_security)
			{
				/*FOR (REQUEST_HANDLE tdgbl->handles_get_fields_req_handle4)
					RFR IN RDB$RELATION_FIELDS WITH
					RFR.RDB$RELATION_NAME = relation->rel_name
					AND RFR.RDB$FIELD_NAME = X.RDB$FIELD_NAME*/
				{
                                if (!tdgbl->handles_get_fields_req_handle4)
                                   isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &tdgbl->handles_get_fields_req_handle4, (short) sizeof(isc_636), (char*) isc_636);
				isc_vtov ((const char*) isc_660.isc_667, (char*) isc_637.isc_638, 32);
				isc_vtov ((const char*) relation->rel_name, (char*) isc_637.isc_639, 32);
				if (tdgbl->handles_get_fields_req_handle4)
				   {
                                   isc_start_and_send (isc_status, (FB_API_HANDLE*) &tdgbl->handles_get_fields_req_handle4, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 64, &isc_637, (short) 0);
				   }
				if (!isc_status [1]) {
				while (1)
				   {
                                   isc_receive (isc_status, (FB_API_HANDLE*) &tdgbl->handles_get_fields_req_handle4, (short) 1, (short) 34, &isc_640, (short) 0);
				   if (!isc_640.isc_642 || isc_status [1]) break;
					COPY (/*RFR.RDB$SECURITY_CLASS*/
					      isc_640.isc_641, field->fld_security_class);
				/*END_FOR;*/
				   }
				   };
				/*ON_ERROR*/
				if (isc_status [1])
				   {
					general_on_error();
				/*END_ERROR;*/
				   }
				}
			}
			if (tdgbl->BCK_capabilities & BCK_attributes_v3)
			{
				/*FOR (REQUEST_HANDLE tdgbl->handles_get_fields_req_handle5)
					RF IN RDB$FIELDS WITH RF.RDB$FIELD_NAME = X.RDB$FIELD_SOURCE*/
				{
                                if (!tdgbl->handles_get_fields_req_handle5)
                                   isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &tdgbl->handles_get_fields_req_handle5, (short) sizeof(isc_630), (char*) isc_630);
				isc_vtov ((const char*) isc_660.isc_666, (char*) isc_631.isc_632, 32);
				if (tdgbl->handles_get_fields_req_handle5)
				   {
                                   isc_start_and_send (isc_status, (FB_API_HANDLE*) &tdgbl->handles_get_fields_req_handle5, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 32, &isc_631, (short) 0);
				   }
				if (!isc_status [1]) {
				while (1)
				   {
                                   isc_receive (isc_status, (FB_API_HANDLE*) &tdgbl->handles_get_fields_req_handle5, (short) 1, (short) 4, &isc_633, (short) 0);
				   if (!isc_633.isc_634 || isc_status [1]) break;
					// use the fld_flags to mark the field as an array and
					// to differentiate it from other blobs
					if (/*RF.RDB$DIMENSIONS*/
					    isc_633.isc_635)
					{
						field->fld_flags |= FLD_array;
						field->fld_dimensions = /*RF.RDB$DIMENSIONS*/
									isc_633.isc_635;
						if (field->fld_dimensions < 0) {
							BURP_error_redirect (NULL, 52, SafeArg() << field->fld_name);
							// msg 52 array dimension for field %s is invalid
						}
						get_ranges (field);
					}
				/*END_FOR;*/
				   }
				   };
				/*ON_ERROR*/
				if (isc_status [1])
				   {
					general_on_error();
				/*END_ERROR;*/
				   }
				}
			}
			if (tdgbl->BCK_capabilities & BCK_ods8)
			{
				/*FOR (REQUEST_HANDLE tdgbl->handles_get_fields_req_handle6)
					X2 IN RDB$RELATION_FIELDS CROSS F2 IN RDB$FIELDS
					WITH X2.RDB$FIELD_NAME = X.RDB$FIELD_NAME
					AND X2.RDB$RELATION_NAME EQ relation->rel_name
					AND X2.RDB$FIELD_SOURCE EQ F2.RDB$FIELD_NAME*/
				{
                                if (!tdgbl->handles_get_fields_req_handle6)
                                   isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &tdgbl->handles_get_fields_req_handle6, (short) sizeof(isc_614), (char*) isc_614);
				isc_vtov ((const char*) relation->rel_name, (char*) isc_615.isc_616, 32);
				isc_vtov ((const char*) isc_660.isc_667, (char*) isc_615.isc_617, 32);
				if (tdgbl->handles_get_fields_req_handle6)
				   {
                                   isc_start_and_send (isc_status, (FB_API_HANDLE*) &tdgbl->handles_get_fields_req_handle6, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 64, &isc_615, (short) 0);
				   }
				if (!isc_status [1]) {
				while (1)
				   {
                                   isc_receive (isc_status, (FB_API_HANDLE*) &tdgbl->handles_get_fields_req_handle6, (short) 1, (short) 34, &isc_618, (short) 0);
				   if (!isc_618.isc_621 || isc_status [1]) break;

					if (!/*X2.RDB$NULL_FLAG.NULL*/
					     isc_618.isc_628)
					{
						field->fld_null_flag = /*X2.RDB$NULL_FLAG*/
								       isc_618.isc_629;
						field->fld_flags |= FLD_null_flag;
					}
					if (!/*X2.RDB$DEFAULT_VALUE.NULL*/
					     isc_618.isc_627)
					{
						blob_id = &/*X2.RDB$DEFAULT_VALUE*/
							   isc_618.isc_620;
						if (blob_id->gds_quad_low || blob_id->gds_quad_high)
							field->fld_default_value = /*X2.RDB$DEFAULT_VALUE*/
										   isc_618.isc_620;
					}
					if (!/*X2.RDB$DEFAULT_SOURCE.NULL*/
					     isc_618.isc_626)
					{
						blob_id = &/*X2.RDB$DEFAULT_SOURCE*/
							   isc_618.isc_619;
						if (blob_id->gds_quad_low || blob_id->gds_quad_high)
							field->fld_default_source = /*X2.RDB$DEFAULT_SOURCE*/
										    isc_618.isc_619;
					}
					if (!/*F2.RDB$CHARACTER_SET_ID.NULL*/
					     isc_618.isc_624)
					{
						field->fld_character_set_id = /*F2.RDB$CHARACTER_SET_ID*/
									      isc_618.isc_625;
						field->fld_flags |= FLD_charset_flag;
					}
					if (!/*X2.RDB$COLLATION_ID.NULL*/
					     isc_618.isc_622)
					{
						field->fld_collation_id = /*X2.RDB$COLLATION_ID*/
									  isc_618.isc_623;
						field->fld_flags |= FLD_collate_flag;
					}
				/*END_FOR;*/
				   }
				   };
				/*ON_ERROR*/
				if (isc_status [1])
				   {
					general_on_error();
				/*END_ERROR;*/
				   }
				}
			}

			field_list.add(field);

		/*END_FOR;*/
		   }
		   };
		/*ON_ERROR*/
		if (isc_status [1])
		   {
			general_on_error();
		/*END_ERROR;*/
		   }
		}
	}

	burp_fld* fields = NULL;

	while (field_list.getCount())
	{
		field = field_list.pop();
		field->fld_next = fields;
		fields = field;
	}

	return fields;
}


SINT64 get_gen_id( const TEXT* name, SSHORT name_len)
{
/**************************************
 *
 *	g e t _ g e n _ i d
 *
 **************************************
 *
 * Functional description
 *	Read id for a generator;
 *
 **************************************/
	UCHAR blr_buffer[100];	// enough to fit blr

	BurpGlobals* tdgbl = BurpGlobals::getSpecific();

	FB_API_HANDLE gen_id_reqh = 0;
	UCHAR* blr = blr_buffer;

	// If this is ODS 10 (IB version 6.0) or greater, build BLR to retrieve
	// the 64-bit value of the generator.  If not, build BLR to retrieve the
	// 32-bit value, which we will cast to the expected INT64 format.

	if (tdgbl->BCK_capabilities & BCK_ods10)
	{
		// build the blr with the right relation name and 64-bit results.
		add_byte(blr, blr_version5);
		add_byte(blr, blr_begin);
		add_byte(blr, blr_message);
		add_byte(blr, 0);
		add_word(blr, 1);
		add_byte(blr, blr_int64);
		add_byte(blr, 0);
		add_byte(blr, blr_send);
		add_byte(blr, 0);
		add_byte(blr, blr_assignment);
		add_byte(blr, blr_gen_id);
		add_byte(blr, name_len);
		while (name_len--)
		{
			const UCHAR c = *name++;
			add_byte(blr, c);
		}
		add_byte(blr, blr_literal);
		add_byte(blr, blr_long);
		add_byte(blr, 0);
		add_word(blr, 0);
		add_word(blr, 0);
		add_byte(blr, blr_parameter);
		add_byte(blr, 0);
		add_word(blr, 0);
		add_byte(blr, blr_end);
		add_byte(blr, blr_eoc);
	}
	else
	{
		// build the blr with the right relation name and 32-bit results
		add_byte(blr, blr_version4);
		add_byte(blr, blr_begin);
		add_byte(blr, blr_message);
		add_byte(blr, 0);
		add_word(blr, 1);
		add_byte(blr, blr_long);
		add_byte(blr, 0);
		add_byte(blr, blr_send);
		add_byte(blr, 0);
		add_byte(blr, blr_assignment);
		add_byte(blr, blr_gen_id);
		add_byte(blr, name_len);
		while (name_len--)
		{
			const UCHAR c = *name++;
			add_byte(blr, c);
		}
		add_byte(blr, blr_literal);
		add_byte(blr, blr_long);
		add_byte(blr, 0);
		add_word(blr, 0);
		add_word(blr, 0);
		add_byte(blr, blr_parameter);
		add_byte(blr, 0);
		add_word(blr, 0);
		add_byte(blr, blr_end);
		add_byte(blr, blr_eoc);
	}

	const SSHORT blr_length = blr - blr_buffer;

#ifdef DEBUG
	if (debug_on)
		fb_print_blr(blr_buffer, blr_length, NULL, NULL, 0);
#endif

	ISC_STATUS_ARRAY status_vector;
	if (isc_compile_request(status_vector, &DB, &gen_id_reqh, blr_length, (const char*) blr_buffer))
	{
		// if there's no gen_id, never mind ...
		return 0;
	}

	// use the same gds_trans generated by gpre
	if (isc_start_request(status_vector, &gen_id_reqh, &gds_trans, 0))
	{
		BURP_error_redirect(status_vector, 25);
		// msg 25 Failed in put_blr_gen_id
	}


	SINT64 read_msg1;
	if (tdgbl->BCK_capabilities & BCK_ods10)
	{
		if (isc_receive(status_vector, &gen_id_reqh, 0, sizeof(read_msg1), &read_msg1, 0))
		{
			BURP_error_redirect(status_vector, 25);
			// msg 25 Failed in put_blr_gen_id
		}
	}
	else
	{
		SLONG read_msg0;
		if (isc_receive(status_vector, &gen_id_reqh, 0, sizeof(read_msg0), &read_msg0, 0))
		{
			BURP_error_redirect(status_vector, 25);
			// msg 25 Failed in put_blr_gen_id
		}
		read_msg1 = (SINT64) read_msg0;
	}

	isc_release_request(status_vector, &gen_id_reqh);

	return read_msg1;
}


void get_ranges( burp_fld* field)
{
   struct isc_609_struct {
          ISC_LONG isc_610;	/* RDB$UPPER_BOUND */
          ISC_LONG isc_611;	/* RDB$LOWER_BOUND */
          short isc_612;	/* isc_utility */
          short isc_613;	/* RDB$DIMENSION */
   } isc_609;
   struct isc_607_struct {
          char  isc_608 [32];	/* RDB$FIELD_NAME */
   } isc_607;
/**************************************
 *
 *	g e t _ r a n g e s
 *
 **************************************
 *
 * Functional description
 *	Fill in the range low and high bounds by reading
 *      the ranges in rdb$field_dimensions.
 *
 **************************************/
	BurpGlobals* tdgbl = BurpGlobals::getSpecific();

	SLONG* rp = field->fld_ranges;
	USHORT count = 0;

	// Get the array dimensions in the rdb$field_dimensions

	/*FOR (REQUEST_HANDLE tdgbl->handles_get_ranges_req_handle1)
		X IN RDB$FIELD_DIMENSIONS
		WITH X.RDB$FIELD_NAME EQ field->fld_source
		SORTED BY X.RDB$DIMENSION*/
	{
        if (!tdgbl->handles_get_ranges_req_handle1)
           isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &tdgbl->handles_get_ranges_req_handle1, (short) sizeof(isc_606), (char*) isc_606);
	isc_vtov ((const char*) field->fld_source, (char*) isc_607.isc_608, 32);
	if (tdgbl->handles_get_ranges_req_handle1)
	   {
           isc_start_and_send (isc_status, (FB_API_HANDLE*) &tdgbl->handles_get_ranges_req_handle1, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 32, &isc_607, (short) 0);
	   }
	if (!isc_status [1]) {
	while (1)
	   {
           isc_receive (isc_status, (FB_API_HANDLE*) &tdgbl->handles_get_ranges_req_handle1, (short) 1, (short) 12, &isc_609, (short) 0);
	   if (!isc_609.isc_612 || isc_status [1]) break;

		if (count != /*X.RDB$DIMENSION*/
			     isc_609.isc_613)
			BURP_error_redirect (NULL, 52, SafeArg() << field->fld_name);
			// msg 52 array dimension for field %s is invalid
		*rp++ = /*X.RDB$LOWER_BOUND*/
			isc_609.isc_611;
		*rp++ = /*X.RDB$UPPER_BOUND*/
			isc_609.isc_610;
		count++;

	/*END_FOR;*/
	   }
	   };
	/*ON_ERROR*/
	if (isc_status [1])
	   {
		general_on_error();
	/*END_ERROR;*/
	   }
	}

	if (count != field->fld_dimensions)
		BURP_error_redirect(NULL, 52, SafeArg() << field->fld_name);
		// msg 52 array dimension for field %s is invalid
}


void put_array( burp_fld* field, burp_rel* relation, ISC_QUAD* blob_id)
{
/**************************************
 *
 *	p u t _ a r r a y
 *
 **************************************
 *
 * Functional description
 *	Write out an array.  If, however, it's null, don't even bother.
 *
 **************************************/
	SLONG range_buffer[16];	// enough for 16 dimensions
	UCHAR blr_buffer[200];		// enough for a sdl with 16 dimensions

	BurpGlobals* tdgbl = BurpGlobals::getSpecific();

	// If the array is null, don't store it.  It will be restored as null.

	if (!blob_id->gds_quad_low && !blob_id->gds_quad_high)
		return;

	lstring xdr_buffer;
	xdr_buffer.lstr_allocated = 0;
	xdr_buffer.lstr_address = NULL;

	UCHAR* blr = blr_buffer;
	const SLONG* const end_ranges = field->fld_ranges + 2 * field->fld_dimensions;

	USHORT field_length = field->fld_length;
	if (tdgbl->gbl_sw_transportable)
		xdr_buffer.lstr_length = field_length + 3;

	// build the sdl

	add_byte(blr, isc_sdl_version1);

	add_byte(blr, isc_sdl_struct);
	add_byte(blr, 1);

	add_byte(blr, field->fld_type);

	switch (field->fld_type)
	{
	case blr_short:
	case blr_long:
	case blr_quad:
	case blr_int64:
		add_byte(blr, field->fld_scale);
		break;
	case blr_text:
	case blr_varying:
		add_word(blr, field->fld_length);
		break;
	}

	if (field->fld_type == blr_varying)
		field_length += sizeof(USHORT);

	add_byte(blr, isc_sdl_rid);
	add_word(blr, relation->rel_id);
	add_byte(blr, isc_sdl_fid);
	add_word(blr, field->fld_id);

	USHORT count = 0;
	for (const SLONG* range = field->fld_ranges; range < end_ranges; range += 2, count++)
	{
		add_byte(blr, isc_sdl_do2);
		add_byte(blr, count);
		add_byte(blr, isc_sdl_long_integer);
		add_long(blr, range[0]);
		add_byte(blr, isc_sdl_long_integer);
		add_long(blr, range[1]);
	}

	add_byte(blr, isc_sdl_element);
	add_byte(blr, 1);
	add_byte(blr, isc_sdl_scalar);
	add_byte(blr, 0);
	add_byte(blr, field->fld_dimensions);

	for (count = 0; count < field->fld_dimensions; count++)
	{
		add_byte(blr, isc_sdl_variable);
		add_byte(blr, count);
	}

	add_byte(blr, isc_sdl_eoc);

#ifdef DEBUG
	if (debug_on)
		PRETTY_print_sdl(blr_buffer, NULL, NULL, 0);
#endif

	const USHORT blr_length = blr - blr_buffer;

	// compute the range size for each dimension = high_range - low_range

	ULONG slice_length = field_length;
	for (const SLONG* range = field->fld_ranges; range < end_ranges; range += 2)
	{
		slice_length *= (range[1] - range[0] + 1);
		if (tdgbl->gbl_sw_transportable)
			xdr_buffer.lstr_length *= (range[1] - range[0] + 1);
	}
	UCHAR* slice = BURP_alloc(slice_length);

	// allocate space for the XDR representation

	if (tdgbl->gbl_sw_transportable)
	{
		xdr_buffer.lstr_address = BURP_alloc(xdr_buffer.lstr_length);
		xdr_buffer.lstr_allocated = xdr_buffer.lstr_length;
	}

	ISC_STATUS_ARRAY status_vector;
	ULONG return_length = 0;
	if (isc_get_slice(status_vector, &DB, &gds_trans, blob_id, blr_length, (const char*) blr_buffer,
					  0,	// param length for subset of an array handling
					  NULL,	// param for subset of an array handling
					  slice_length, slice, (SLONG*) &return_length))
	{
		BURP_print(false, 81, field->fld_name);
		// msg 81 error accessing blob field %s -- continuing
		BURP_print_status(false, status_vector);
#ifdef DEBUG
		PRETTY_print_sdl(blr_buffer, NULL, NULL, 0);
#endif
		// CVC: At this point I would expected calls to deallocate memory
		// See the end of this function.
		BURP_free(slice);
		if (xdr_buffer.lstr_allocated)
			BURP_free(xdr_buffer.lstr_address);
		return;
	}

	if (return_length != slice_length)
	{
		// Ugh.  The full array wasn't returned.  We must recompute the top
		// element to backup.

		SLONG returned_elements = (return_length / field_length) - 1;

		SLONG* returned_range = range_buffer;
		const SLONG* range = end_ranges - 2;
		for (int i1 = 0, i3 = 0;
			 range >= field->fld_ranges; range -= 2, returned_range++, i1++)
		{
			int divisor = 1;
			for (int i2 = (2 * (i1 + 1) + 1); i2 <= field->fld_dimensions * 2; i2 += 2)
			{
				divisor *= (field->fld_ranges[i2] - field->fld_ranges[i2 - 1] + 1);
			}
			*returned_range = (returned_elements - 1) / divisor + field->fld_ranges[i3];
			returned_elements -= (*returned_range - field->fld_ranges[i3]) * divisor;
			i3 += 2;
		}
	}

	put(tdgbl, (UCHAR) rec_array);
	put_numeric(att_blob_field_number, field->fld_number);
	put_numeric(att_array_dimensions, field->fld_dimensions);

	SLONG* returned_range = range_buffer;
	for (const SLONG* range = field->fld_ranges; range < end_ranges; range += 2, returned_range++)
	{
		put_numeric(att_array_range_low, (int) range[0]);
		if (return_length == slice_length)
			put_numeric(att_array_range_high, (int) range[1]);
		else
			put_numeric(att_array_range_high, (int) *returned_range);
	}

	put(tdgbl, att_blob_data);
	put(tdgbl, (UCHAR) (return_length));
	put(tdgbl, (UCHAR) (return_length >> 8));
	put(tdgbl, (UCHAR) (return_length >> 16));
	put(tdgbl, (UCHAR) (return_length >> 24));

	if (return_length)
	{
		const UCHAR* p;
		if (tdgbl->gbl_sw_transportable)
		{
			lstring xdr_slice;
			xdr_slice.lstr_allocated = xdr_slice.lstr_length = return_length;
			xdr_slice.lstr_address = slice;
			return_length = CAN_slice(&xdr_buffer, &xdr_slice, TRUE, /*blr_length,*/ blr_buffer);
			put(tdgbl, att_xdr_array);
			put(tdgbl, (UCHAR) (return_length));
			put(tdgbl, (UCHAR) (return_length >> 8));
			put(tdgbl, (UCHAR) (return_length >> 16));
			put(tdgbl, (UCHAR) (return_length >> 24));
			p = xdr_buffer.lstr_address;
		}
		else
			p = slice;
		put_block(tdgbl, p, return_length);
	}

	BURP_free(slice);
	if (xdr_buffer.lstr_allocated)
		BURP_free(xdr_buffer.lstr_address);
}


void put_asciz( const att_type attribute, const TEXT* string)
{
/**************************************
 *
 *	p u t _ a s c i z
 *
 **************************************
 *
 * Functional description
 *	Write an attribute starting with a null terminated string.
 *	Currently it's only called by write_database with the db's name as param.
 *
 **************************************/
	BurpGlobals* tdgbl = BurpGlobals::getSpecific();

	ULONG l = strlen(string);
	// CVC: We'll have to ensure that length < MAX_FILE_NAME_SIZE.
	// For now, we'll truncate silently until we define a message.
	// We can't honor operating systems that allow longer file names.
	if (l >= MAX_FILE_NAME_SIZE)
	{
		//BURP_print(CREATE A MESSAGE, SafeArg() << string << (MAX_FILE_NAME_SIZE - 1));
		// msg ZZZ: name %s too large, truncating to %d bytes.
		l = MAX_FILE_NAME_SIZE - 1;
	}

	put(tdgbl, attribute);
	put(tdgbl, (UCHAR) l);
	if (l)
		put_block(tdgbl, (const UCHAR*) string, l);
}


void put_blob( burp_fld* field, ISC_QUAD& blob_id)
{
/**************************************
 *
 *	p u t _ b l o b
 *
 **************************************
 *
 * Functional description
 *	Write out a blob.  If, however, it's null, don't even bother.
 *	This is for user data blobs.
 *
 **************************************/
	ISC_STATUS_ARRAY status_vector;

	BurpGlobals* tdgbl = BurpGlobals::getSpecific();

	// If the blob is null, don't store it.  It will be restored as null.

	if (UserBlob::blobIsNull(blob_id))
		return;

	// Open the blob and get it's vital statistics

	UserBlob blob(status_vector);

	if (!blob.open(DB, gds_trans, blob_id))
	{
		BURP_print(false, 81, field->fld_name);
		// msg 81 error accessing blob field %s -- continuing
		BURP_print_status(false, status_vector);
		return;
	}

	UCHAR blob_info[32];
	if (!blob.getInfo(sizeof(blob_items), blob_items, sizeof(blob_info), blob_info))
	{
		BURP_error_redirect(status_vector, 20);
		// msg 20 isc_blob_info failed
	}

	put(tdgbl, (UCHAR) rec_blob);
	put_numeric(att_blob_field_number, field->fld_number);

	ULONG segments = 0, total_length = 0;
	USHORT max_segment = 0;
	int blob_type = 0; // 0 - segmented, 1 - stream
	const UCHAR* p = blob_info;

	UCHAR item;
	while ((item = *p++) != isc_info_end)
	{
		const USHORT l = gds__vax_integer(p, 2);
		p += 2;
		const ULONG n = gds__vax_integer(p, l);
		p += l;
		switch (item)
		{
		case isc_info_blob_max_segment:
			max_segment = n;
			break;

		case isc_info_blob_type:
			blob_type = n;
			break;

		case isc_info_blob_num_segments:
			segments = n;
			break;

		case isc_info_blob_total_length:
			total_length = n;
			break;

		default:
			BURP_error_redirect(NULL, 21, SafeArg() << int(item));
			// msg 21 don't understand blob info item %ld
		}
	}

	// NS: Compute number of chunks we are going to write for stream blob based
	// on total blob length and maximum segment size. This way we tend to
	// preserve maximum internal segment size over backup/restore. I'm not sure
	// this is beneficial, but let's do it for the moment instead of inventing
	// our own chunk size. Note, the number of segments returned by information
	// call for stream blob is always unreliable, even for zero-length blobs
	if (blob_type == 1) {
		if (total_length != 0)
			segments = (total_length + max_segment - 1) / max_segment;
		else
			segments = 0;
	}

	put_numeric(att_blob_max_segment, max_segment);
	put_numeric(att_blob_number_segments, segments);
	put_numeric(att_blob_type, blob_type);

	// Allocate a buffer large enough for the largest segment and start grinding.
	UCHAR static_buffer[1024];
	UCHAR* buffer;
	if (!max_segment || max_segment <= sizeof(static_buffer))
		buffer = static_buffer;
	else
		buffer = BURP_alloc(max_segment);

	put(tdgbl, att_blob_data);

	while (segments > 0)
	{
		size_t segment_length;
		blob.getSegment(max_segment, buffer, segment_length);

		const ISC_STATUS status = blob.getCode();
		// Handle the errors. For stream blob isc_segment is not error here.
		if (status && (status != isc_segment || blob_type == 0))
		{
			BURP_error_redirect(status_vector, 22);
			// msg 22 isc_get_segment failed
		}

		put(tdgbl, (UCHAR) (segment_length));
		put(tdgbl, (UCHAR) (segment_length >> 8));
		if (segment_length)
		{
			put_block(tdgbl, buffer, segment_length);
		}
		--segments;
	}

	if (!blob.close())
		BURP_error_redirect(status_vector, 23);
		// msg 23 isc_close_blob failed

	if (buffer != static_buffer)
		BURP_free(buffer);
}


bool put_blr_blob( att_type attribute, ISC_QUAD& blob_id)
{
/**************************************
 *
 *	p u t _ b l r _ b l o b
 *
 **************************************
 *
 * Functional description
 *	Write out a blr blob, if present.  Otherwise do nothing.
 *	Return true if the blob was present, false otherwise.
 *
 **************************************/
	ISC_STATUS_ARRAY status_vector;
	BurpGlobals* tdgbl = BurpGlobals::getSpecific();

	// If the blob is null, don't store it.  It will be restored as null.

	if (UserBlob::blobIsNull(blob_id))
		return false;

	// Open the blob and get it's vital statistics

	UserBlob blob(status_vector);

	if (!blob.open(DB, gds_trans, blob_id))
	{
		BURP_error_redirect(status_vector, 24);
		// msg 24 isc_open_blob failed
	}

	UCHAR blob_info[32];
	if (!blob.getInfo(sizeof(blr_items), blr_items, sizeof(blob_info), blob_info))
	{
		BURP_error_redirect(status_vector, 20);
		// msg 20 isc_blob_info failed
	}

	ULONG length = 0;
	USHORT max_segment = 0;
	const UCHAR* p = blob_info;
	UCHAR item;

	while ((item = *p++) != isc_info_end)
	{
		const USHORT l = isc_vax_integer((const char*) p, 2);
		p += 2;
		const ULONG n = isc_vax_integer((const char*) p, l);
		p += l;
		switch (item)
		{
		case isc_info_blob_max_segment:
			max_segment = n;
			break;

		case isc_info_blob_total_length:
			length = n;
			break;

		default:
			BURP_print(true, 79, SafeArg() << int(item));
			// msg 79 don't understand blob info item %ld
			if (!blob.close())
				BURP_error_redirect(status_vector, 23);
				// msg 23 isc_close_blob failed
			return false;
		}
	}

	if (!length)
	{
		if (!blob.close())
			BURP_error_redirect(status_vector, 23);
			// msg 23 isc_close_blob failed
		return false;
	}

	// Rdb sometimes gets the length messed up

	if (length < max_segment)
		length = max_segment;

	put_numeric(attribute, (int) length);

	// Allocate a buffer large enough for the largest segment and start grinding.

	UCHAR static_buffer[1024];
	UCHAR* buffer;
	if (!max_segment || max_segment <= sizeof(static_buffer))
		buffer = static_buffer;
	else
		buffer = BURP_alloc(max_segment);

	// The old code didn't accept isc_segment so we check it.
	size_t segment_length;
	while (blob.getSegment(max_segment, buffer, segment_length) && !blob.getCode())
	{
		if (segment_length)
		{
			put_block(tdgbl, buffer, segment_length);
		}
	}

	if (!blob.close())
	{
		BURP_error_redirect(status_vector, 23);
		// msg 23 isc_close_blob failed
	}

	if (buffer != static_buffer)
		BURP_free(buffer);

	return true;
}


void put_data(burp_rel* relation)
{
/**************************************
 *
 *	p u t _ d a t a
 *
 **************************************
 *
 * Functional description
 *	Write relation meta-data and data.
 *
 **************************************/
	burp_fld* field;
	ISC_STATUS_ARRAY status_vector;

	BurpGlobals* tdgbl = BurpGlobals::getSpecific();

	// CVC: A signed short isn't enough if the engine allows near 32K fields,
	// each being char(1) ASCII in the worst case. Looking at BLR generation
	// below, it's clear an extreme case won't compile => blr_length >= 32K.
	// However, SSHORT is the limit for request_length in isc_compile_request.
	SSHORT field_count = 1;

	for (field = relation->rel_fields; field; field = field->fld_next)
	{
		if (!(field->fld_flags & FLD_computed))
		{
			field_count += 2;
		}
	}
	fb_assert(field_count > 0 && field_count * 9 > 0 && field_count * 9 + 200 > 0);

	// Time to generate blr to fetch data.  Make sure we allocate a BLR buffer
	// large enough to handle the per field overhead
	UCHAR* const blr_buffer = BURP_alloc(200 + field_count * 9);
	UCHAR* blr = blr_buffer;
	add_byte(blr, blr_version4);
	add_byte(blr, blr_begin);
	add_byte(blr, blr_message);
	add_byte(blr, 0);				// Message number
	add_word(blr, field_count);		// Number of fields, counting eof

	RCRD_OFFSET offset = 0;
	SSHORT count = 0;   // This is param count.

	for (field = relation->rel_fields; field; field = field->fld_next)
	{
		if (field->fld_flags & FLD_computed)
			continue;
		SSHORT alignment = 4;
		FLD_LENGTH length = field->fld_length;
		SSHORT dtype = field->fld_type;
		if (field->fld_flags & FLD_array)
		{
			dtype = blr_blob;
			length = 8;
		}
		switch (dtype)
		{
		case blr_text:
			alignment = type_alignments[dtype_text];
			add_byte(blr, field->fld_type);
			add_word(blr, field->fld_length);
			break;

		case blr_varying:
			alignment = type_alignments[dtype_varying];
			add_byte(blr, field->fld_type);
			add_word(blr, field->fld_length);
			length += sizeof(USHORT);
			break;

		case blr_short:
			alignment = type_alignments[dtype_short];
			add_byte(blr, field->fld_type);
			add_byte(blr, field->fld_scale);
			break;

		case blr_long:
			alignment = type_alignments[dtype_long];
			add_byte(blr, field->fld_type);
			add_byte(blr, field->fld_scale);
			break;

		case blr_quad:
			alignment = type_alignments[dtype_quad];
			add_byte(blr, field->fld_type);
			add_byte(blr, field->fld_scale);
			break;

		case blr_int64:
			alignment = type_alignments[dtype_int64];
			add_byte(blr, field->fld_type);
			add_byte(blr, field->fld_scale);
			break;

		case blr_double:
			alignment = type_alignments[dtype_double];
			add_byte(blr, field->fld_type);
			break;

		case blr_timestamp:
			alignment = type_alignments[dtype_timestamp];
			add_byte(blr, field->fld_type);
			break;

		case blr_sql_time:
			alignment = type_alignments[dtype_sql_time];
			add_byte(blr, field->fld_type);
			break;

		case blr_sql_date:
			alignment = type_alignments[dtype_sql_date];
			add_byte(blr, field->fld_type);
			break;

		case blr_float:
			alignment = type_alignments[dtype_real];
			add_byte(blr, field->fld_type);
			break;

		case blr_blob:
			alignment = type_alignments[dtype_blob];
			add_byte(blr, blr_quad);
			add_byte(blr, 0);
			break;

		default:
			BURP_error_redirect(NULL, 26, SafeArg() << field->fld_type);
			// msg 26 datatype %ld not understood
			break;
		}
		if (alignment)
			offset = FB_ALIGN(offset, alignment);
		field->fld_offset = offset;
		field->fld_parameter = count++;
		offset += length;
	}

	// Next, build fields for null flags

	for (field = relation->rel_fields; field; field = field->fld_next)
	{
		if (field->fld_flags & FLD_computed)
			continue;
		add_byte(blr, blr_short);
		add_byte(blr, 0);
		offset = FB_ALIGN(offset, sizeof(SSHORT));
		field->fld_missing_parameter = count++;
		offset += sizeof(SSHORT);
	}

	// Finally, make up an EOF field

	add_byte(blr, blr_short);			// eof field
	add_byte(blr, 0);					// scale for eof field
	SSHORT eof_parameter = count++;
	RCRD_OFFSET record_length = offset;
	RCRD_OFFSET eof_offset = FB_ALIGN(offset, sizeof(SSHORT));
	// To be used later for the buffer size to receive data
	const FLD_LENGTH length = (USHORT) (eof_offset + sizeof(SSHORT));

	// Build FOR loop, body, and eof handler

	add_byte(blr, blr_for);
	add_byte(blr, blr_rse);
	add_byte(blr, 1);					// count of relations
	add_byte(blr, blr_rid);
	add_word(blr, relation->rel_id);
	add_byte(blr, 0);					// context variable
	add_byte(blr, blr_end);

	add_byte(blr, blr_send);
	add_byte(blr, 0);
	add_byte(blr, blr_begin);
	add_byte(blr, blr_assignment);
	add_byte(blr, blr_literal);
	add_byte(blr, blr_short);
	add_byte(blr, 0);
	add_word(blr, 1);
	add_byte(blr, blr_parameter);
	add_byte(blr, 0);
	add_word(blr, eof_parameter);

	for (field = relation->rel_fields; field; field = field->fld_next)
	{
		if (field->fld_flags & FLD_computed)
			continue;
		add_byte(blr, blr_assignment);
		add_byte(blr, blr_fid);
		add_byte(blr, 0);
		add_word(blr, field->fld_id);
		add_byte(blr, blr_parameter2);
		add_byte(blr, 0);
		add_word(blr, field->fld_parameter);
		add_word(blr, field->fld_missing_parameter);
	}

	add_byte(blr, blr_end);

	add_byte(blr, blr_send);
	add_byte(blr, 0);
	add_byte(blr, blr_assignment);
	add_byte(blr, blr_literal);
	add_byte(blr, blr_short);
	add_byte(blr, 0);
	add_word(blr, 0);
	add_byte(blr, blr_parameter);
	add_byte(blr, 0);
	add_word(blr, eof_parameter);

	add_byte(blr, blr_end);
	add_byte(blr, blr_eoc);

	SSHORT blr_length = blr - blr_buffer;

#ifdef DEBUG
	if (debug_on)
		fb_print_blr(blr_buffer, blr_length, NULL, NULL, 0);
#endif

	// Compile request

	FB_API_HANDLE request = 0;
	if (isc_compile_request(status_vector, &DB, &request, blr_length, (const SCHAR*) blr_buffer))
	{
		BURP_error_redirect(status_vector, 27);
		// msg 27 isc_compile_request failed
		fb_print_blr(blr_buffer, blr_length, NULL, NULL, 0);
	}

	BURP_free(blr_buffer);

	BURP_verbose(142, relation->rel_name);
	// msg 142  writing data for relation %s

	if (isc_start_request(status_vector, &request, &gds_trans, 0))
	{
		BURP_error_redirect(status_vector, 28);
		// msg 28 isc_start_request failed
	}

	// Here is the crux of the problem -- writing data.  All this work
	// for the following small loop.

	UCHAR* buffer = BURP_alloc(length);
	SSHORT* eof = (SSHORT *) (buffer + eof_offset);

	// the XDR representation may be even fluffier
	lstring xdr_buffer;
	if (tdgbl->gbl_sw_transportable)
	{
		xdr_buffer.lstr_length = xdr_buffer.lstr_allocated = length + count * 3;
		xdr_buffer.lstr_address = BURP_alloc(xdr_buffer.lstr_length);
	}
	else
		xdr_buffer.lstr_address = NULL;

	ULONG records = 0;
	while (true)
	{
		if (isc_receive(status_vector, &request, 0, length, buffer, 0))
		{
			BURP_error_redirect(status_vector, 29);
			// msg 29 isc_receive failed
		}
		if (!*eof)
			break;
		records++;
		// Verbose records
		if ((records % BACKUP_VERBOSE_INTERVAL) == 0)
			BURP_verbose(108, SafeArg() << records);

		put(tdgbl, (UCHAR) rec_data);
		put_numeric(att_data_length, record_length);
		const UCHAR* p;
		if (tdgbl->gbl_sw_transportable)
		{
			record_length = CAN_encode_decode(relation, &xdr_buffer, buffer, TRUE);
			put_numeric(att_xdr_length, record_length);
			p = xdr_buffer.lstr_address;
		}
		else
			p = buffer;
		put(tdgbl, att_data_data);
		if (tdgbl->gbl_sw_compress)
			compress(p, record_length);
		else if (record_length)
			put_block(tdgbl, p, record_length);

		// Look for any blobs to write

		for (field = relation->rel_fields; field; field = field->fld_next)
		{
			if (field->fld_type == blr_blob &&
				!(field->fld_flags & FLD_computed) && !(field->fld_flags & FLD_array))
			{
				put_blob(field, *(ISC_QUAD*) (buffer + field->fld_offset));
			}
		}

		// Look for any array to write
		// we got back the blob_id for the array from isc_receive in the second param.
		for (field = relation->rel_fields; field; field = field->fld_next)
		{
			if (field->fld_flags & FLD_array)
			{
				put_array(field, relation, (ISC_QUAD*) (buffer + field->fld_offset));
			}
		}
	}

	BURP_free(buffer);

	if (xdr_buffer.lstr_address)
		BURP_free(xdr_buffer.lstr_address);

	BURP_verbose(108, SafeArg() << records);
	// msg 108 %ld records written

	if (isc_release_request(status_vector, &request))
		BURP_error_redirect(status_vector, 30);
	// msg 30 isc_release_request failed
}


void put_index( burp_rel* relation)
{
   struct isc_530_struct {
          char  isc_531 [32];	/* RDB$FOREIGN_KEY */
          ISC_QUAD isc_532;	/* RDB$EXPRESSION_BLR */
          ISC_QUAD isc_533;	/* RDB$EXPRESSION_SOURCE */
          short isc_534;	/* isc_utility */
          short isc_535;	/* gds__null_flag */
          short isc_536;	/* gds__null_flag */
          short isc_537;	/* gds__null_flag */
   } isc_530;
   struct isc_528_struct {
          char  isc_529 [32];	/* RDB$INDEX_NAME */
   } isc_528;
   struct isc_541_struct {
          short isc_542;	/* isc_utility */
          short isc_543;	/* RDB$INDEX_TYPE */
   } isc_541;
   struct isc_539_struct {
          char  isc_540 [32];	/* RDB$INDEX_NAME */
   } isc_539;
   struct isc_547_struct {
          char  isc_548 [32];	/* RDB$FIELD_NAME */
          short isc_549;	/* isc_utility */
   } isc_547;
   struct isc_545_struct {
          char  isc_546 [32];	/* RDB$INDEX_NAME */
   } isc_545;
   struct isc_553_struct {
          short isc_554;	/* isc_utility */
          short isc_555;	/* RDB$INDEX_INACTIVE */
   } isc_553;
   struct isc_551_struct {
          char  isc_552 [32];	/* RDB$INDEX_NAME */
   } isc_551;
   struct isc_560_struct {
          short isc_561;	/* isc_utility */
   } isc_560;
   struct isc_557_struct {
          char  isc_558 [32];	/* RDB$RELATION_NAME */
          char  isc_559 [32];	/* RDB$FIELD_NAME */
   } isc_557;
   struct isc_565_struct {
          char  isc_566 [32];	/* RDB$FIELD_NAME */
          short isc_567;	/* isc_utility */
   } isc_565;
   struct isc_563_struct {
          char  isc_564 [32];	/* RDB$INDEX_NAME */
   } isc_563;
   struct isc_571_struct {
          ISC_QUAD isc_572;	/* RDB$DESCRIPTION */
          char  isc_573 [32];	/* RDB$INDEX_NAME */
          short isc_574;	/* isc_utility */
          short isc_575;	/* RDB$UNIQUE_FLAG */
          short isc_576;	/* RDB$SEGMENT_COUNT */
   } isc_571;
   struct isc_569_struct {
          char  isc_570 [32];	/* RDB$RELATION_NAME */
   } isc_569;
   struct isc_580_struct {
          char  isc_581 [32];	/* RDB$FIELD_NAME */
          short isc_582;	/* isc_utility */
   } isc_580;
   struct isc_578_struct {
          char  isc_579 [32];	/* RDB$INDEX_NAME */
   } isc_578;
   struct isc_587_struct {
          short isc_588;	/* isc_utility */
   } isc_587;
   struct isc_584_struct {
          char  isc_585 [32];	/* RDB$RELATION_NAME */
          char  isc_586 [32];	/* RDB$INDEX_NAME */
   } isc_584;
   struct isc_592_struct {
          char  isc_593 [32];	/* RDB$FOREIGN_KEY */
          ISC_QUAD isc_594;	/* RDB$EXPRESSION_BLR */
          ISC_QUAD isc_595;	/* RDB$EXPRESSION_SOURCE */
          ISC_QUAD isc_596;	/* RDB$DESCRIPTION */
          char  isc_597 [32];	/* RDB$INDEX_NAME */
          short isc_598;	/* isc_utility */
          short isc_599;	/* gds__null_flag */
          short isc_600;	/* gds__null_flag */
          short isc_601;	/* gds__null_flag */
          short isc_602;	/* RDB$INDEX_TYPE */
          short isc_603;	/* RDB$UNIQUE_FLAG */
          short isc_604;	/* RDB$INDEX_INACTIVE */
          short isc_605;	/* RDB$SEGMENT_COUNT */
   } isc_592;
   struct isc_590_struct {
          char  isc_591 [32];	/* RDB$RELATION_NAME */
   } isc_590;
/**************************************
 *
 *	p u t _ i n d e x
 *
 **************************************
 *
 * Functional description
 *	Write information about an index.  First
 *	check that all the segments of the
 *	index exist.
 *
 **************************************/
	ULONG count;
	TEXT temp[GDS_NAME_LEN];

	BurpGlobals* tdgbl = BurpGlobals::getSpecific();

	// if we have all capabilities, use the first request to get the
	// most performance out of the latest engine; if we don't
	// have one of the capabilities we must use the second set of
	// requests--this requires more code but it is well worth it
	// for the performance benefits, especially remotely--deej

	if ((tdgbl->BCK_capabilities & BCK_idx_inactive) &&
		(tdgbl->BCK_capabilities & BCK_attributes_v3) &&
		(tdgbl->BCK_capabilities & BCK_ods8))
	{
		/*FOR (REQUEST_HANDLE tdgbl->handles_put_index_req_handle1)
			X IN RDB$INDICES WITH
			X.RDB$RELATION_NAME EQ relation->rel_name*/
		{
                if (!tdgbl->handles_put_index_req_handle1)
                   isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &tdgbl->handles_put_index_req_handle1, (short) sizeof(isc_589), (char*) isc_589);
		isc_vtov ((const char*) relation->rel_name, (char*) isc_590.isc_591, 32);
		if (tdgbl->handles_put_index_req_handle1)
		   {
                   isc_start_and_send (isc_status, (FB_API_HANDLE*) &tdgbl->handles_put_index_req_handle1, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 32, &isc_590, (short) 0);
		   }
		if (!isc_status [1]) {
		while (1)
		   {
                   isc_receive (isc_status, (FB_API_HANDLE*) &tdgbl->handles_put_index_req_handle1, (short) 1, (short) 104, &isc_592, (short) 0);
		   if (!isc_592.isc_598 || isc_status [1]) break;

			count = 0;
			/*FOR (REQUEST_HANDLE tdgbl->handles_put_index_req_handle2)
				I_S IN RDB$INDEX_SEGMENTS CROSS
				RFR IN RDB$RELATION_FIELDS WITH
				I_S.RDB$FIELD_NAME = RFR.RDB$FIELD_NAME AND
				I_S.RDB$INDEX_NAME = X.RDB$INDEX_NAME AND
				RFR.RDB$RELATION_NAME = relation->rel_name*/
			{
                        if (!tdgbl->handles_put_index_req_handle2)
                           isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &tdgbl->handles_put_index_req_handle2, (short) sizeof(isc_583), (char*) isc_583);
			isc_vtov ((const char*) relation->rel_name, (char*) isc_584.isc_585, 32);
			isc_vtov ((const char*) isc_592.isc_597, (char*) isc_584.isc_586, 32);
			if (tdgbl->handles_put_index_req_handle2)
			   {
                           isc_start_and_send (isc_status, (FB_API_HANDLE*) &tdgbl->handles_put_index_req_handle2, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 64, &isc_584, (short) 0);
			   }
			if (!isc_status [1]) {
			while (1)
			   {
                           isc_receive (isc_status, (FB_API_HANDLE*) &tdgbl->handles_put_index_req_handle2, (short) 1, (short) 2, &isc_587, (short) 0);
			   if (!isc_587.isc_588 || isc_status [1]) break;

				count++;

			/*END_FOR;*/
			   }
			   };
			/*ON_ERROR*/
			if (isc_status [1])
			   {
				general_on_error();
			/*END_ERROR;*/
			   }
			}

			if (count != (ULONG) /*X.RDB$SEGMENT_COUNT*/
					     isc_592.isc_605)
			{
				BURP_print(true, 180, SafeArg() << /*X.RDB$INDEX_NAME*/
								   isc_592.isc_597 << count << /*X.RDB$SEGMENT_COUNT*/
	     isc_592.isc_605);
				continue;
			}

			put(tdgbl, rec_index);
			const ULONG l = PUT_TEXT (att_index_name, /*X.RDB$INDEX_NAME*/
								  isc_592.isc_597);
			MISC_terminate (/*X.RDB$INDEX_NAME*/
					isc_592.isc_597, temp, l, sizeof(temp));
			BURP_verbose (151, temp);
			// msg 151 writing index %s
			put_numeric (att_segment_count, /*X.RDB$SEGMENT_COUNT*/
							isc_592.isc_605);
			put_numeric (att_index_inactive, /*X.RDB$INDEX_INACTIVE*/
							 isc_592.isc_604);
			put_numeric (att_index_unique_flag, /*X.RDB$UNIQUE_FLAG*/
							    isc_592.isc_603);

			/*FOR (REQUEST_HANDLE tdgbl->handles_put_index_req_handle5)
				Y IN RDB$INDEX_SEGMENTS WITH
				Y.RDB$INDEX_NAME EQ X.RDB$INDEX_NAME
				SORTED BY Y.RDB$FIELD_POSITION*/
			{
                        if (!tdgbl->handles_put_index_req_handle5)
                           isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &tdgbl->handles_put_index_req_handle5, (short) sizeof(isc_577), (char*) isc_577);
			isc_vtov ((const char*) isc_592.isc_597, (char*) isc_578.isc_579, 32);
			if (tdgbl->handles_put_index_req_handle5)
			   {
                           isc_start_and_send (isc_status, (FB_API_HANDLE*) &tdgbl->handles_put_index_req_handle5, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 32, &isc_578, (short) 0);
			   }
			if (!isc_status [1]) {
			while (1)
			   {
                           isc_receive (isc_status, (FB_API_HANDLE*) &tdgbl->handles_put_index_req_handle5, (short) 1, (short) 34, &isc_580, (short) 0);
			   if (!isc_580.isc_582 || isc_status [1]) break;

				PUT_TEXT (att_index_field_name, /*Y.RDB$FIELD_NAME*/
								isc_580.isc_581);

			/*END_FOR;*/
			   }
			   };
			/*ON_ERROR*/
			if (isc_status [1])
			   {
				general_on_error();
			/*END_ERROR;*/
			   }
			}

			put_source_blob (att_index_description2, att_index_description, /*X.RDB$DESCRIPTION*/
											isc_592.isc_596);
			put_numeric (att_index_type, /*X.RDB$INDEX_TYPE*/
						     isc_592.isc_602);

			if (!/*X.RDB$EXPRESSION_SOURCE.NULL*/
			     isc_592.isc_601)
				put_source_blob (att_index_expression_source, att_index_expression_source,
								 /*X.RDB$EXPRESSION_SOURCE*/
								 isc_592.isc_595);
			if (!/*X.RDB$EXPRESSION_BLR.NULL*/
			     isc_592.isc_600)
				put_blr_blob (att_index_expression_blr, /*X.RDB$EXPRESSION_BLR*/
									isc_592.isc_594);
			if (!/*X.RDB$FOREIGN_KEY.NULL*/
			     isc_592.isc_599)
				PUT_TEXT (att_index_foreign_key, /*X.RDB$FOREIGN_KEY*/
								 isc_592.isc_593);
			put(tdgbl, att_end);

		/*END_FOR;*/
		   }
		   };
		/*ON_ERROR*/
		if (isc_status [1])
		   {
			general_on_error();
		/*END_ERROR;*/
		   }
		}
	}
	else
	{
		/*FOR (REQUEST_HANDLE tdgbl->handles_put_index_req_handle1)
			X IN RDB$INDICES WITH
			X.RDB$RELATION_NAME EQ relation->rel_name*/
		{
                if (!tdgbl->handles_put_index_req_handle1)
                   isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &tdgbl->handles_put_index_req_handle1, (short) sizeof(isc_568), (char*) isc_568);
		isc_vtov ((const char*) relation->rel_name, (char*) isc_569.isc_570, 32);
		if (tdgbl->handles_put_index_req_handle1)
		   {
                   isc_start_and_send (isc_status, (FB_API_HANDLE*) &tdgbl->handles_put_index_req_handle1, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 32, &isc_569, (short) 0);
		   }
		if (!isc_status [1]) {
		while (1)
		   {
                   isc_receive (isc_status, (FB_API_HANDLE*) &tdgbl->handles_put_index_req_handle1, (short) 1, (short) 46, &isc_571, (short) 0);
		   if (!isc_571.isc_574 || isc_status [1]) break;

			count = 0;
			/*FOR (REQUEST_HANDLE tdgbl->handles_put_index_req_handle2)
				I_S IN RDB$INDEX_SEGMENTS WITH
				I_S.RDB$INDEX_NAME = X.RDB$INDEX_NAME*/
			{
                        if (!tdgbl->handles_put_index_req_handle2)
                           isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &tdgbl->handles_put_index_req_handle2, (short) sizeof(isc_562), (char*) isc_562);
			isc_vtov ((const char*) isc_571.isc_573, (char*) isc_563.isc_564, 32);
			if (tdgbl->handles_put_index_req_handle2)
			   {
                           isc_start_and_send (isc_status, (FB_API_HANDLE*) &tdgbl->handles_put_index_req_handle2, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 32, &isc_563, (short) 0);
			   }
			if (!isc_status [1]) {
			while (1)
			   {
                           isc_receive (isc_status, (FB_API_HANDLE*) &tdgbl->handles_put_index_req_handle2, (short) 1, (short) 34, &isc_565, (short) 0);
			   if (!isc_565.isc_567 || isc_status [1]) break;
				bool match = false;

				/*FOR (REQUEST_HANDLE tdgbl->handles_put_index_req_handle3)
					RFR IN RDB$RELATION_FIELDS WITH
					I_S.RDB$FIELD_NAME = RFR.RDB$FIELD_NAME AND
					RFR.RDB$RELATION_NAME = relation->rel_name*/
				{
                                if (!tdgbl->handles_put_index_req_handle3)
                                   isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &tdgbl->handles_put_index_req_handle3, (short) sizeof(isc_556), (char*) isc_556);
				isc_vtov ((const char*) relation->rel_name, (char*) isc_557.isc_558, 32);
				isc_vtov ((const char*) isc_565.isc_566, (char*) isc_557.isc_559, 32);
				if (tdgbl->handles_put_index_req_handle3)
				   {
                                   isc_start_and_send (isc_status, (FB_API_HANDLE*) &tdgbl->handles_put_index_req_handle3, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 64, &isc_557, (short) 0);
				   }
				if (!isc_status [1]) {
				while (1)
				   {
                                   isc_receive (isc_status, (FB_API_HANDLE*) &tdgbl->handles_put_index_req_handle3, (short) 1, (short) 2, &isc_560, (short) 0);
				   if (!isc_560.isc_561 || isc_status [1]) break;
					match = true;
				/*END_FOR;*/
				   }
				   };
				/*ON_ERROR*/
				if (isc_status [1])
				   {
					general_on_error();
				/*END_ERROR;*/
				   }
				}
				if (!match)
					BURP_print (true, 179, SafeArg() << /*I_S.RDB$FIELD_NAME*/
									    isc_565.isc_566 << /*X.RDB$INDEX_NAME*/
    isc_571.isc_573);
				else
					count++;
			/*END_FOR;*/
			   }
			   };
			/*ON_ERROR*/
			if (isc_status [1])
			   {
				general_on_error();
			/*END_ERROR;*/
			   }
			}

			if (count != (ULONG) /*X.RDB$SEGMENT_COUNT*/
					     isc_571.isc_576)
			{
				BURP_print(true, 180, SafeArg() << /*X.RDB$INDEX_NAME*/
								   isc_571.isc_573 << count << /*X.RDB$SEGMENT_COUNT*/
	     isc_571.isc_576);
				continue;
			}

			put(tdgbl, rec_index);
			const ULONG l = PUT_TEXT (att_index_name, /*X.RDB$INDEX_NAME*/
								  isc_571.isc_573);
			MISC_terminate (/*X.RDB$INDEX_NAME*/
					isc_571.isc_573, temp, l, sizeof(temp));
			BURP_verbose (151, temp);
			// msg 151 writing index %s
			put_numeric (att_segment_count, /*X.RDB$SEGMENT_COUNT*/
							isc_571.isc_576);
			if (tdgbl->BCK_capabilities & BCK_idx_inactive)
				/*FOR (REQUEST_HANDLE tdgbl->handles_put_index_req_handle4)
					I IN RDB$INDICES WITH I.RDB$INDEX_NAME = X.RDB$INDEX_NAME*/
				{
                                if (!tdgbl->handles_put_index_req_handle4)
                                   isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &tdgbl->handles_put_index_req_handle4, (short) sizeof(isc_550), (char*) isc_550);
				isc_vtov ((const char*) isc_571.isc_573, (char*) isc_551.isc_552, 32);
				if (tdgbl->handles_put_index_req_handle4)
				   {
                                   isc_start_and_send (isc_status, (FB_API_HANDLE*) &tdgbl->handles_put_index_req_handle4, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 32, &isc_551, (short) 0);
				   }
				if (!isc_status [1]) {
				while (1)
				   {
                                   isc_receive (isc_status, (FB_API_HANDLE*) &tdgbl->handles_put_index_req_handle4, (short) 1, (short) 4, &isc_553, (short) 0);
				   if (!isc_553.isc_554 || isc_status [1]) break;
					put_numeric (att_index_inactive, /*I.RDB$INDEX_INACTIVE*/
									 isc_553.isc_555);
				/*END_FOR;*/
				   }
				   };
				/*ON_ERROR*/
				if (isc_status [1])
				   {
					general_on_error();
				/*END_ERROR;*/
				   }
				}
			put_numeric (att_index_unique_flag, /*X.RDB$UNIQUE_FLAG*/
							    isc_571.isc_575);
			/*FOR (REQUEST_HANDLE tdgbl->handles_put_index_req_handle5)
				Y IN RDB$INDEX_SEGMENTS WITH Y.RDB$INDEX_NAME EQ X.RDB$INDEX_NAME
				SORTED BY Y.RDB$FIELD_POSITION*/
			{
                        if (!tdgbl->handles_put_index_req_handle5)
                           isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &tdgbl->handles_put_index_req_handle5, (short) sizeof(isc_544), (char*) isc_544);
			isc_vtov ((const char*) isc_571.isc_573, (char*) isc_545.isc_546, 32);
			if (tdgbl->handles_put_index_req_handle5)
			   {
                           isc_start_and_send (isc_status, (FB_API_HANDLE*) &tdgbl->handles_put_index_req_handle5, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 32, &isc_545, (short) 0);
			   }
			if (!isc_status [1]) {
			while (1)
			   {
                           isc_receive (isc_status, (FB_API_HANDLE*) &tdgbl->handles_put_index_req_handle5, (short) 1, (short) 34, &isc_547, (short) 0);
			   if (!isc_547.isc_549 || isc_status [1]) break;
				PUT_TEXT (att_index_field_name, /*Y.RDB$FIELD_NAME*/
								isc_547.isc_548);
			/*END_FOR;*/
			   }
			   };
			/*ON_ERROR*/
			if (isc_status [1])
			   {
				general_on_error();
			/*END_ERROR;*/
			   }
			}
			put_source_blob (att_index_description2, att_index_description, /*X.RDB$DESCRIPTION*/
											isc_571.isc_572);
			if (tdgbl->BCK_capabilities & BCK_attributes_v3)
				/*FOR (REQUEST_HANDLE tdgbl->handles_put_index_req_handle6)
					I IN RDB$INDICES WITH I.RDB$INDEX_NAME = X.RDB$INDEX_NAME*/
				{
                                if (!tdgbl->handles_put_index_req_handle6)
                                   isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &tdgbl->handles_put_index_req_handle6, (short) sizeof(isc_538), (char*) isc_538);
				isc_vtov ((const char*) isc_571.isc_573, (char*) isc_539.isc_540, 32);
				if (tdgbl->handles_put_index_req_handle6)
				   {
                                   isc_start_and_send (isc_status, (FB_API_HANDLE*) &tdgbl->handles_put_index_req_handle6, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 32, &isc_539, (short) 0);
				   }
				if (!isc_status [1]) {
				while (1)
				   {
                                   isc_receive (isc_status, (FB_API_HANDLE*) &tdgbl->handles_put_index_req_handle6, (short) 1, (short) 4, &isc_541, (short) 0);
				   if (!isc_541.isc_542 || isc_status [1]) break;
					put_numeric (att_index_type, /*I.RDB$INDEX_TYPE*/
								     isc_541.isc_543);
				/*END_FOR;*/
				   }
				   };
				/*ON_ERROR*/
				if (isc_status [1])
				   {
					general_on_error();
				/*END_ERROR;*/
				   }
				}
			if (tdgbl->BCK_capabilities & BCK_ods8)
				/*FOR (REQUEST_HANDLE tdgbl->handles_put_index_req_handle7)
					I IN RDB$INDICES WITH I.RDB$INDEX_NAME = X.RDB$INDEX_NAME*/
				{
                                if (!tdgbl->handles_put_index_req_handle7)
                                   isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &tdgbl->handles_put_index_req_handle7, (short) sizeof(isc_527), (char*) isc_527);
				isc_vtov ((const char*) isc_571.isc_573, (char*) isc_528.isc_529, 32);
				if (tdgbl->handles_put_index_req_handle7)
				   {
                                   isc_start_and_send (isc_status, (FB_API_HANDLE*) &tdgbl->handles_put_index_req_handle7, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 32, &isc_528, (short) 0);
				   }
				if (!isc_status [1]) {
				while (1)
				   {
                                   isc_receive (isc_status, (FB_API_HANDLE*) &tdgbl->handles_put_index_req_handle7, (short) 1, (short) 56, &isc_530, (short) 0);
				   if (!isc_530.isc_534 || isc_status [1]) break;
					if (!/*I.RDB$EXPRESSION_SOURCE.NULL*/
					     isc_530.isc_537)
						put_source_blob (att_index_expression_source, att_index_expression_source,
										 /*I.RDB$EXPRESSION_SOURCE*/
										 isc_530.isc_533);
					if (!/*I.RDB$EXPRESSION_BLR.NULL*/
					     isc_530.isc_536)
						put_blr_blob (att_index_expression_blr, /*I.RDB$EXPRESSION_BLR*/
											isc_530.isc_532);
					if (!/*I.RDB$FOREIGN_KEY.NULL*/
					     isc_530.isc_535)
						PUT_TEXT (att_index_foreign_key, /*I.RDB$FOREIGN_KEY*/
										 isc_530.isc_531);
				/*END_FOR;*/
				   }
				   };
				/*ON_ERROR*/
				if (isc_status [1])
				   {
					general_on_error();
				/*END_ERROR;*/
				   }
				}
			put(tdgbl, att_end);

		/*END_FOR;*/
		   }
		   };
		/*ON_ERROR*/
		if (isc_status [1])
		   {
			general_on_error();
		/*END_ERROR;*/
		   }
		}
	}
}


int put_message( att_type attribute, att_type attribute2, const TEXT* text, const ULONG length)
{
/**************************************
 *
 *	p u t _ m e s s a g e
 *
 **************************************
 *
 * Functional description
 *	Write a variable length text string, with embedded
 *      blanks.  Same as put_text but handles embedded blanks.
 * CVC: As v6 time, put_text handles embedded blanks, too!
 * The only difference is that put_text's length is SSHORT, so
 * in theory put_message can handle much longer input and it's
 * used for exception and trigger's messages (plus update/delete
 * rules for FKs and constraint types, where it's irrelevant
 * which function of the two you use).
 * CVC: Responsability for FKs and constraint types transferred to put_text.
 * This functions tries to maintain backwards compatibility where possible.
 *
 **************************************/
	BurpGlobals* tdgbl = BurpGlobals::getSpecific();

	ULONG l = 0;
	for (const TEXT* p = text; *p && l < length; p++)
		l++;

	const ULONG newlen = MIN(l, length);
	fb_assert(newlen <= MAX_USHORT);

	// If we can store the message using the old format, we do it.
	if (newlen <= MAX_UCHAR)
	{
		put(tdgbl, attribute);
		put(tdgbl, (UCHAR) newlen);
	}
	else if (newlen <= MAX_USHORT)
	{
		if (!attribute2) // In theory, this never happens, because the caller knows what it's doing.
			BURP_error(314, "");
		put(tdgbl, attribute2);
		USHORT vax_value = (USHORT) newlen;
		vax_value = (USHORT) gds__vax_integer((const UCHAR*) &vax_value, sizeof(vax_value));
		put_block(tdgbl, (const UCHAR*) &vax_value, sizeof(vax_value));
	}
	else
		BURP_error(315, "");

	if (newlen)
		put_block(tdgbl, reinterpret_cast<const UCHAR*>(text), newlen);

	return newlen;
}


void put_numeric( att_type attribute, SLONG value)
{
/**************************************
 *
 *	p u t _ n u m e r i c
 *
 **************************************
 *
 * Functional description
 *	Write a numeric value as an attribute.  The number is represented
 *	low byte first, high byte last, as in VAX.
 *
 **************************************/
	BurpGlobals* tdgbl = BurpGlobals::getSpecific();

	const SLONG vax_value = (SLONG) isc_vax_integer((const char*) &value, sizeof(value));

	put(tdgbl, attribute);
	put(tdgbl, (UCHAR) sizeof(value));
	put_block(tdgbl, (const UCHAR*) &vax_value, sizeof(vax_value));
}


void put_int64( att_type attribute, SINT64 value)
{
/**************************************
 *
 *	p u t _ i n t 6 4
 *
 **************************************
 *
 * Functional description
 *	Write a 64-bit numeric value as an attribute.
 *      The number is represented low byte first, high byte last, as in VAX.
 *      This function is just like put_numeric, except that it handles an
 *      INT64 value, while put_numeric handles a 32-bit value.
 *
 **************************************/
	BurpGlobals* tdgbl = BurpGlobals::getSpecific();

	const FB_UINT64 le_value = (FB_UINT64) isc_portable_integer((const UCHAR*) &value, sizeof(value));

	put(tdgbl, attribute);
	put(tdgbl, (UCHAR) sizeof(value));
	put_block(tdgbl, (const UCHAR*) &le_value, sizeof(le_value));
}


void put_relation( burp_rel* relation)
{
   struct isc_515_struct {
          char  isc_516 [32];	/* RDB$RELATION_NAME */
          short isc_517;	/* isc_utility */
          short isc_518;	/* RDB$VIEW_CONTEXT */
   } isc_515;
   struct isc_513_struct {
          char  isc_514 [32];	/* RDB$VIEW_NAME */
   } isc_513;
   struct isc_522_struct {
          char  isc_523 [256];	/* RDB$CONTEXT_NAME */
          char  isc_524 [32];	/* RDB$RELATION_NAME */
          short isc_525;	/* isc_utility */
          short isc_526;	/* RDB$VIEW_CONTEXT */
   } isc_522;
   struct isc_520_struct {
          char  isc_521 [32];	/* RDB$VIEW_NAME */
   } isc_520;
/**************************************
 *
 * 	p u t _ r e l a t i o n
 *
 **************************************
 *
 * Functional description
 *	Write relation meta-data and data.
 *
 **************************************/
	TEXT temp[GDS_NAME_LEN];

	BurpGlobals* tdgbl = BurpGlobals::getSpecific();

	// Write local field information.  This is made slightly more complicated
	// by the requirement that computational fields be aligned.

	burp_fld* aligned = NULL;
	burp_fld* unaligned = NULL;
	burp_fld* aligned4 = NULL;
	burp_fld* aligned8 = NULL;

	burp_fld* fields = get_fields(relation);

	// sort the list of fields into three lists, depending on alignment
	burp_fld* field;
	for (field = fields; field = fields;)
	{
		fields = field->fld_next;
		USHORT l = field->fld_length;
		if (field->fld_type == blr_varying)
			l += sizeof(USHORT);
		if (!(l & 7))
		{
			field->fld_next = aligned8;
			aligned8 = field;
		}
		else if (!(l & 3))
		{
			field->fld_next = aligned4;
			aligned4 = field;
		}
		else if (l & 1)
		{
			field->fld_next = unaligned;
			unaligned = field;
		}
		else
		{
			field->fld_next = aligned;
			aligned = field;
		}
	}

	// Next, merge the aligned and unaligned sub-lists.  In the process,
	// re-create (approximately) the original order of the fields.  This is
	// not strictly required, but it certainly is polite.

	while (field = unaligned)
	{
		unaligned = field->fld_next;
		field->fld_next = relation->rel_fields;
		relation->rel_fields = field;
	}

	while (field = aligned)
	{
		aligned = field->fld_next;
		field->fld_next = relation->rel_fields;
		relation->rel_fields = field;
	}

	while (field = aligned4)
	{
		aligned4 = field->fld_next;
		field->fld_next = relation->rel_fields;
		relation->rel_fields = field;
	}

	while (field = aligned8)
	{
		aligned8 = field->fld_next;
		field->fld_next = relation->rel_fields;
		relation->rel_fields = field;
	}

	// Now write the fields in what will become physical backup order

	for (field = relation->rel_fields; field; field = field->fld_next)
	{
		put(tdgbl, (UCHAR) rec_field);
		const USHORT l = PUT_TEXT(att_field_name, field->fld_name);
		MISC_terminate(field->fld_name, temp, l, sizeof(temp));
		BURP_verbose(144, temp);
		// msg 144  writing field %s
		PUT_TEXT(att_field_source, field->fld_source);
		if (field->fld_query_name[0])
			PUT_TEXT(att_field_query_name, field->fld_query_name);
		if (field->fld_complex_name[0])
			PUT_TEXT(att_field_complex_name, field->fld_complex_name);
		if (field->fld_edit_string[0])
			PUT_TEXT(att_field_edit_string, field->fld_edit_string);
		put_source_blob(att_field_description2, att_field_description, field->fld_description);
		put_source_blob(att_field_query_header, att_field_query_header, field->fld_query_header);
		if (field->fld_security_class[0])
			PUT_TEXT(att_field_security_class, field->fld_security_class);
		if (!(field->fld_flags & FLD_position_missing))
			put_numeric(att_field_position, field->fld_position);
		put_numeric(att_field_type, field->fld_type);
		put_numeric(att_field_length, field->fld_length);
		put_numeric(att_field_sub_type, field->fld_sub_type);
		put_numeric(att_field_scale, field->fld_scale);
		put_numeric(att_field_number, field->fld_number);
		put_numeric(att_field_system_flag, field->fld_system_flag);
		if (!(field->fld_flags & FLD_update_missing))
			put_numeric(att_field_update_flag, field->fld_update_flag);
		if (field->fld_flags & FLD_null_flag)
			put_numeric(att_field_null_flag, field->fld_null_flag);
		if (field->fld_flags & FLD_charset_flag)
			put_numeric(att_field_character_set, field->fld_character_set_id);
		if (field->fld_flags & FLD_collate_flag)
			put_numeric(att_field_collation_id, field->fld_collation_id);
		put_blr_blob(att_field_default_value, field->fld_default_value);
		put_source_blob(att_field_default_source, att_field_default_source, field->fld_default_source);
		if (relation->rel_flags & REL_view)
		{
			put_numeric(att_view_context, field->fld_view_context);
			if (field->fld_base[0])
				PUT_TEXT(att_base_field, field->fld_base);
		}
		if (field->fld_flags & FLD_computed)
			put_numeric(att_field_computed_flag, TRUE);
		if (field->fld_flags & FLD_array)
		{
			put_numeric(att_field_dimensions, field->fld_dimensions);
			const SLONG* rp = field->fld_ranges;
			for (USHORT n = field->fld_dimensions; n; rp += 2, n--)
			{
				put_numeric(att_field_range_low, *rp);
				put_numeric(att_field_range_high, *(rp + 1));
			}
		}
		put(tdgbl, att_end);
	}

	// Write out view relations (if a view, of course)

	if (relation->rel_flags & REL_view)
	{
		if (tdgbl->BCK_capabilities & BCK_context_name)
		{
			/*FOR (REQUEST_HANDLE tdgbl->handles_put_relation_req_handle1)
				X IN RDB$VIEW_RELATIONS WITH X.RDB$VIEW_NAME EQ relation->rel_name*/
			{
                        if (!tdgbl->handles_put_relation_req_handle1)
                           isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &tdgbl->handles_put_relation_req_handle1, (short) sizeof(isc_519), (char*) isc_519);
			isc_vtov ((const char*) relation->rel_name, (char*) isc_520.isc_521, 32);
			if (tdgbl->handles_put_relation_req_handle1)
			   {
                           isc_start_and_send (isc_status, (FB_API_HANDLE*) &tdgbl->handles_put_relation_req_handle1, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 32, &isc_520, (short) 0);
			   }
			if (!isc_status [1]) {
			while (1)
			   {
                           isc_receive (isc_status, (FB_API_HANDLE*) &tdgbl->handles_put_relation_req_handle1, (short) 1, (short) 292, &isc_522, (short) 0);
			   if (!isc_522.isc_525 || isc_status [1]) break;
				put(tdgbl, rec_view);
				PUT_TEXT (att_view_relation_name, /*X.RDB$RELATION_NAME*/
								  isc_522.isc_524);
				put_numeric (att_view_context_id, /*X.RDB$VIEW_CONTEXT*/
								  isc_522.isc_526);
				PUT_TEXT (att_view_context_name, /*X.RDB$CONTEXT_NAME*/
								 isc_522.isc_523);
				put(tdgbl, att_end);
			/*END_FOR*/
			   }
			   };
			/*ON_ERROR*/
			if (isc_status [1])
			   {
				general_on_error();
			/*END_ERROR;*/
			   }
			}
		}
		else
		{
			/*FOR (REQUEST_HANDLE tdgbl->handles_put_relation_req_handle2)
				X IN RDB$VIEW_RELATIONS WITH X.RDB$VIEW_NAME EQ relation->rel_name*/
			{
                        if (!tdgbl->handles_put_relation_req_handle2)
                           isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &tdgbl->handles_put_relation_req_handle2, (short) sizeof(isc_512), (char*) isc_512);
			isc_vtov ((const char*) relation->rel_name, (char*) isc_513.isc_514, 32);
			if (tdgbl->handles_put_relation_req_handle2)
			   {
                           isc_start_and_send (isc_status, (FB_API_HANDLE*) &tdgbl->handles_put_relation_req_handle2, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 32, &isc_513, (short) 0);
			   }
			if (!isc_status [1]) {
			while (1)
			   {
                           isc_receive (isc_status, (FB_API_HANDLE*) &tdgbl->handles_put_relation_req_handle2, (short) 1, (short) 36, &isc_515, (short) 0);
			   if (!isc_515.isc_517 || isc_status [1]) break;
				put(tdgbl, rec_view);
				PUT_TEXT (att_view_relation_name, /*X.RDB$RELATION_NAME*/
								  isc_515.isc_516);
				put_numeric (att_view_context_id, /*X.RDB$VIEW_CONTEXT*/
								  isc_515.isc_518);
				put(tdgbl, att_end);
			/*END_FOR;*/
			   }
			   };
			/*ON_ERROR*/
			if (isc_status [1])
			   {
				general_on_error();
			/*END_ERROR;*/
			   }
			}
		}
	}
	put(tdgbl, (UCHAR) rec_relation_end);
}


bool put_source_blob(att_type attribute, att_type old_attribute, ISC_QUAD& blob_id)
{
/**************************************
 *
 *	p u t _ s o u r c e _ b l o b
 *
 **************************************
 *
 * Functional description
 *	Write out a source blob or query header if present.
 *	Return true is there was the blob was present, false otherwise.
 *	Include the NULL character to separate each segment.
 *
 **************************************/
	ISC_STATUS_ARRAY status_vector;
	BurpGlobals* tdgbl = BurpGlobals::getSpecific();

	// If the blob is null, don't store it.  It will be restored as null.

	if (UserBlob::blobIsNull(blob_id))
		return false;

	if (tdgbl->gbl_sw_old_descriptions && attribute != att_field_query_header)
		return put_blr_blob(old_attribute, blob_id);

	// Open the blob and get it's vital statistics

	UserBlob blob(status_vector);

	if (!blob.open(DB, gds_trans, blob_id))
	{
		BURP_error_redirect(status_vector, 24);
		// msg 24 isc_open_blob failed
	}

	UCHAR blob_info[48];
	if (!blob.getInfo(sizeof(source_items), source_items, sizeof(blob_info), blob_info))
	{
		BURP_error_redirect(status_vector, 20);
		// msg 20 isc_blob_info failed
	}

	ULONG length = 0;
	ULONG num_seg = 0;
	USHORT max_segment = 0;
	const UCHAR* p = blob_info;
	UCHAR item;

	while ((item = *p++) != isc_info_end)
	{
		const USHORT l = gds__vax_integer(p, 2);
		p += 2;
		const ULONG n = gds__vax_integer(p, l);
		p += l;
		switch (item)
		{
		case isc_info_blob_max_segment:
			max_segment = n;
			break;

		case isc_info_blob_total_length:
			length = n;
			break;

		case isc_info_blob_num_segments:
			num_seg = n;
			break;

		default:
			BURP_print(true, 79, SafeArg() << int(item));
			// msg 79 don't understand blob info item %ld
			if (!blob.close())
			{
				BURP_error_redirect(status_vector, 23);
				// msg 23 isc_close_blob failed
			}
			return false;
		}
	}

	if (!length)
	{
		if (!blob.close())
		{
			BURP_error_redirect(status_vector, 23);
			// msg 23 isc_close_blob failed
		}
		return false;
	}

	// Rdb sometimes gets the length messed up

	if (length < max_segment)
		length = max_segment;

	fb_assert(FB_UINT64(length) + num_seg <= FB_UINT64(MAX_ULONG));
	put_numeric(attribute, length + num_seg);

	// Allocate a buffer large enough for the largest segment and start grinding.

	UCHAR static_buffer[1024];
	UCHAR* buffer;
	if (!max_segment || max_segment <= sizeof(static_buffer))
		buffer = static_buffer;
	else
		buffer = BURP_alloc(max_segment);

	// The old code didn't accept isc_segment so we check it.
	size_t segment_length;
	while (blob.getSegment(max_segment, buffer, segment_length) && !blob.getCode())
	{
		if (segment_length)
		{
			put_block(tdgbl, buffer, segment_length);
		}
		put(tdgbl, (UCHAR) 0);
	}

	if (!blob.close())
		BURP_error_redirect(status_vector, 23);
	// msg 23 isc_close_blob failed

	if (buffer != static_buffer)
		BURP_free(buffer);

	return true;
}


int put_text( att_type attribute, const TEXT* text, SSHORT size_len)
{
/**************************************
 *
 *	p u t _ t e x t
 *
 **************************************
 *
 * Functional description
 * Write a variable length text string, with embedded spaces.
 * Truncate trailing spaces.
 * Now this routine does not truncate trailing spaces, 3-2002 MOD
 * transfering changes from fb1, I believe this is to do with problems
 * with quoted names and embedded spaces.
 * CVC: This routine does trailing spaces truncation, but correctly.
 *
 **************************************/
	BurpGlobals* tdgbl = BurpGlobals::getSpecific();

	const SSHORT l = (SSHORT) MISC_symbol_length(text, (ULONG) size_len);
	fb_assert(l <= MAX_UCHAR);

	put(tdgbl, attribute);
	put(tdgbl, (UCHAR) l);
	if (l)
		put_block(tdgbl, (const UCHAR*) text, l);

	return l;
}


void set_capabilities()
{
   struct isc_510_struct {
          short isc_511;	/* isc_utility */
   } isc_510;
   struct isc_507_struct {
          char  isc_508 [32];	/* RDB$FIELD_NAME */
          char  isc_509 [32];	/* RDB$RELATION_NAME */
   } isc_507;
/**************************************
 *
 *	s e t _ c a p a b i l i t i e s
 *
 **************************************
 *
 * Functional description
 *
 *	set the capabilities bits for the
 *	database being extracted to avoid
 *	unpleasantness later.
 *
 **************************************/
	BurpGlobals* tdgbl = BurpGlobals::getSpecific();

	FB_API_HANDLE req = 0;

	// Look for desireable fields in system relations

	for (const rfr_tab_t* rel_field_table = rfr_table; rel_field_table->relation; rel_field_table++)
	{
		const TEXT* field = rel_field_table->field;
		const TEXT* relation = rel_field_table->relation;
		/*FOR (REQUEST_HANDLE req) x IN RDB$RELATION_FIELDS
			WITH x.RDB$RELATION_NAME = relation
			AND x.RDB$FIELD_NAME = field*/
		{
                if (!req)
                   isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &req, (short) sizeof(isc_506), (char*) isc_506);
		isc_vtov ((const char*) field, (char*) isc_507.isc_508, 32);
		isc_vtov ((const char*) relation, (char*) isc_507.isc_509, 32);
		if (req)
		   {
                   isc_start_and_send (isc_status, (FB_API_HANDLE*) &req, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 64, &isc_507, (short) 0);
		   }
		if (!isc_status [1]) {
		while (1)
		   {
                   isc_receive (isc_status, (FB_API_HANDLE*) &req, (short) 1, (short) 2, &isc_510, (short) 0);
		   if (!isc_510.isc_511 || isc_status [1]) break;
			tdgbl->BCK_capabilities |= rel_field_table->bit_mask;
		/*END_FOR;*/
		   }
		   };
		/*ON_ERROR*/
		if (isc_status [1])
		   {
			general_on_error();
		/*END_ERROR;*/
		   }
		}
	}

	isc_release_request(isc_status, &req);
}


void write_character_sets()
{
   struct isc_490_struct {
          char  isc_491 [32];	/* RDB$DEFAULT_COLLATE_NAME */
          char  isc_492 [32];	/* RDB$FUNCTION_NAME */
          ISC_QUAD isc_493;	/* RDB$DESCRIPTION */
          char  isc_494 [32];	/* RDB$FORM_OF_USE */
          char  isc_495 [32];	/* RDB$CHARACTER_SET_NAME */
          ISC_LONG isc_496;	/* RDB$NUMBER_OF_CHARACTERS */
          short isc_497;	/* isc_utility */
          short isc_498;	/* RDB$BYTES_PER_CHARACTER */
          short isc_499;	/* gds__null_flag */
          short isc_500;	/* gds__null_flag */
          short isc_501;	/* RDB$CHARACTER_SET_ID */
          short isc_502;	/* gds__null_flag */
          short isc_503;	/* gds__null_flag */
          short isc_504;	/* gds__null_flag */
          short isc_505;	/* RDB$SYSTEM_FLAG */
   } isc_490;
/**************************************
 *
 *	w r i t e _ c h a r a c t e r _ s e t s
 *
 **************************************
 *
 * Functional description
 * 	write a record in the burp file for
 *	each user defined character set.
 *
 **************************************/
	isc_req_handle req_handle1 = 0;

	BurpGlobals* tdgbl = BurpGlobals::getSpecific();

	/*FOR (REQUEST_HANDLE req_handle1)
		X IN RDB$CHARACTER_SETS
		WITH X.RDB$SYSTEM_FLAG MISSING OR X.RDB$SYSTEM_FLAG NE 1 OR
			 X.RDB$DEFAULT_COLLATE_NAME NE X.RDB$CHARACTER_SET_NAME*/
	{
        if (!req_handle1)
           isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &req_handle1, (short) sizeof(isc_489), (char*) isc_489);
	if (req_handle1)
	   {
           isc_start_request (isc_status, (FB_API_HANDLE*) &req_handle1, (FB_API_HANDLE*) &gds_trans, (short) 0);
	   }
	if (!isc_status [1]) {
	while (1)
	   {
           isc_receive (isc_status, (FB_API_HANDLE*) &req_handle1, (short) 0, (short) 158, &isc_490, (short) 0);
	   if (!isc_490.isc_497 || isc_status [1]) break;

		put(tdgbl, rec_charset);
		PUT_TEXT (att_charset_name, /*X.RDB$CHARACTER_SET_NAME*/
					    isc_490.isc_495);

		if (/*X.RDB$SYSTEM_FLAG.NULL*/
		    isc_490.isc_504 || /*X.RDB$SYSTEM_FLAG*/
    isc_490.isc_505 != 1)
		{
			if (!/*X.RDB$FORM_OF_USE.NULL*/
			     isc_490.isc_503)
				PUT_TEXT (att_charset_form, /*X.RDB$FORM_OF_USE*/
							    isc_490.isc_494);
			if (!/*X.RDB$NUMBER_OF_CHARACTERS.NULL*/
			     isc_490.isc_502)
				put_numeric (att_charset_numchar, /*X.RDB$NUMBER_OF_CHARACTERS*/
								  isc_490.isc_496);
			put_numeric (att_charset_id, /*X.RDB$CHARACTER_SET_ID*/
						     isc_490.isc_501);
			if (/*X.RDB$SYSTEM_FLAG*/
			    isc_490.isc_505)
				put_numeric (att_charset_sysflag, /*X.RDB$SYSTEM_FLAG*/
								  isc_490.isc_505);
			if (!/*X.RDB$DESCRIPTION.NULL*/
			     isc_490.isc_500)
			{
				put_source_blob (att_charset_description, att_charset_description, /*X.RDB$DESCRIPTION*/
												   isc_490.isc_493);
			}
			if (!/*X.RDB$FUNCTION_NAME.NULL*/
			     isc_490.isc_499)
				PUT_TEXT (att_charset_funct, /*X.RDB$FUNCTION_NAME*/
							     isc_490.isc_492);
			put_numeric (att_charset_bytes_char, /*X.RDB$BYTES_PER_CHARACTER*/
							     isc_490.isc_498);
		}

		PUT_TEXT (att_charset_coll, /*X.RDB$DEFAULT_COLLATE_NAME*/
					    isc_490.isc_491);
		put(tdgbl, att_end);
	/*END_FOR;*/
	   }
	   };
	/*ON_ERROR*/
	if (isc_status [1])
	   {
		general_on_error();
	/*END_ERROR;*/
	   }
	}

	MISC_release_request_silent(req_handle1);
}


void write_check_constraints()
{
   struct isc_484_struct {
          char  isc_485 [32];	/* RDB$TRIGGER_NAME */
          char  isc_486 [32];	/* RDB$CONSTRAINT_NAME */
          short isc_487;	/* isc_utility */
          short isc_488;	/* gds__null_flag */
   } isc_484;
/**************************************
 *
 *	w r i t e _ c h e c k _ c o n s t r a i n t s
 *
 **************************************
 *
 * Functional description
 * 	write a record in the burp file for
 *	each check constraint.
 *
 **************************************/
	isc_req_handle req_handle1 = 0;

	BurpGlobals* tdgbl = BurpGlobals::getSpecific();

	/*FOR (REQUEST_HANDLE req_handle1)
		X IN RDB$CHECK_CONSTRAINTS*/
	{
        if (!req_handle1)
           isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &req_handle1, (short) sizeof(isc_483), (char*) isc_483);
	if (req_handle1)
	   {
           isc_start_request (isc_status, (FB_API_HANDLE*) &req_handle1, (FB_API_HANDLE*) &gds_trans, (short) 0);
	   }
	if (!isc_status [1]) {
	while (1)
	   {
           isc_receive (isc_status, (FB_API_HANDLE*) &req_handle1, (short) 0, (short) 68, &isc_484, (short) 0);
	   if (!isc_484.isc_487 || isc_status [1]) break;
		put(tdgbl, rec_chk_constraint);

		PUT_TEXT (att_chk_constraint_name, /*X.RDB$CONSTRAINT_NAME*/
						   isc_484.isc_486);
		if (!/*X.RDB$TRIGGER_NAME.NULL*/
		     isc_484.isc_488)
			PUT_TEXT (att_chk_trigger_name, /*X.RDB$TRIGGER_NAME*/
							isc_484.isc_485);
		put(tdgbl, att_end);
	/*END_FOR;*/
	   }
	   };
	/*ON_ERROR*/
	if (isc_status [1])
	   {
		general_on_error();
	/*END_ERROR;*/
	   }
	}

	MISC_release_request_silent(req_handle1);
}


void write_collations()
{
   struct isc_456_struct {
          char  isc_457 [32];	/* RDB$FUNCTION_NAME */
          ISC_QUAD isc_458;	/* RDB$DESCRIPTION */
          char  isc_459 [32];	/* RDB$COLLATION_NAME */
          short isc_460;	/* isc_utility */
          short isc_461;	/* gds__null_flag */
          short isc_462;	/* gds__null_flag */
          short isc_463;	/* RDB$SYSTEM_FLAG */
          short isc_464;	/* RDB$COLLATION_ATTRIBUTES */
          short isc_465;	/* RDB$CHARACTER_SET_ID */
          short isc_466;	/* RDB$COLLATION_ID */
   } isc_456;
   struct isc_468_struct {
          ISC_QUAD isc_469;	/* RDB$SPECIFIC_ATTRIBUTES */
          char  isc_470 [32];	/* RDB$BASE_COLLATION_NAME */
          char  isc_471 [32];	/* RDB$FUNCTION_NAME */
          ISC_QUAD isc_472;	/* RDB$DESCRIPTION */
          char  isc_473 [32];	/* RDB$COLLATION_NAME */
          short isc_474;	/* isc_utility */
          short isc_475;	/* gds__null_flag */
          short isc_476;	/* gds__null_flag */
          short isc_477;	/* gds__null_flag */
          short isc_478;	/* gds__null_flag */
          short isc_479;	/* RDB$SYSTEM_FLAG */
          short isc_480;	/* RDB$COLLATION_ATTRIBUTES */
          short isc_481;	/* RDB$CHARACTER_SET_ID */
          short isc_482;	/* RDB$COLLATION_ID */
   } isc_468;
/**************************************
 *
 *	w r i t e _ c o l l a t i o n s
 *
 **************************************
 *
 * Functional description
 * 	write a record in the burp file for
 *	each user defined collation
 *
 **************************************/
	isc_req_handle req_handle1 = 0;

	BurpGlobals* tdgbl = BurpGlobals::getSpecific();

	if (tdgbl->BCK_capabilities & BCK_ods11)
	{
		/*FOR (REQUEST_HANDLE req_handle1)
			X IN RDB$COLLATIONS WITH X.RDB$SYSTEM_FLAG MISSING OR X.RDB$SYSTEM_FLAG NE 1*/
		{
                if (!req_handle1)
                   isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &req_handle1, (short) sizeof(isc_467), (char*) isc_467);
		if (req_handle1)
		   {
                   isc_start_request (isc_status, (FB_API_HANDLE*) &req_handle1, (FB_API_HANDLE*) &gds_trans, (short) 0);
		   }
		if (!isc_status [1]) {
		while (1)
		   {
                   isc_receive (isc_status, (FB_API_HANDLE*) &req_handle1, (short) 0, (short) 130, &isc_468, (short) 0);
		   if (!isc_468.isc_474 || isc_status [1]) break;
			put(tdgbl, rec_collation);
			PUT_TEXT (att_coll_name, /*X.RDB$COLLATION_NAME*/
						 isc_468.isc_473);
			put_numeric (att_coll_id, /*X.RDB$COLLATION_ID*/
						  isc_468.isc_482);
			put_numeric (att_coll_cs_id, /*X.RDB$CHARACTER_SET_ID*/
						     isc_468.isc_481);
			put_numeric (att_coll_attr, /*X.RDB$COLLATION_ATTRIBUTES*/
						    isc_468.isc_480);
			if (/*X.RDB$SYSTEM_FLAG*/
			    isc_468.isc_479)
				put_numeric (att_coll_sysflag, /*X.RDB$SYSTEM_FLAG*/
							       isc_468.isc_479);
			if (!/*X.RDB$DESCRIPTION.NULL*/
			     isc_468.isc_478)
				put_source_blob (att_coll_description, att_coll_description, /*X.RDB$DESCRIPTION*/
											     isc_468.isc_472);
			if (!/*X.RDB$FUNCTION_NAME.NULL*/
			     isc_468.isc_477)
				PUT_TEXT (att_coll_funct, /*X.RDB$FUNCTION_NAME*/
							  isc_468.isc_471);
			if (!/*X.RDB$BASE_COLLATION_NAME.NULL*/
			     isc_468.isc_476)
				PUT_TEXT(att_coll_base_collation_name, /*X.RDB$BASE_COLLATION_NAME*/
								       isc_468.isc_470);
			if (!/*X.RDB$SPECIFIC_ATTRIBUTES.NULL*/
			     isc_468.isc_475)
				put_source_blob (att_coll_specific_attr, att_coll_specific_attr, /*X.RDB$SPECIFIC_ATTRIBUTES*/
												 isc_468.isc_469);
			put(tdgbl, att_end);
		/*END_FOR;*/
		   }
		   };
		/*ON_ERROR*/
		if (isc_status [1])
		   {
			general_on_error();
		/*END_ERROR;*/
		   }
		}
	}
	else
	{
		/*FOR (REQUEST_HANDLE req_handle1)
			X IN RDB$COLLATIONS WITH X.RDB$SYSTEM_FLAG MISSING OR X.RDB$SYSTEM_FLAG NE 1*/
		{
                if (!req_handle1)
                   isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &req_handle1, (short) sizeof(isc_455), (char*) isc_455);
		if (req_handle1)
		   {
                   isc_start_request (isc_status, (FB_API_HANDLE*) &req_handle1, (FB_API_HANDLE*) &gds_trans, (short) 0);
		   }
		if (!isc_status [1]) {
		while (1)
		   {
                   isc_receive (isc_status, (FB_API_HANDLE*) &req_handle1, (short) 0, (short) 86, &isc_456, (short) 0);
		   if (!isc_456.isc_460 || isc_status [1]) break;
			put(tdgbl, rec_collation);
			PUT_TEXT (att_coll_name, /*X.RDB$COLLATION_NAME*/
						 isc_456.isc_459);
			put_numeric (att_coll_id, /*X.RDB$COLLATION_ID*/
						  isc_456.isc_466);
			put_numeric (att_coll_cs_id, /*X.RDB$CHARACTER_SET_ID*/
						     isc_456.isc_465);
			put_numeric (att_coll_attr, /*X.RDB$COLLATION_ATTRIBUTES*/
						    isc_456.isc_464);
			if (/*X.RDB$SYSTEM_FLAG*/
			    isc_456.isc_463)
				put_numeric (att_coll_sysflag, /*X.RDB$SYSTEM_FLAG*/
							       isc_456.isc_463);
			if (!/*X.RDB$DESCRIPTION.NULL*/
			     isc_456.isc_462)
				put_source_blob (att_coll_description, att_coll_description, /*X.RDB$DESCRIPTION*/
											     isc_456.isc_458);
			if (!/*X.RDB$FUNCTION_NAME.NULL*/
			     isc_456.isc_461)
				PUT_TEXT (att_coll_funct, /*X.RDB$FUNCTION_NAME*/
							  isc_456.isc_457);
			put(tdgbl, att_end);
		/*END_FOR;*/
		   }
		   };
		/*ON_ERROR*/
		if (isc_status [1])
		   {
			general_on_error();
		/*END_ERROR;*/
		   }
		}
	}

	MISC_release_request_silent(req_handle1);
}

void write_database( const TEXT* dbb_file)
{
   struct isc_434_struct {
          char  isc_435 [32];	/* RDB$CHARACTER_SET_NAME */
          short isc_436;	/* isc_utility */
          short isc_437;	/* gds__null_flag */
   } isc_434;
   struct isc_439_struct {
          ISC_QUAD isc_440;	/* RDB$DESCRIPTION */
          short isc_441;	/* isc_utility */
   } isc_439;
   struct isc_443_struct {
          char  isc_444 [32];	/* RDB$SECURITY_CLASS */
          short isc_445;	/* isc_utility */
          short isc_446;	/* gds__null_flag */
   } isc_443;
   struct isc_448_struct {
          char  isc_449 [32];	/* RDB$CHARACTER_SET_NAME */
          ISC_QUAD isc_450;	/* RDB$DESCRIPTION */
          char  isc_451 [32];	/* RDB$SECURITY_CLASS */
          short isc_452;	/* isc_utility */
          short isc_453;	/* gds__null_flag */
          short isc_454;	/* gds__null_flag */
   } isc_448;
/**************************************
 *
 *	w r i t e _ d a t a b a s e
 *
 **************************************
 *
 * Functional description
 * 	write a physical database record and a
 *	logical database record in the burp file for
 *	the database itself.
 *
 **************************************/
	ISC_STATUS_ARRAY status_vector;
	SCHAR buffer[256];
	isc_req_handle req_handle1 = 0, req_handle2 = 0, req_handle3 = 0;

	BurpGlobals* tdgbl = BurpGlobals::getSpecific();

	put(tdgbl, (UCHAR) rec_physical_db);

	if (isc_database_info(status_vector, &DB, sizeof(db_info_items), db_info_items,
						  sizeof(buffer), buffer))
	{
		BURP_error_redirect(status_vector, 31);
		// msg 31 isc_database_info failed
	}

	USHORT page_size = 0, forced_writes, no_reserve, SQL_dialect, db_read_only;
 	ULONG sweep_interval, page_buffers;
 	USHORT length = 0;
	for (const SCHAR* d = buffer; *d != isc_info_end; d += length)
	{
		const UCHAR item = *d++;
		length = (USHORT) isc_vax_integer(d, 2);
		d += 2;
		switch (item)
		{
		case isc_info_end:
			break;

		case isc_info_page_size:
			page_size = (USHORT) isc_vax_integer(d, length);
			put_numeric(att_page_size, page_size);
			break;

		case isc_info_sweep_interval:
			sweep_interval = isc_vax_integer(d, length);
			put_numeric(att_sweep_interval, sweep_interval);
			break;

		case isc_info_forced_writes:
			forced_writes = (USHORT) isc_vax_integer(d, length);
			put_numeric(att_forced_writes, forced_writes);
			break;

		case isc_info_no_reserve:
			if (no_reserve = (USHORT) isc_vax_integer(d, length))
				put_numeric(att_no_reserve, no_reserve);
			break;

		case isc_info_set_page_buffers:
			if (page_buffers = isc_vax_integer(d, length))
				put_numeric(att_page_buffers, page_buffers);
			break;

		case isc_info_error:	// old server does not understand new isc_info
			break;				// parameter and returns isc_info_error. skip it

		case isc_info_db_sql_dialect:
			SQL_dialect = (USHORT) isc_vax_integer(d, length);
			put_numeric(att_SQL_dialect, SQL_dialect);
			break;

		case isc_info_db_read_only:
			if (db_read_only = (USHORT) isc_vax_integer(d, length))
				put_numeric(att_db_read_only, db_read_only);
			break;

		default:
			BURP_error_redirect(status_vector, 31);
			// msg 31 isc_database_info failed
			break;
		}
	}

	put_asciz(att_file_name, dbb_file);

	BURP_verbose(77, SafeArg() << dbb_file << page_size);
	// msg 77 database %s has a page size of %ld bytes.

	put(tdgbl, att_end);

	put(tdgbl, (UCHAR) rec_database);

	// if we have all capabilities, use the first request to get the
	// most performance out of the latest engine; if we don't
	// have one of the capabilities we must use the second set of
	// requests--this requires more code but it is well worth it
	// for the performance benefits, especially remotely--deej

	if ((tdgbl->BCK_capabilities & BCK_security) &&
		(tdgbl->BCK_capabilities & BCK_db_description) &&
		(tdgbl->BCK_capabilities & BCK_ods8))
	{
		/*FOR (REQUEST_HANDLE req_handle1)
			D IN RDB$DATABASE*/
		{
                if (!req_handle1)
                   isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &req_handle1, (short) sizeof(isc_447), (char*) isc_447);
		if (req_handle1)
		   {
                   isc_start_request (isc_status, (FB_API_HANDLE*) &req_handle1, (FB_API_HANDLE*) &gds_trans, (short) 0);
		   }
		if (!isc_status [1]) {
		while (1)
		   {
                   isc_receive (isc_status, (FB_API_HANDLE*) &req_handle1, (short) 0, (short) 78, &isc_448, (short) 0);
		   if (!isc_448.isc_452 || isc_status [1]) break;

			if (!/*D.RDB$SECURITY_CLASS.NULL*/
			     isc_448.isc_454)
				PUT_TEXT (att_database_security_class, /*D.RDB$SECURITY_CLASS*/
								       isc_448.isc_451);
			put_source_blob (att_database_description2, att_database_description, /*D.RDB$DESCRIPTION*/
											      isc_448.isc_450);
			if (!/*D.RDB$CHARACTER_SET_NAME.NULL*/
			     isc_448.isc_453)
				PUT_TEXT (att_database_dfl_charset, /*D.RDB$CHARACTER_SET_NAME*/
								    isc_448.isc_449);
		/*END_FOR;*/
		   }
		   };
		/*ON_ERROR*/
		if (isc_status [1])
		   {
			general_on_error();
		/*END_ERROR;*/
		   }
		}
	}
	else
	{
		if (tdgbl->BCK_capabilities & BCK_security)
		{
			/*FOR (REQUEST_HANDLE req_handle1)
				D IN RDB$DATABASE*/
			{
                        if (!req_handle1)
                           isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &req_handle1, (short) sizeof(isc_442), (char*) isc_442);
			if (req_handle1)
			   {
                           isc_start_request (isc_status, (FB_API_HANDLE*) &req_handle1, (FB_API_HANDLE*) &gds_trans, (short) 0);
			   }
			if (!isc_status [1]) {
			while (1)
			   {
                           isc_receive (isc_status, (FB_API_HANDLE*) &req_handle1, (short) 0, (short) 36, &isc_443, (short) 0);
			   if (!isc_443.isc_445 || isc_status [1]) break;
				if (!/*D.RDB$SECURITY_CLASS.NULL*/
				     isc_443.isc_446)
					PUT_TEXT (att_database_security_class, /*D.RDB$SECURITY_CLASS*/
									       isc_443.isc_444);
			/*END_FOR;*/
			   }
			   };
			/*ON_ERROR*/
			if (isc_status [1])
			   {
				general_on_error();
			/*END_ERROR;*/
			   }
			}
		}

		if (tdgbl->BCK_capabilities & BCK_db_description)
		{
			/*FOR (REQUEST_HANDLE req_handle2)
				D IN RDB$DATABASE*/
			{
                        if (!req_handle2)
                           isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &req_handle2, (short) sizeof(isc_438), (char*) isc_438);
			if (req_handle2)
			   {
                           isc_start_request (isc_status, (FB_API_HANDLE*) &req_handle2, (FB_API_HANDLE*) &gds_trans, (short) 0);
			   }
			if (!isc_status [1]) {
			while (1)
			   {
                           isc_receive (isc_status, (FB_API_HANDLE*) &req_handle2, (short) 0, (short) 10, &isc_439, (short) 0);
			   if (!isc_439.isc_441 || isc_status [1]) break;
				put_source_blob (att_database_description2, att_database_description, /*D.RDB$DESCRIPTION*/
												      isc_439.isc_440);
			/*END_FOR;*/
			   }
			   };
			/*ON_ERROR*/
			if (isc_status [1])
			   {
				general_on_error();
			/*END_ERROR;*/
			   }
			}
		}

		if (tdgbl->BCK_capabilities & BCK_ods8)
		{
			/*FOR (REQUEST_HANDLE req_handle3)
				D IN RDB$DATABASE*/
			{
                        if (!req_handle3)
                           isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &req_handle3, (short) sizeof(isc_433), (char*) isc_433);
			if (req_handle3)
			   {
                           isc_start_request (isc_status, (FB_API_HANDLE*) &req_handle3, (FB_API_HANDLE*) &gds_trans, (short) 0);
			   }
			if (!isc_status [1]) {
			while (1)
			   {
                           isc_receive (isc_status, (FB_API_HANDLE*) &req_handle3, (short) 0, (short) 36, &isc_434, (short) 0);
			   if (!isc_434.isc_436 || isc_status [1]) break;
				if (!/*D.RDB$CHARACTER_SET_NAME.NULL*/
				     isc_434.isc_437)
					PUT_TEXT (att_database_dfl_charset, /*D.RDB$CHARACTER_SET_NAME*/
									    isc_434.isc_435);
			/*END_FOR;*/
			   }
			   };
			/*ON_ERROR*/
			if (isc_status [1])
			   {
				general_on_error();
			/*END_ERROR;*/
			   }
			}
		}
	}

	MISC_release_request_silent(req_handle1);
	MISC_release_request_silent(req_handle2);
	MISC_release_request_silent(req_handle3);

	put(tdgbl, att_end);
}


void write_exceptions()
{
   struct isc_428_struct {
          ISC_QUAD isc_429;	/* RDB$DESCRIPTION */
          char  isc_430 [1024];	/* RDB$MESSAGE */
          char  isc_431 [32];	/* RDB$EXCEPTION_NAME */
          short isc_432;	/* isc_utility */
   } isc_428;
/**************************************
 *
 *	w r i t e _ e x c e p t i o n s
 *
 **************************************
 *
 * Functional description
 * 	write a record in the burp file for
 *	each exception.
 *
 **************************************/
	TEXT temp[GDS_NAME_LEN];
	isc_req_handle req_handle1 = 0;

	BurpGlobals* tdgbl = BurpGlobals::getSpecific();

	/*FOR (REQUEST_HANDLE req_handle1)
		X IN RDB$EXCEPTIONS
		WITH X.RDB$SYSTEM_FLAG MISSING OR X.RDB$SYSTEM_FLAG NE 1*/
	{
        if (!req_handle1)
           isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &req_handle1, (short) sizeof(isc_427), (char*) isc_427);
	if (req_handle1)
	   {
           isc_start_request (isc_status, (FB_API_HANDLE*) &req_handle1, (FB_API_HANDLE*) &gds_trans, (short) 0);
	   }
	if (!isc_status [1]) {
	while (1)
	   {
           isc_receive (isc_status, (FB_API_HANDLE*) &req_handle1, (short) 0, (short) 1066, &isc_428, (short) 0);
	   if (!isc_428.isc_432 || isc_status [1]) break;
		put(tdgbl, rec_exception);
		const SSHORT l = PUT_TEXT (att_exception_name, /*X.RDB$EXCEPTION_NAME*/
							       isc_428.isc_431);
		MISC_terminate (/*X.RDB$EXCEPTION_NAME*/
				isc_428.isc_431, temp, l, sizeof(temp));
		BURP_verbose (198, temp);
		// msg 198 writing exception %s
		PUT_MESSAGE(att_exception_msg, att_exception_msg2, /*X.RDB$MESSAGE*/
								   isc_428.isc_430);
		put_source_blob (att_exception_description2, att_procedure_description, /*X.RDB$DESCRIPTION*/
											isc_428.isc_429);
		put(tdgbl, att_end);
	/*END_FOR;*/
	   }
	   };
	/*ON_ERROR*/
	if (isc_status [1])
	   {
		general_on_error();
	/*END_ERROR;*/
	   }
	}

	MISC_release_request_silent(req_handle1);
}


void write_field_dimensions()
{
   struct isc_421_struct {
          char  isc_422 [32];	/* RDB$FIELD_NAME */
          ISC_LONG isc_423;	/* RDB$UPPER_BOUND */
          ISC_LONG isc_424;	/* RDB$LOWER_BOUND */
          short isc_425;	/* isc_utility */
          short isc_426;	/* RDB$DIMENSION */
   } isc_421;
/**************************************
 *
 *	w r i t e _ f i e l d _ d i m e n s i o n s
 *
 **************************************
 *
 * Functional description
 * 	write a record in the burp file for
 *	each array field dimension.
 *
 **************************************/
	isc_req_handle req_handle1 = 0;

	BurpGlobals* tdgbl = BurpGlobals::getSpecific();

	/*FOR (REQUEST_HANDLE req_handle1)
		X IN RDB$FIELD_DIMENSIONS*/
	{
        if (!req_handle1)
           isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &req_handle1, (short) sizeof(isc_420), (char*) isc_420);
	if (req_handle1)
	   {
           isc_start_request (isc_status, (FB_API_HANDLE*) &req_handle1, (FB_API_HANDLE*) &gds_trans, (short) 0);
	   }
	if (!isc_status [1]) {
	while (1)
	   {
           isc_receive (isc_status, (FB_API_HANDLE*) &req_handle1, (short) 0, (short) 44, &isc_421, (short) 0);
	   if (!isc_421.isc_425 || isc_status [1]) break;
		put(tdgbl, rec_field_dimensions);
		PUT_TEXT (att_field_name, /*X.RDB$FIELD_NAME*/
					  isc_421.isc_422);
		put_numeric (att_field_dimensions, /*X.RDB$DIMENSION*/
						   isc_421.isc_426);
		put_numeric (att_field_range_low, /*X.RDB$LOWER_BOUND*/
						  isc_421.isc_424);
		put_numeric (att_field_range_high, /*X.RDB$UPPER_BOUND*/
						   isc_421.isc_423);
		put(tdgbl, att_end);
	/*END_FOR;*/
	   }
	   };
	/*ON_ERROR*/
	if (isc_status [1])
	   {
		general_on_error();
	/*END_ERROR;*/
	   }
	}

	MISC_release_request_silent(req_handle1);
}


void write_filters()
{
   struct isc_412_struct {
          char  isc_413 [32];	/* RDB$ENTRYPOINT */
          char  isc_414 [256];	/* RDB$MODULE_NAME */
          ISC_QUAD isc_415;	/* RDB$DESCRIPTION */
          char  isc_416 [32];	/* RDB$FUNCTION_NAME */
          short isc_417;	/* isc_utility */
          short isc_418;	/* RDB$OUTPUT_SUB_TYPE */
          short isc_419;	/* RDB$INPUT_SUB_TYPE */
   } isc_412;
/**************************************
 *
 *	w r i t e _ f i l t e r s
 *
 **************************************
 *
 * Functional description
 * 	write a record in the burp file for
 *	each filter.
 *
 **************************************/
	TEXT temp[GDS_NAME_LEN];
	isc_req_handle req_handle1 = 0;

	BurpGlobals* tdgbl = BurpGlobals::getSpecific();

	/*FOR (REQUEST_HANDLE req_handle1)
		X IN RDB$FILTERS
		WITH X.RDB$SYSTEM_FLAG MISSING OR X.RDB$SYSTEM_FLAG NE 1*/
	{
        if (!req_handle1)
           isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &req_handle1, (short) sizeof(isc_411), (char*) isc_411);
	if (req_handle1)
	   {
           isc_start_request (isc_status, (FB_API_HANDLE*) &req_handle1, (FB_API_HANDLE*) &gds_trans, (short) 0);
	   }
	if (!isc_status [1]) {
	while (1)
	   {
           isc_receive (isc_status, (FB_API_HANDLE*) &req_handle1, (short) 0, (short) 334, &isc_412, (short) 0);
	   if (!isc_412.isc_417 || isc_status [1]) break;
		put(tdgbl, rec_filter);
		const SSHORT l = PUT_TEXT (att_filter_name, /*X.RDB$FUNCTION_NAME*/
							    isc_412.isc_416);
		MISC_terminate (/*X.RDB$FUNCTION_NAME*/
				isc_412.isc_416, temp, l, sizeof(temp));
		BURP_verbose (145, temp);
		// msg 145 writing filter %s
		put_source_blob (att_filter_description2, att_filter_description, /*X.RDB$DESCRIPTION*/
										  isc_412.isc_415);
		PUT_TEXT (att_filter_module_name, /*X.RDB$MODULE_NAME*/
						  isc_412.isc_414);
		PUT_TEXT (att_filter_entrypoint, /*X.RDB$ENTRYPOINT*/
						 isc_412.isc_413);
		put_numeric (att_filter_input_sub_type, /*X.RDB$INPUT_SUB_TYPE*/
							isc_412.isc_419);
		put_numeric (att_filter_output_sub_type, /*X.RDB$OUTPUT_SUB_TYPE*/
							 isc_412.isc_418);
		put(tdgbl, att_end);
	/*END_FOR;*/
	   }
	   };
	/*ON_ERROR*/
	if (isc_status [1])
	   {
		general_on_error();
	/*END_ERROR;*/
	   }
	}

	MISC_release_request_silent(req_handle1);
}


void write_functions()
{
   struct isc_402_struct {
          char  isc_403 [32];	/* RDB$QUERY_NAME */
          char  isc_404 [32];	/* RDB$ENTRYPOINT */
          char  isc_405 [256];	/* RDB$MODULE_NAME */
          ISC_QUAD isc_406;	/* RDB$DESCRIPTION */
          char  isc_407 [32];	/* RDB$FUNCTION_NAME */
          short isc_408;	/* isc_utility */
          short isc_409;	/* RDB$FUNCTION_TYPE */
          short isc_410;	/* RDB$RETURN_ARGUMENT */
   } isc_402;
/**************************************
 *
 *	w r i t e _ f u n c t i o n s
 *
 **************************************
 *
 * Functional description
 * 	write a record in the burp file for
 *	each function.
 *
 **************************************/
	GDS_NAME func;
	TEXT temp[GDS_NAME_LEN];
	isc_req_handle req_handle1 = 0;

	BurpGlobals* tdgbl = BurpGlobals::getSpecific();

	/*FOR (REQUEST_HANDLE req_handle1)
		X IN RDB$FUNCTIONS WITH X.RDB$SYSTEM_FLAG MISSING OR X.RDB$SYSTEM_FLAG NE 1*/
	{
        if (!req_handle1)
           isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &req_handle1, (short) sizeof(isc_401), (char*) isc_401);
	if (req_handle1)
	   {
           isc_start_request (isc_status, (FB_API_HANDLE*) &req_handle1, (FB_API_HANDLE*) &gds_trans, (short) 0);
	   }
	if (!isc_status [1]) {
	while (1)
	   {
           isc_receive (isc_status, (FB_API_HANDLE*) &req_handle1, (short) 0, (short) 366, &isc_402, (short) 0);
	   if (!isc_402.isc_408 || isc_status [1]) break;
		put(tdgbl, rec_function);
		const SSHORT l = PUT_TEXT (att_function_name, /*X.RDB$FUNCTION_NAME*/
							      isc_402.isc_407);
		MISC_terminate (/*X.RDB$FUNCTION_NAME*/
				isc_402.isc_407, temp, l, sizeof(temp));
		BURP_verbose (147, temp);
		// msg 147 writing function %.*s
		put_source_blob (att_function_description2, att_function_description, /*X.RDB$DESCRIPTION*/
										      isc_402.isc_406);
		PUT_TEXT (att_function_module_name, /*X.RDB$MODULE_NAME*/
						    isc_402.isc_405);
		PUT_TEXT (att_function_entrypoint, /*X.RDB$ENTRYPOINT*/
						   isc_402.isc_404);
		put_numeric (att_function_return_arg, /*X.RDB$RETURN_ARGUMENT*/
						      isc_402.isc_410);
		put_numeric (att_function_type, /*X.RDB$FUNCTION_TYPE*/
						isc_402.isc_409);
		PUT_TEXT (att_function_query_name, /*X.RDB$QUERY_NAME*/
						   isc_402.isc_403);
		put(tdgbl, att_end);
		COPY (/*X.RDB$FUNCTION_NAME*/
		      isc_402.isc_407, func);
		write_function_args (func);
		put(tdgbl, rec_function_end);
	/*END_FOR;*/
	   }
	   };
	/*ON_ERROR*/
	if (isc_status [1])
	   {
		general_on_error();
	/*END_ERROR;*/
	   }
	}

	MISC_release_request_silent(req_handle1);
}


void write_function_args( GDS_NAME funcptr)
{
   struct isc_369_struct {
          short isc_370;	/* isc_utility */
          short isc_371;	/* gds__null_flag */
          short isc_372;	/* RDB$CHARACTER_SET_ID */
   } isc_369;
   struct isc_366_struct {
          char  isc_367 [32];	/* RDB$FUNCTION_NAME */
          short isc_368;	/* RDB$ARGUMENT_POSITION */
   } isc_366;
   struct isc_376_struct {
          char  isc_377 [32];	/* RDB$FUNCTION_NAME */
          short isc_378;	/* isc_utility */
          short isc_379;	/* RDB$FIELD_SUB_TYPE */
          short isc_380;	/* RDB$FIELD_LENGTH */
          short isc_381;	/* RDB$FIELD_SCALE */
          short isc_382;	/* RDB$FIELD_TYPE */
          short isc_383;	/* RDB$MECHANISM */
          short isc_384;	/* RDB$ARGUMENT_POSITION */
   } isc_376;
   struct isc_374_struct {
          char  isc_375 [32];	/* RDB$FUNCTION_NAME */
   } isc_374;
   struct isc_388_struct {
          char  isc_389 [32];	/* RDB$FUNCTION_NAME */
          short isc_390;	/* isc_utility */
          short isc_391;	/* gds__null_flag */
          short isc_392;	/* RDB$FIELD_PRECISION */
          short isc_393;	/* gds__null_flag */
          short isc_394;	/* RDB$CHARACTER_SET_ID */
          short isc_395;	/* RDB$FIELD_SUB_TYPE */
          short isc_396;	/* RDB$FIELD_LENGTH */
          short isc_397;	/* RDB$FIELD_SCALE */
          short isc_398;	/* RDB$FIELD_TYPE */
          short isc_399;	/* RDB$MECHANISM */
          short isc_400;	/* RDB$ARGUMENT_POSITION */
   } isc_388;
   struct isc_386_struct {
          char  isc_387 [32];	/* RDB$FUNCTION_NAME */
   } isc_386;
/**************************************
 *
 *	w r i t e _ f u n c t i o n _ a r g s
 *
 **************************************
 *
 * Functional description
 * 	write all arguments for a function.
 *
 **************************************/
	TEXT temp[GDS_NAME_LEN];

	BurpGlobals* tdgbl = BurpGlobals::getSpecific();

	// if we have all capabilities, use the first request to get the
	// most performance out of the latest engine; if we don't
	// have one of the capabilities we must use the second set of
	// requests--this requires more code but it is well worth it
	// for the performance benefits, especially remotely--deej

	if (tdgbl->BCK_capabilities & BCK_ods10)
	{
		/*FOR (REQUEST_HANDLE tdgbl->handles_write_function_args_req_handle1)
			X IN RDB$FUNCTION_ARGUMENTS WITH
			X.RDB$FUNCTION_NAME EQ funcptr*/
		{
                if (!tdgbl->handles_write_function_args_req_handle1)
                   isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &tdgbl->handles_write_function_args_req_handle1, (short) sizeof(isc_385), (char*) isc_385);
		isc_vtov ((const char*) funcptr, (char*) isc_386.isc_387, 32);
		if (tdgbl->handles_write_function_args_req_handle1)
		   {
                   isc_start_and_send (isc_status, (FB_API_HANDLE*) &tdgbl->handles_write_function_args_req_handle1, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 32, &isc_386, (short) 0);
		   }
		if (!isc_status [1]) {
		while (1)
		   {
                   isc_receive (isc_status, (FB_API_HANDLE*) &tdgbl->handles_write_function_args_req_handle1, (short) 1, (short) 54, &isc_388, (short) 0);
		   if (!isc_388.isc_390 || isc_status [1]) break;

			put(tdgbl, rec_function_arg);
			const SSHORT l = PUT_TEXT (att_functionarg_name, /*X.RDB$FUNCTION_NAME*/
									 isc_388.isc_389);
			MISC_terminate (/*X.RDB$FUNCTION_NAME*/
					isc_388.isc_389, temp, l, sizeof(temp));
			BURP_verbose (141, temp);
			// msg 141 writing argument for function %s
			put_numeric (att_functionarg_position, /*X.RDB$ARGUMENT_POSITION*/
							       isc_388.isc_400);
			put_numeric (att_functionarg_mechanism, /*X.RDB$MECHANISM*/
								isc_388.isc_399);
			put_numeric (att_functionarg_field_type, /*X.RDB$FIELD_TYPE*/
								 isc_388.isc_398);
			put_numeric (att_functionarg_field_scale, /*X.RDB$FIELD_SCALE*/
								  isc_388.isc_397);
			put_numeric (att_functionarg_field_length, /*X.RDB$FIELD_LENGTH*/
								   isc_388.isc_396);
			put_numeric (att_functionarg_field_sub_type, /*X.RDB$FIELD_SUB_TYPE*/
								     isc_388.isc_395);
			if (!/*X.RDB$CHARACTER_SET_ID.NULL*/
			     isc_388.isc_393)
				put_numeric (att_functionarg_character_set, /*X.RDB$CHARACTER_SET_ID*/
									    isc_388.isc_394);

			if (!/*X.RDB$FIELD_PRECISION.NULL*/
			     isc_388.isc_391)
				put_numeric (att_functionarg_field_precision, /*X.RDB$FIELD_PRECISION*/
									      isc_388.isc_392);
			put(tdgbl, att_end);
		/*END_FOR;*/
		   }
		   };
		/*ON_ERROR*/
		if (isc_status [1])
		   {
			general_on_error();
		/*END_ERROR;*/
		   }
		}
	}
	else
	{
		/*FOR (REQUEST_HANDLE tdgbl->handles_write_function_args_req_handle1)
			X IN RDB$FUNCTION_ARGUMENTS WITH
			X.RDB$FUNCTION_NAME EQ funcptr*/
		{
                if (!tdgbl->handles_write_function_args_req_handle1)
                   isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &tdgbl->handles_write_function_args_req_handle1, (short) sizeof(isc_373), (char*) isc_373);
		isc_vtov ((const char*) funcptr, (char*) isc_374.isc_375, 32);
		if (tdgbl->handles_write_function_args_req_handle1)
		   {
                   isc_start_and_send (isc_status, (FB_API_HANDLE*) &tdgbl->handles_write_function_args_req_handle1, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 32, &isc_374, (short) 0);
		   }
		if (!isc_status [1]) {
		while (1)
		   {
                   isc_receive (isc_status, (FB_API_HANDLE*) &tdgbl->handles_write_function_args_req_handle1, (short) 1, (short) 46, &isc_376, (short) 0);
		   if (!isc_376.isc_378 || isc_status [1]) break;

			put(tdgbl, rec_function_arg);
			const SSHORT l = PUT_TEXT (att_functionarg_name, /*X.RDB$FUNCTION_NAME*/
									 isc_376.isc_377);
			MISC_terminate (/*X.RDB$FUNCTION_NAME*/
					isc_376.isc_377, temp, l, sizeof(temp));
			BURP_verbose (141, temp);
			// msg 141 writing argument for function %s
			put_numeric (att_functionarg_position, /*X.RDB$ARGUMENT_POSITION*/
							       isc_376.isc_384);
			put_numeric (att_functionarg_mechanism, /*X.RDB$MECHANISM*/
								isc_376.isc_383);
			put_numeric (att_functionarg_field_type, /*X.RDB$FIELD_TYPE*/
								 isc_376.isc_382);
			put_numeric (att_functionarg_field_scale, /*X.RDB$FIELD_SCALE*/
								  isc_376.isc_381);
			put_numeric (att_functionarg_field_length, /*X.RDB$FIELD_LENGTH*/
								   isc_376.isc_380);
			put_numeric (att_functionarg_field_sub_type, /*X.RDB$FIELD_SUB_TYPE*/
								     isc_376.isc_379);

			if (tdgbl->BCK_capabilities & BCK_ods8)
			{
				/*FOR (REQUEST_HANDLE tdgbl->handles_write_function_args_req_handle2)
					X2 IN RDB$FUNCTION_ARGUMENTS WITH
					X2.RDB$FUNCTION_NAME EQ funcptr AND
					X2.RDB$ARGUMENT_POSITION = X.RDB$ARGUMENT_POSITION*/
				{
                                if (!tdgbl->handles_write_function_args_req_handle2)
                                   isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &tdgbl->handles_write_function_args_req_handle2, (short) sizeof(isc_365), (char*) isc_365);
				isc_vtov ((const char*) funcptr, (char*) isc_366.isc_367, 32);
				isc_366.isc_368 = isc_376.isc_384;
				if (tdgbl->handles_write_function_args_req_handle2)
				   {
                                   isc_start_and_send (isc_status, (FB_API_HANDLE*) &tdgbl->handles_write_function_args_req_handle2, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 34, &isc_366, (short) 0);
				   }
				if (!isc_status [1]) {
				while (1)
				   {
                                   isc_receive (isc_status, (FB_API_HANDLE*) &tdgbl->handles_write_function_args_req_handle2, (short) 1, (short) 6, &isc_369, (short) 0);
				   if (!isc_369.isc_370 || isc_status [1]) break;;

					if (!/*X2.RDB$CHARACTER_SET_ID.NULL*/
					     isc_369.isc_371)
						put_numeric (att_functionarg_character_set, /*X2.RDB$CHARACTER_SET_ID*/
											    isc_369.isc_372);
					// Note that BCK_ods10 canNOT be set if we're in this
					// "else" branch.  Hence there is no need to test that
					// bit and store the RDB$FIELD_PRECISION.

				/*END_FOR;*/
				   }
				   };
				/*ON_ERROR*/
				if (isc_status [1])
				   {
					general_on_error();
				/*END_ERROR;*/
				   }
				}
			}
			put(tdgbl, att_end);

		/*END_FOR;*/
		   }
		   };
		/*ON_ERROR*/
		if (isc_status [1])
		   {
			general_on_error();
		/*END_ERROR;*/
		   }
		}
	}
}


void write_generators()
{
   struct isc_356_struct {
          char  isc_357 [32];	/* RDB$GENERATOR_NAME */
          short isc_358;	/* isc_utility */
   } isc_356;
   struct isc_360_struct {
          ISC_QUAD isc_361;	/* RDB$DESCRIPTION */
          char  isc_362 [32];	/* RDB$GENERATOR_NAME */
          short isc_363;	/* isc_utility */
          short isc_364;	/* gds__null_flag */
   } isc_360;
/**************************************
 *
 *	w r i t e _ g e n e r a t o r s
 *
 **************************************
 *
 * Functional description
 *	Write any defined generators.
 *
 **************************************/
	isc_req_handle req_handle1 = 0;
	TEXT temp[GDS_NAME_LEN];

	BurpGlobals* tdgbl = BurpGlobals::getSpecific();

	if (tdgbl->BCK_capabilities & BCK_ods11)
	{
		/*FOR (REQUEST_HANDLE req_handle1)
			X IN RDB$GENERATORS
			WITH X.RDB$SYSTEM_FLAG MISSING OR X.RDB$SYSTEM_FLAG NE 1*/
		{
                if (!req_handle1)
                   isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &req_handle1, (short) sizeof(isc_359), (char*) isc_359);
		if (req_handle1)
		   {
                   isc_start_request (isc_status, (FB_API_HANDLE*) &req_handle1, (FB_API_HANDLE*) &gds_trans, (short) 0);
		   }
		if (!isc_status [1]) {
		while (1)
		   {
                   isc_receive (isc_status, (FB_API_HANDLE*) &req_handle1, (short) 0, (short) 44, &isc_360, (short) 0);
		   if (!isc_360.isc_363 || isc_status [1]) break;
			put(tdgbl, rec_generator);
			const SSHORT l = PUT_TEXT (att_gen_generator, /*X.RDB$GENERATOR_NAME*/
								      isc_360.isc_362);
			SINT64 value = 0;
			if (!tdgbl->gbl_sw_meta) {
				value = get_gen_id (/*X.RDB$GENERATOR_NAME*/
						    isc_360.isc_362, l);
				put_int64 (att_gen_value_int64, value);
			}
			if (!/*X.RDB$DESCRIPTION.NULL*/
			     isc_360.isc_364) {
				put_source_blob (att_gen_description, att_gen_description, /*X.RDB$DESCRIPTION*/
											   isc_360.isc_361);
			}
			put(tdgbl, att_end);
			MISC_terminate (/*X.RDB$GENERATOR_NAME*/
					isc_360.isc_362, temp, l, sizeof(temp));
			BURP_verbose (165, SafeArg() << temp << value);
			// msg 165 writing generator %s value %ld
		/*END_FOR;*/
		   }
		   };
		/*ON_ERROR*/
		if (isc_status [1])
		   {
			general_on_error();
		/*END_ERROR;*/
		   }
		}
	}
	else
	{
		/*FOR (REQUEST_HANDLE req_handle1)
			X IN RDB$GENERATORS
			WITH X.RDB$SYSTEM_FLAG MISSING OR X.RDB$SYSTEM_FLAG NE 1*/
		{
                if (!req_handle1)
                   isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &req_handle1, (short) sizeof(isc_355), (char*) isc_355);
		if (req_handle1)
		   {
                   isc_start_request (isc_status, (FB_API_HANDLE*) &req_handle1, (FB_API_HANDLE*) &gds_trans, (short) 0);
		   }
		if (!isc_status [1]) {
		while (1)
		   {
                   isc_receive (isc_status, (FB_API_HANDLE*) &req_handle1, (short) 0, (short) 34, &isc_356, (short) 0);
		   if (!isc_356.isc_358 || isc_status [1]) break;
			put(tdgbl, rec_generator);
			const SSHORT l = PUT_TEXT (att_gen_generator, /*X.RDB$GENERATOR_NAME*/
								      isc_356.isc_357);
			SINT64 value = 0;
			if (!tdgbl->gbl_sw_meta) {
				value = get_gen_id (/*X.RDB$GENERATOR_NAME*/
						    isc_356.isc_357, l);
				put_int64 (att_gen_value_int64, value);
			}
			put(tdgbl, att_end);
			MISC_terminate (/*X.RDB$GENERATOR_NAME*/
					isc_356.isc_357, temp, l, sizeof(temp));
			BURP_verbose (165, SafeArg() << temp << value);
			// msg 165 writing generator %s value %ld
		/*END_FOR;*/
		   }
		   };
		/*ON_ERROR*/
		if (isc_status [1])
		   {
			general_on_error();
		/*END_ERROR;*/
		   }
		}
	}

	MISC_release_request_silent(req_handle1);
}


void write_global_fields()
{
   struct isc_263_struct {
          short isc_264;	/* isc_utility */
          short isc_265;	/* gds__null_flag */
          short isc_266;	/* RDB$FIELD_PRECISION */
   } isc_263;
   struct isc_261_struct {
          char  isc_262 [32];	/* RDB$FIELD_NAME */
   } isc_261;
   struct isc_270_struct {
          ISC_QUAD isc_271;	/* RDB$MISSING_SOURCE */
          ISC_QUAD isc_272;	/* RDB$DEFAULT_SOURCE */
          short isc_273;	/* isc_utility */
          short isc_274;	/* gds__null_flag */
          short isc_275;	/* RDB$COLLATION_ID */
          short isc_276;	/* gds__null_flag */
          short isc_277;	/* RDB$CHARACTER_SET_ID */
          short isc_278;	/* gds__null_flag */
          short isc_279;	/* gds__null_flag */
          short isc_280;	/* gds__null_flag */
          short isc_281;	/* RDB$CHARACTER_LENGTH */
          short isc_282;	/* gds__null_flag */
          short isc_283;	/* RDB$NULL_FLAG */
   } isc_270;
   struct isc_268_struct {
          char  isc_269 [32];	/* RDB$FIELD_NAME */
   } isc_268;
   struct isc_287_struct {
          short isc_288;	/* isc_utility */
          short isc_289;	/* RDB$DIMENSIONS */
          short isc_290;	/* RDB$EXTERNAL_SCALE */
          short isc_291;	/* RDB$EXTERNAL_TYPE */
          short isc_292;	/* RDB$EXTERNAL_LENGTH */
   } isc_287;
   struct isc_285_struct {
          char  isc_286 [32];	/* RDB$FIELD_NAME */
   } isc_285;
   struct isc_294_struct {
          ISC_QUAD isc_295;	/* RDB$DESCRIPTION */
          ISC_QUAD isc_296;	/* RDB$COMPUTED_SOURCE */
          ISC_QUAD isc_297;	/* RDB$COMPUTED_BLR */
          ISC_QUAD isc_298;	/* RDB$VALIDATION_SOURCE */
          ISC_QUAD isc_299;	/* RDB$VALIDATION_BLR */
          ISC_QUAD isc_300;	/* RDB$DEFAULT_VALUE */
          ISC_QUAD isc_301;	/* RDB$MISSING_VALUE */
          ISC_QUAD isc_302;	/* RDB$QUERY_HEADER */
          char  isc_303 [128];	/* RDB$EDIT_STRING */
          char  isc_304 [32];	/* RDB$QUERY_NAME */
          char  isc_305 [32];	/* RDB$FIELD_NAME */
          short isc_306;	/* isc_utility */
          short isc_307;	/* RDB$SYSTEM_FLAG */
          short isc_308;	/* RDB$SEGMENT_LENGTH */
          short isc_309;	/* RDB$FIELD_SCALE */
          short isc_310;	/* RDB$FIELD_SUB_TYPE */
          short isc_311;	/* RDB$FIELD_LENGTH */
          short isc_312;	/* RDB$FIELD_TYPE */
          short isc_313;	/* gds__null_flag */
          short isc_314;	/* gds__null_flag */
   } isc_294;
   struct isc_316_struct {
          ISC_QUAD isc_317;	/* RDB$MISSING_SOURCE */
          ISC_QUAD isc_318;	/* RDB$DEFAULT_SOURCE */
          ISC_QUAD isc_319;	/* RDB$DESCRIPTION */
          ISC_QUAD isc_320;	/* RDB$COMPUTED_SOURCE */
          ISC_QUAD isc_321;	/* RDB$COMPUTED_BLR */
          ISC_QUAD isc_322;	/* RDB$VALIDATION_SOURCE */
          ISC_QUAD isc_323;	/* RDB$VALIDATION_BLR */
          ISC_QUAD isc_324;	/* RDB$DEFAULT_VALUE */
          ISC_QUAD isc_325;	/* RDB$MISSING_VALUE */
          ISC_QUAD isc_326;	/* RDB$QUERY_HEADER */
          char  isc_327 [128];	/* RDB$EDIT_STRING */
          char  isc_328 [32];	/* RDB$QUERY_NAME */
          char  isc_329 [32];	/* RDB$FIELD_NAME */
          short isc_330;	/* isc_utility */
          short isc_331;	/* gds__null_flag */
          short isc_332;	/* RDB$FIELD_PRECISION */
          short isc_333;	/* gds__null_flag */
          short isc_334;	/* RDB$COLLATION_ID */
          short isc_335;	/* gds__null_flag */
          short isc_336;	/* RDB$CHARACTER_SET_ID */
          short isc_337;	/* gds__null_flag */
          short isc_338;	/* gds__null_flag */
          short isc_339;	/* gds__null_flag */
          short isc_340;	/* RDB$CHARACTER_LENGTH */
          short isc_341;	/* gds__null_flag */
          short isc_342;	/* RDB$NULL_FLAG */
          short isc_343;	/* RDB$DIMENSIONS */
          short isc_344;	/* RDB$EXTERNAL_SCALE */
          short isc_345;	/* RDB$EXTERNAL_TYPE */
          short isc_346;	/* RDB$EXTERNAL_LENGTH */
          short isc_347;	/* RDB$SYSTEM_FLAG */
          short isc_348;	/* RDB$SEGMENT_LENGTH */
          short isc_349;	/* RDB$FIELD_SCALE */
          short isc_350;	/* RDB$FIELD_SUB_TYPE */
          short isc_351;	/* RDB$FIELD_LENGTH */
          short isc_352;	/* RDB$FIELD_TYPE */
          short isc_353;	/* gds__null_flag */
          short isc_354;	/* gds__null_flag */
   } isc_316;
/**************************************
 *
 *	w r i t e _ g l o b a l _ f i e l d s
 *
 **************************************
 *
 * Functional description
 * 	write a record in the burp file for
 *	each global field.
 *
 **************************************/
	TEXT temp[GDS_NAME_LEN];
	isc_req_handle req_handle1 = 0, req_handle2 = 0,
		req_handle3 = 0, req_handle4 = 0;

	BurpGlobals* tdgbl = BurpGlobals::getSpecific();

	// if we have all capabilities, use the first request to get the
	// most performance out of the latest engine; if we don't
	// have one of the capabilities we must use the second set of
	// requests--this requires more code but it is well worth it
	// for the performance benefits, especially remotely--deej

	if ((tdgbl->BCK_capabilities & BCK_attributes_v3) &&
		(tdgbl->BCK_capabilities & BCK_ods8) &&
		(tdgbl->BCK_capabilities & BCK_ods10))
	{
		/*FOR (REQUEST_HANDLE req_handle1)
			X IN RDB$FIELDS WITH
			X.RDB$SYSTEM_FLAG NE 1 OR
			X.RDB$SYSTEM_FLAG MISSING*/
		{
                if (!req_handle1)
                   isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &req_handle1, (short) sizeof(isc_315), (char*) isc_315);
		if (req_handle1)
		   {
                   isc_start_request (isc_status, (FB_API_HANDLE*) &req_handle1, (FB_API_HANDLE*) &gds_trans, (short) 0);
		   }
		if (!isc_status [1]) {
		while (1)
		   {
                   isc_receive (isc_status, (FB_API_HANDLE*) &req_handle1, (short) 0, (short) 322, &isc_316, (short) 0);
		   if (!isc_316.isc_330 || isc_status [1]) break;

			put(tdgbl, rec_global_field);
			const SSHORT l = PUT_TEXT (att_field_name, /*X.RDB$FIELD_NAME*/
								   isc_316.isc_329);
			MISC_terminate (/*X.RDB$FIELD_NAME*/
					isc_316.isc_329, temp, l, sizeof(temp));
			BURP_verbose (149, temp);
			// msg 149  writing global field %.*s
			if (!/*X.RDB$QUERY_NAME.NULL*/
			     isc_316.isc_354 && /*X.RDB$QUERY_NAME*/
    isc_316.isc_328 [0] != ' ')
				PUT_TEXT (att_field_query_name, /*X.RDB$QUERY_NAME*/
								isc_316.isc_328);
			if (!/*X.RDB$EDIT_STRING.NULL*/
			     isc_316.isc_353 && /*X.RDB$EDIT_STRING*/
    isc_316.isc_327 [0] != ' ')
				PUT_TEXT (att_field_edit_string, /*X.RDB$EDIT_STRING*/
								 isc_316.isc_327);
			put_source_blob (att_field_query_header, att_field_query_header, /*X.RDB$QUERY_HEADER*/
											 isc_316.isc_326);
			put_numeric (att_field_type, /*X.RDB$FIELD_TYPE*/
						     isc_316.isc_352);
			put_numeric (att_field_length, /*X.RDB$FIELD_LENGTH*/
						       isc_316.isc_351);
			put_numeric (att_field_sub_type, /*X.RDB$FIELD_SUB_TYPE*/
							 isc_316.isc_350);
			put_numeric (att_field_scale, /*X.RDB$FIELD_SCALE*/
						      isc_316.isc_349);
			put_blr_blob (att_field_missing_value, /*X.RDB$MISSING_VALUE*/
							       isc_316.isc_325);
			put_blr_blob (att_field_default_value, /*X.RDB$DEFAULT_VALUE*/
							       isc_316.isc_324);
			put_blr_blob (att_field_validation_blr, /*X.RDB$VALIDATION_BLR*/
								isc_316.isc_323);
			put_source_blob(att_field_validation_source2, att_field_validation_source,
							/*X.RDB$VALIDATION_SOURCE*/
							isc_316.isc_322);
			put_blr_blob (att_field_computed_blr, /*X.RDB$COMPUTED_BLR*/
							      isc_316.isc_321);
			put_source_blob(att_field_computed_source2, att_field_computed_source,
							/*X.RDB$COMPUTED_SOURCE*/
							isc_316.isc_320);
			if (/*X.RDB$SEGMENT_LENGTH*/
			    isc_316.isc_348)
				put_numeric (att_field_segment_length, /*X.RDB$SEGMENT_LENGTH*/
								       isc_316.isc_348);
			if (/*X.RDB$SYSTEM_FLAG*/
			    isc_316.isc_347)
				put_numeric (att_field_system_flag, /*X.RDB$SYSTEM_FLAG*/
								    isc_316.isc_347);
			put_source_blob (att_field_description2, att_field_description, /*X.RDB$DESCRIPTION*/
											isc_316.isc_319);

			if (/*X.RDB$EXTERNAL_LENGTH*/
			    isc_316.isc_346)
				put_numeric (att_field_external_length, /*X.RDB$EXTERNAL_LENGTH*/
									isc_316.isc_346);
			if (/*X.RDB$EXTERNAL_TYPE*/
			    isc_316.isc_345)
				put_numeric (att_field_external_type, /*X.RDB$EXTERNAL_TYPE*/
								      isc_316.isc_345);
			if (/*X.RDB$EXTERNAL_SCALE*/
			    isc_316.isc_344)
				put_numeric (att_field_external_scale, /*X.RDB$EXTERNAL_SCALE*/
								       isc_316.isc_344);
			if (/*X.RDB$DIMENSIONS*/
			    isc_316.isc_343)
				put_numeric (att_field_dimensions, /*X.RDB$DIMENSIONS*/
								   isc_316.isc_343);
			if (!/*X.RDB$NULL_FLAG.NULL*/
			     isc_316.isc_341)
				put_numeric (att_field_null_flag, /*X.RDB$NULL_FLAG*/
								  isc_316.isc_342);
			if (!/*X.RDB$CHARACTER_LENGTH.NULL*/
			     isc_316.isc_339)
				put_numeric (att_field_character_length, /*X.RDB$CHARACTER_LENGTH*/
									 isc_316.isc_340);
			if (!/*X.RDB$DEFAULT_SOURCE.NULL*/
			     isc_316.isc_338)
				put_source_blob(att_field_default_source, att_field_default_source,
								/*X.RDB$DEFAULT_SOURCE*/
								isc_316.isc_318);
			if (!/*X.RDB$MISSING_SOURCE.NULL*/
			     isc_316.isc_337)
				put_source_blob(att_field_missing_source, att_field_missing_source,
								/*X.RDB$MISSING_SOURCE*/
								isc_316.isc_317);
			if (!/*X.RDB$CHARACTER_SET_ID.NULL*/
			     isc_316.isc_335)
				put_numeric (att_field_character_set, /*X.RDB$CHARACTER_SET_ID*/
								      isc_316.isc_336);
			if (!/*X.RDB$COLLATION_ID.NULL*/
			     isc_316.isc_333)
				put_numeric (att_field_collation_id, /*X.RDB$COLLATION_ID*/
								     isc_316.isc_334);

			if (!/*X.RDB$FIELD_PRECISION.NULL*/
			     isc_316.isc_331)
				put_numeric (att_field_precision, /*X.RDB$FIELD_PRECISION*/
								  isc_316.isc_332);

			put(tdgbl, att_end);

		/*END_FOR;*/
		   }
		   };
		/*ON_ERROR*/
		if (isc_status [1])
		   {
			general_on_error();
		/*END_ERROR;*/
		   }
		}
	}
	else
	{
		/*FOR (REQUEST_HANDLE req_handle1)
			X IN RDB$FIELDS WITH
			X.RDB$SYSTEM_FLAG NE 1 OR
			X.RDB$SYSTEM_FLAG MISSING*/
		{
                if (!req_handle1)
                   isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &req_handle1, (short) sizeof(isc_293), (char*) isc_293);
		if (req_handle1)
		   {
                   isc_start_request (isc_status, (FB_API_HANDLE*) &req_handle1, (FB_API_HANDLE*) &gds_trans, (short) 0);
		   }
		if (!isc_status [1]) {
		while (1)
		   {
                   isc_receive (isc_status, (FB_API_HANDLE*) &req_handle1, (short) 0, (short) 274, &isc_294, (short) 0);
		   if (!isc_294.isc_306 || isc_status [1]) break;

			put(tdgbl, rec_global_field);
			const SSHORT l = PUT_TEXT (att_field_name, /*X.RDB$FIELD_NAME*/
								   isc_294.isc_305);
			MISC_terminate (/*X.RDB$FIELD_NAME*/
					isc_294.isc_305, temp, l, sizeof(temp));
			BURP_verbose (149, temp);
			// msg 149  writing global field %.*s
			if (!/*X.RDB$QUERY_NAME.NULL*/
			     isc_294.isc_314 && /*X.RDB$QUERY_NAME*/
    isc_294.isc_304 [0] != ' ')
				PUT_TEXT (att_field_query_name, /*X.RDB$QUERY_NAME*/
								isc_294.isc_304);
			if (!/*X.RDB$EDIT_STRING.NULL*/
			     isc_294.isc_313 && /*X.RDB$EDIT_STRING*/
    isc_294.isc_303 [0] != ' ')
				PUT_TEXT (att_field_edit_string, /*X.RDB$EDIT_STRING*/
								 isc_294.isc_303);
			put_source_blob (att_field_query_header, att_field_query_header, /*X.RDB$QUERY_HEADER*/
											 isc_294.isc_302);
			put_numeric (att_field_type, /*X.RDB$FIELD_TYPE*/
						     isc_294.isc_312);
			put_numeric (att_field_length, /*X.RDB$FIELD_LENGTH*/
						       isc_294.isc_311);
			put_numeric (att_field_sub_type, /*X.RDB$FIELD_SUB_TYPE*/
							 isc_294.isc_310);
			put_numeric (att_field_scale, /*X.RDB$FIELD_SCALE*/
						      isc_294.isc_309);
			put_blr_blob (att_field_missing_value, /*X.RDB$MISSING_VALUE*/
							       isc_294.isc_301);
			put_blr_blob (att_field_default_value, /*X.RDB$DEFAULT_VALUE*/
							       isc_294.isc_300);
			put_blr_blob (att_field_validation_blr, /*X.RDB$VALIDATION_BLR*/
								isc_294.isc_299);
			put_source_blob(att_field_validation_source2, att_field_validation_source,
							/*X.RDB$VALIDATION_SOURCE*/
							isc_294.isc_298);
			put_blr_blob (att_field_computed_blr, /*X.RDB$COMPUTED_BLR*/
							      isc_294.isc_297);
			put_source_blob (att_field_computed_source2, att_field_computed_source,
				/*X.RDB$COMPUTED_SOURCE*/
				isc_294.isc_296);
			if (/*X.RDB$SEGMENT_LENGTH*/
			    isc_294.isc_308)
				put_numeric (att_field_segment_length, /*X.RDB$SEGMENT_LENGTH*/
								       isc_294.isc_308);
			if (/*X.RDB$SYSTEM_FLAG*/
			    isc_294.isc_307)
				put_numeric (att_field_system_flag, /*X.RDB$SYSTEM_FLAG*/
								    isc_294.isc_307);
			put_source_blob (att_field_description2, att_field_description, /*X.RDB$DESCRIPTION*/
											isc_294.isc_295);
			if (tdgbl->BCK_capabilities & BCK_attributes_v3)
			{
				/*FOR (REQUEST_HANDLE req_handle2)
					F IN RDB$FIELDS WITH F.RDB$FIELD_NAME = X.RDB$FIELD_NAME*/
				{
                                if (!req_handle2)
                                   isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &req_handle2, (short) sizeof(isc_284), (char*) isc_284);
				isc_vtov ((const char*) isc_294.isc_305, (char*) isc_285.isc_286, 32);
				if (req_handle2)
				   {
                                   isc_start_and_send (isc_status, (FB_API_HANDLE*) &req_handle2, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 32, &isc_285, (short) 0);
				   }
				if (!isc_status [1]) {
				while (1)
				   {
                                   isc_receive (isc_status, (FB_API_HANDLE*) &req_handle2, (short) 1, (short) 10, &isc_287, (short) 0);
				   if (!isc_287.isc_288 || isc_status [1]) break;

					if (/*F.RDB$EXTERNAL_LENGTH*/
					    isc_287.isc_292)
						put_numeric (att_field_external_length, /*F.RDB$EXTERNAL_LENGTH*/
											isc_287.isc_292);
					if (/*F.RDB$EXTERNAL_TYPE*/
					    isc_287.isc_291)
						put_numeric (att_field_external_type, /*F.RDB$EXTERNAL_TYPE*/
										      isc_287.isc_291);
					if (/*F.RDB$EXTERNAL_SCALE*/
					    isc_287.isc_290)
						put_numeric (att_field_external_scale, /*F.RDB$EXTERNAL_SCALE*/
										       isc_287.isc_290);
					if (/*F.RDB$DIMENSIONS*/
					    isc_287.isc_289)
						put_numeric (att_field_dimensions, /*F.RDB$DIMENSIONS*/
										   isc_287.isc_289);
				/*END_FOR;*/
				   }
				   };
				/*ON_ERROR*/
				if (isc_status [1])
				   {
					general_on_error();
				/*END_ERROR;*/
				   }
				}
			}
			if (tdgbl->BCK_capabilities & BCK_ods8)
			{
				/*FOR (REQUEST_HANDLE req_handle3)
					F IN RDB$FIELDS WITH F.RDB$FIELD_NAME = X.RDB$FIELD_NAME*/
				{
                                if (!req_handle3)
                                   isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &req_handle3, (short) sizeof(isc_267), (char*) isc_267);
				isc_vtov ((const char*) isc_294.isc_305, (char*) isc_268.isc_269, 32);
				if (req_handle3)
				   {
                                   isc_start_and_send (isc_status, (FB_API_HANDLE*) &req_handle3, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 32, &isc_268, (short) 0);
				   }
				if (!isc_status [1]) {
				while (1)
				   {
                                   isc_receive (isc_status, (FB_API_HANDLE*) &req_handle3, (short) 1, (short) 38, &isc_270, (short) 0);
				   if (!isc_270.isc_273 || isc_status [1]) break;
					if (!/*F.RDB$NULL_FLAG.NULL*/
					     isc_270.isc_282)
						put_numeric (att_field_null_flag, /*F.RDB$NULL_FLAG*/
										  isc_270.isc_283);
					if (!/*F.RDB$CHARACTER_LENGTH.NULL*/
					     isc_270.isc_280)
						put_numeric (att_field_character_length, /*F.RDB$CHARACTER_LENGTH*/
											 isc_270.isc_281);
					if (!/*F.RDB$DEFAULT_SOURCE.NULL*/
					     isc_270.isc_279)
						put_source_blob(att_field_default_source, att_field_default_source,
										/*F.RDB$DEFAULT_SOURCE*/
										isc_270.isc_272);
					if (!/*F.RDB$MISSING_SOURCE.NULL*/
					     isc_270.isc_278)
						put_source_blob(att_field_missing_source, att_field_missing_source,
										/*F.RDB$MISSING_SOURCE*/
										isc_270.isc_271);
					if (!/*F.RDB$CHARACTER_SET_ID.NULL*/
					     isc_270.isc_276)
						put_numeric (att_field_character_set, /*F.RDB$CHARACTER_SET_ID*/
										      isc_270.isc_277);
					if (!/*F.RDB$COLLATION_ID.NULL*/
					     isc_270.isc_274)
						put_numeric (att_field_collation_id, /*F.RDB$COLLATION_ID*/
										     isc_270.isc_275);

					if (tdgbl->BCK_capabilities & BCK_ods10)
					{
						/*FOR (REQUEST_HANDLE req_handle4)
							K IN RDB$FIELDS WITH K.RDB$FIELD_NAME = X.RDB$FIELD_NAME*/
						{
                                                if (!req_handle4)
                                                   isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &req_handle4, (short) sizeof(isc_260), (char*) isc_260);
						isc_vtov ((const char*) isc_294.isc_305, (char*) isc_261.isc_262, 32);
						if (req_handle4)
						   {
                                                   isc_start_and_send (isc_status, (FB_API_HANDLE*) &req_handle4, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 32, &isc_261, (short) 0);
						   }
						if (!isc_status [1]) {
						while (1)
						   {
                                                   isc_receive (isc_status, (FB_API_HANDLE*) &req_handle4, (short) 1, (short) 6, &isc_263, (short) 0);
						   if (!isc_263.isc_264 || isc_status [1]) break;
							if (!/*K.RDB$FIELD_PRECISION.NULL*/
							     isc_263.isc_265)
								put_numeric (att_field_precision, /*K.RDB$FIELD_PRECISION*/
												  isc_263.isc_266);
						/*END_FOR;*/
						   }
						   };
						/*ON_ERROR*/
						if (isc_status [1])
						   {
							general_on_error();
						/*END_ERROR;*/
						   }
						}
					}
				/*END_FOR;*/
				   }
				   };
				/*ON_ERROR*/
				if (isc_status [1])
				   {
					general_on_error();
				/*END_ERROR;*/
				   }
				}
			}
			put(tdgbl, att_end);
		/*END_FOR;*/
		   }
		   };
		/*ON_ERROR*/
		if (isc_status [1])
		   {
			general_on_error();
		/*END_ERROR;*/
		   }
		}
	}

	MISC_release_request_silent(req_handle1);
	MISC_release_request_silent(req_handle2);
	MISC_release_request_silent(req_handle3);
	MISC_release_request_silent(req_handle4);
}


void write_procedures()
{
   struct isc_230_struct {
          char  isc_231 [32];	/* RDB$OWNER_NAME */
          char  isc_232 [32];	/* RDB$SECURITY_CLASS */
          ISC_QUAD isc_233;	/* RDB$PROCEDURE_BLR */
          ISC_QUAD isc_234;	/* RDB$PROCEDURE_SOURCE */
          ISC_QUAD isc_235;	/* RDB$DESCRIPTION */
          char  isc_236 [32];	/* RDB$PROCEDURE_NAME */
          short isc_237;	/* isc_utility */
          short isc_238;	/* gds__null_flag */
          short isc_239;	/* RDB$PROCEDURE_OUTPUTS */
          short isc_240;	/* RDB$PROCEDURE_INPUTS */
   } isc_230;
   struct isc_242_struct {
          ISC_QUAD isc_243;	/* RDB$DEBUG_INFO */
          char  isc_244 [32];	/* RDB$OWNER_NAME */
          char  isc_245 [32];	/* RDB$SECURITY_CLASS */
          ISC_QUAD isc_246;	/* RDB$PROCEDURE_BLR */
          ISC_QUAD isc_247;	/* RDB$PROCEDURE_SOURCE */
          ISC_QUAD isc_248;	/* RDB$DESCRIPTION */
          char  isc_249 [32];	/* RDB$PROCEDURE_NAME */
          short isc_250;	/* isc_utility */
          short isc_251;	/* gds__null_flag */
          short isc_252;	/* gds__null_flag */
          short isc_253;	/* RDB$VALID_BLR */
          short isc_254;	/* gds__null_flag */
          short isc_255;	/* RDB$PROCEDURE_TYPE */
          short isc_256;	/* gds__null_flag */
          short isc_257;	/* gds__null_flag */
          short isc_258;	/* RDB$PROCEDURE_OUTPUTS */
          short isc_259;	/* RDB$PROCEDURE_INPUTS */
   } isc_242;
/**************************************
 *
 *	w r i t e _ p r o c e d u r e s
 *
 **************************************
 *
 * Functional description
 * 	write a record in the burp file for
 *	each stored procedure.
 *
 **************************************/
	GDS_NAME proc;
	TEXT temp[GDS_NAME_LEN];
	isc_req_handle req_handle1 = 0;

	BurpGlobals* tdgbl = BurpGlobals::getSpecific();

	if (tdgbl->BCK_capabilities & BCK_ods11_1)
	{
		/*FOR (REQUEST_HANDLE req_handle1)
			X IN RDB$PROCEDURES
			WITH X.RDB$SYSTEM_FLAG MISSING OR X.RDB$SYSTEM_FLAG NE 1*/
		{
                if (!req_handle1)
                   isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &req_handle1, (short) sizeof(isc_241), (char*) isc_241);
		if (req_handle1)
		   {
                   isc_start_request (isc_status, (FB_API_HANDLE*) &req_handle1, (FB_API_HANDLE*) &gds_trans, (short) 0);
		   }
		if (!isc_status [1]) {
		while (1)
		   {
                   isc_receive (isc_status, (FB_API_HANDLE*) &req_handle1, (short) 0, (short) 148, &isc_242, (short) 0);
		   if (!isc_242.isc_250 || isc_status [1]) break;
			put(tdgbl, rec_procedure);
			const SSHORT l = PUT_TEXT (att_procedure_name, /*X.RDB$PROCEDURE_NAME*/
								       isc_242.isc_249);
			MISC_terminate (/*X.RDB$PROCEDURE_NAME*/
					isc_242.isc_249, temp, l, sizeof(temp));
			BURP_verbose (193, temp);
			// msg 193 writing stored procedure %.*s
			put_numeric (att_procedure_inputs, /*X.RDB$PROCEDURE_INPUTS*/
							   isc_242.isc_259);
			put_numeric (att_procedure_outputs, /*X.RDB$PROCEDURE_OUTPUTS*/
							    isc_242.isc_258);
			put_source_blob(att_procedure_description2, att_procedure_description, /*X.RDB$DESCRIPTION*/
											       isc_242.isc_248);
			put_source_blob (att_procedure_source2, att_procedure_source, /*X.RDB$PROCEDURE_SOURCE*/
										      isc_242.isc_247);
			put_blr_blob (att_procedure_blr, /*X.RDB$PROCEDURE_BLR*/
							 isc_242.isc_246);
			if (!/*X.RDB$SECURITY_CLASS.NULL*/
			     isc_242.isc_257)
				PUT_TEXT (att_procedure_security_class, /*X.RDB$SECURITY_CLASS*/
									isc_242.isc_245);
			if (!/*X.RDB$OWNER_NAME.NULL*/
			     isc_242.isc_256)
				PUT_TEXT (att_procedure_owner_name, /*X.RDB$OWNER_NAME*/
								    isc_242.isc_244);
			if (!/*X.RDB$PROCEDURE_TYPE.NULL*/
			     isc_242.isc_254)
				put_numeric (att_procedure_type, /*X.RDB$PROCEDURE_TYPE*/
								 isc_242.isc_255);
			if (!/*X.RDB$VALID_BLR.NULL*/
			     isc_242.isc_252)
				put_numeric (att_procedure_valid_blr, /*X.RDB$VALID_BLR*/
								      isc_242.isc_253);
			if (!/*X.RDB$DEBUG_INFO.NULL*/
			     isc_242.isc_251)
				put_blr_blob (att_procedure_debug_info, /*X.RDB$DEBUG_INFO*/
									isc_242.isc_243);
			put(tdgbl, att_end);
			COPY(/*X.RDB$PROCEDURE_NAME*/
			     isc_242.isc_249, proc);
			write_procedure_prms (proc);
			put(tdgbl, rec_procedure_end);
		/*END_FOR;*/
		   }
		   };
		/*ON_ERROR*/
		if (isc_status [1])
		   {
			general_on_error();
		/*END_ERROR;*/
		   }
		}
	}
	else {
		/*FOR (REQUEST_HANDLE req_handle1)
			X IN RDB$PROCEDURES
			WITH X.RDB$SYSTEM_FLAG MISSING OR X.RDB$SYSTEM_FLAG NE 1*/
		{
                if (!req_handle1)
                   isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &req_handle1, (short) sizeof(isc_229), (char*) isc_229);
		if (req_handle1)
		   {
                   isc_start_request (isc_status, (FB_API_HANDLE*) &req_handle1, (FB_API_HANDLE*) &gds_trans, (short) 0);
		   }
		if (!isc_status [1]) {
		while (1)
		   {
                   isc_receive (isc_status, (FB_API_HANDLE*) &req_handle1, (short) 0, (short) 128, &isc_230, (short) 0);
		   if (!isc_230.isc_237 || isc_status [1]) break;
			put(tdgbl, rec_procedure);
			const SSHORT l = PUT_TEXT (att_procedure_name, /*X.RDB$PROCEDURE_NAME*/
								       isc_230.isc_236);
			MISC_terminate (/*X.RDB$PROCEDURE_NAME*/
					isc_230.isc_236, temp, l, sizeof(temp));
			BURP_verbose (193, temp);
			// msg 193 writing stored procedure %.*s
			put_numeric (att_procedure_inputs, /*X.RDB$PROCEDURE_INPUTS*/
							   isc_230.isc_240);
			put_numeric (att_procedure_outputs, /*X.RDB$PROCEDURE_OUTPUTS*/
							    isc_230.isc_239);
			put_source_blob (att_procedure_description2, att_procedure_description, /*X.RDB$DESCRIPTION*/
												isc_230.isc_235);
			put_source_blob (att_procedure_source2, att_procedure_source, /*X.RDB$PROCEDURE_SOURCE*/
										      isc_230.isc_234);
			put_blr_blob (att_procedure_blr, /*X.RDB$PROCEDURE_BLR*/
							 isc_230.isc_233);
			if (!/*X.RDB$SECURITY_CLASS.NULL*/
			     isc_230.isc_238)
				PUT_TEXT (att_procedure_security_class, /*X.RDB$SECURITY_CLASS*/
									isc_230.isc_232);
			if (!/*X.RDB$SECURITY_CLASS.NULL*/
			     isc_230.isc_238)
				PUT_TEXT (att_procedure_owner_name, /*X.RDB$OWNER_NAME*/
								    isc_230.isc_231);
			put(tdgbl, att_end);
			COPY(/*X.RDB$PROCEDURE_NAME*/
			     isc_230.isc_236, proc);
			write_procedure_prms (proc);
			put(tdgbl, rec_procedure_end);
		/*END_FOR;*/
		   }
		   };
		/*ON_ERROR*/
		if (isc_status [1])
		   {
			general_on_error();
		/*END_ERROR;*/
		   }
		}
	}

	MISC_release_request_silent(req_handle1);
}


void write_procedure_prms( GDS_NAME procptr)
{
   struct isc_200_struct {
          ISC_QUAD isc_201;	/* RDB$DESCRIPTION */
          char  isc_202 [32];	/* RDB$FIELD_SOURCE */
          char  isc_203 [32];	/* RDB$PARAMETER_NAME */
          short isc_204;	/* isc_utility */
          short isc_205;	/* RDB$PARAMETER_TYPE */
          short isc_206;	/* RDB$PARAMETER_NUMBER */
   } isc_200;
   struct isc_198_struct {
          char  isc_199 [32];	/* RDB$PROCEDURE_NAME */
   } isc_198;
   struct isc_210_struct {
          char  isc_211 [32];	/* RDB$RELATION_NAME */
          char  isc_212 [32];	/* RDB$FIELD_NAME */
          ISC_QUAD isc_213;	/* RDB$DEFAULT_SOURCE */
          ISC_QUAD isc_214;	/* RDB$DEFAULT_VALUE */
          ISC_QUAD isc_215;	/* RDB$DESCRIPTION */
          char  isc_216 [32];	/* RDB$FIELD_SOURCE */
          char  isc_217 [32];	/* RDB$PARAMETER_NAME */
          short isc_218;	/* isc_utility */
          short isc_219;	/* gds__null_flag */
          short isc_220;	/* gds__null_flag */
          short isc_221;	/* gds__null_flag */
          short isc_222;	/* RDB$PARAMETER_MECHANISM */
          short isc_223;	/* gds__null_flag */
          short isc_224;	/* RDB$NULL_FLAG */
          short isc_225;	/* gds__null_flag */
          short isc_226;	/* RDB$COLLATION_ID */
          short isc_227;	/* RDB$PARAMETER_TYPE */
          short isc_228;	/* RDB$PARAMETER_NUMBER */
   } isc_210;
   struct isc_208_struct {
          char  isc_209 [32];	/* RDB$PROCEDURE_NAME */
   } isc_208;
/**************************************
 *
 *	w r i t e _ p r o c e d u r e _ p r m s
 *
 **************************************
 *
 * Functional description
 * 	write all parameters of a stored procedure.
 *
 **************************************/
	TEXT temp[GDS_NAME_LEN];

	BurpGlobals* tdgbl = BurpGlobals::getSpecific();

	if (tdgbl->BCK_capabilities & BCK_ods11_1)
	{
		/*FOR (REQUEST_HANDLE tdgbl->handles_write_procedure_prms_req_handle1)
			X IN RDB$PROCEDURE_PARAMETERS WITH X.RDB$PROCEDURE_NAME EQ procptr*/
		{
                if (!tdgbl->handles_write_procedure_prms_req_handle1)
                   isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &tdgbl->handles_write_procedure_prms_req_handle1, (short) sizeof(isc_207), (char*) isc_207);
		isc_vtov ((const char*) procptr, (char*) isc_208.isc_209, 32);
		if (tdgbl->handles_write_procedure_prms_req_handle1)
		   {
                   isc_start_and_send (isc_status, (FB_API_HANDLE*) &tdgbl->handles_write_procedure_prms_req_handle1, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 32, &isc_208, (short) 0);
		   }
		if (!isc_status [1]) {
		while (1)
		   {
                   isc_receive (isc_status, (FB_API_HANDLE*) &tdgbl->handles_write_procedure_prms_req_handle1, (short) 1, (short) 174, &isc_210, (short) 0);
		   if (!isc_210.isc_218 || isc_status [1]) break;
			put(tdgbl, rec_procedure_prm);
			const SSHORT l = PUT_TEXT (att_procedureprm_name, /*X.RDB$PARAMETER_NAME*/
									  isc_210.isc_217);
			MISC_terminate (/*X.RDB$PARAMETER_NAME*/
					isc_210.isc_217, temp, l, sizeof(temp));
			BURP_verbose (194, temp);
			// msg 194 writing parameter %s for stored procedure
			put_numeric (att_procedureprm_number, /*X.RDB$PARAMETER_NUMBER*/
							      isc_210.isc_228);
			put_numeric (att_procedureprm_type, /*X.RDB$PARAMETER_type*/
							    isc_210.isc_227);
			PUT_TEXT (att_procedureprm_field_source, /*X.RDB$FIELD_SOURCE*/
								 isc_210.isc_216);
			put_source_blob(att_procedureprm_description2, att_procedureprm_description,
							/*X.RDB$DESCRIPTION*/
							isc_210.isc_215);
			put_blr_blob (att_procedureprm_default_value, /*X.RDB$DEFAULT_VALUE*/
								      isc_210.isc_214);
			put_source_blob(att_procedureprm_default_source, att_procedureprm_default_source,
							/*X.RDB$DEFAULT_SOURCE*/
							isc_210.isc_213);
			if (!/*X.RDB$COLLATION_ID.NULL*/
			     isc_210.isc_225)
				put_numeric (att_procedureprm_collation_id, /*X.RDB$COLLATION_ID*/
									    isc_210.isc_226);
			if (!/*X.RDB$NULL_FLAG.NULL*/
			     isc_210.isc_223)
				put_numeric (att_procedureprm_null_flag, /*X.RDB$NULL_FLAG*/
									 isc_210.isc_224);
			if (!/*X.RDB$PARAMETER_MECHANISM.NULL*/
			     isc_210.isc_221)
				put_numeric (att_procedureprm_mechanism, /*X.RDB$PARAMETER_MECHANISM*/
									 isc_210.isc_222);

			// BCK_ods11_2
			if (!/*X.RDB$FIELD_NAME.NULL*/
			     isc_210.isc_220)
				PUT_TEXT(att_procedureprm_field_name, /*X.RDB$FIELD_NAME*/
								      isc_210.isc_212);
			if (!/*X.RDB$RELATION_NAME.NULL*/
			     isc_210.isc_219)
				PUT_TEXT(att_procedureprm_relation_name, /*X.RDB$RELATION_NAME*/
									 isc_210.isc_211);

			put(tdgbl, att_end);
		/*END_FOR;*/
		   }
		   };
		/*ON_ERROR*/
		if (isc_status [1])
		   {
			general_on_error();
		/*END_ERROR;*/
		   }
		}
	}
	else
	{
		/*FOR (REQUEST_HANDLE tdgbl->handles_write_procedure_prms_req_handle1)
			X IN RDB$PROCEDURE_PARAMETERS WITH X.RDB$PROCEDURE_NAME EQ procptr*/
		{
                if (!tdgbl->handles_write_procedure_prms_req_handle1)
                   isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &tdgbl->handles_write_procedure_prms_req_handle1, (short) sizeof(isc_197), (char*) isc_197);
		isc_vtov ((const char*) procptr, (char*) isc_198.isc_199, 32);
		if (tdgbl->handles_write_procedure_prms_req_handle1)
		   {
                   isc_start_and_send (isc_status, (FB_API_HANDLE*) &tdgbl->handles_write_procedure_prms_req_handle1, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 32, &isc_198, (short) 0);
		   }
		if (!isc_status [1]) {
		while (1)
		   {
                   isc_receive (isc_status, (FB_API_HANDLE*) &tdgbl->handles_write_procedure_prms_req_handle1, (short) 1, (short) 78, &isc_200, (short) 0);
		   if (!isc_200.isc_204 || isc_status [1]) break;
			put(tdgbl, rec_procedure_prm);
			const SSHORT l = PUT_TEXT (att_procedureprm_name, /*X.RDB$PARAMETER_NAME*/
									  isc_200.isc_203);
			MISC_terminate (/*X.RDB$PARAMETER_NAME*/
					isc_200.isc_203, temp, l, sizeof(temp));
			BURP_verbose (194, temp);
			// msg 194 writing parameter %s for stored procedure
			put_numeric (att_procedureprm_number, /*X.RDB$PARAMETER_NUMBER*/
							      isc_200.isc_206);
			put_numeric (att_procedureprm_type, /*X.RDB$PARAMETER_type*/
							    isc_200.isc_205);
			PUT_TEXT (att_procedureprm_field_source, /*X.RDB$FIELD_SOURCE*/
								 isc_200.isc_202);
			put_source_blob(att_procedureprm_description2, att_procedureprm_description,
							/*X.RDB$DESCRIPTION*/
							isc_200.isc_201);
			put(tdgbl, att_end);
		/*END_FOR;*/
		   }
		   };
		/*ON_ERROR*/
		if (isc_status [1])
		   {
			general_on_error();
		/*END_ERROR;*/
		   }
		}
	}
}


void write_ref_constraints()
{
   struct isc_190_struct {
          char  isc_191 [8];	/* RDB$MATCH_OPTION */
          char  isc_192 [32];	/* RDB$CONST_NAME_UQ */
          char  isc_193 [32];	/* RDB$CONSTRAINT_NAME */
          char  isc_194 [12];	/* RDB$DELETE_RULE */
          char  isc_195 [12];	/* RDB$UPDATE_RULE */
          short isc_196;	/* isc_utility */
   } isc_190;
/**************************************
 *
 *	w r i t e _ r e f _ c o n s t r a i n t s
 *
 **************************************
 *
 * Functional description
 * 	write a record in the burp file for
 *	each referential constraint.
 *
 **************************************/
	isc_req_handle req_handle1 = 0;

	BurpGlobals* tdgbl = BurpGlobals::getSpecific();

	/*FOR (REQUEST_HANDLE req_handle1)
		X IN RDB$REF_CONSTRAINTS*/
	{
        if (!req_handle1)
           isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &req_handle1, (short) sizeof(isc_189), (char*) isc_189);
	if (req_handle1)
	   {
           isc_start_request (isc_status, (FB_API_HANDLE*) &req_handle1, (FB_API_HANDLE*) &gds_trans, (short) 0);
	   }
	if (!isc_status [1]) {
	while (1)
	   {
           isc_receive (isc_status, (FB_API_HANDLE*) &req_handle1, (short) 0, (short) 98, &isc_190, (short) 0);
	   if (!isc_190.isc_196 || isc_status [1]) break;
		put(tdgbl, rec_ref_constraint);
		PUT_TEXT (att_ref_constraint_name, /*X.RDB$CONSTRAINT_NAME*/
						   isc_190.isc_193);
		PUT_TEXT (att_ref_unique_const_name, /*X.RDB$CONST_NAME_UQ*/
						     isc_190.isc_192);
		PUT_TEXT (att_ref_match_option, /*X.RDB$MATCH_OPTION*/
						isc_190.isc_191);
		PUT_TEXT (att_ref_update_rule, /*X.RDB$UPDATE_RULE*/
					       isc_190.isc_195);
		PUT_TEXT (att_ref_delete_rule, /*X.RDB$DELETE_RULE*/
					       isc_190.isc_194);
		put(tdgbl, att_end);
	/*END_FOR;*/
	   }
	   };
	/*ON_ERROR*/
	if (isc_status [1])
	   {
		general_on_error();
	/*END_ERROR;*/
	   }
	}

	MISC_release_request_silent(req_handle1);
}

void write_rel_constraints()
{
   struct isc_180_struct {
          char  isc_181 [32];	/* RDB$INDEX_NAME */
          char  isc_182 [32];	/* RDB$RELATION_NAME */
          char  isc_183 [32];	/* RDB$CONSTRAINT_NAME */
          char  isc_184 [4];	/* RDB$INITIALLY_DEFERRED */
          char  isc_185 [4];	/* RDB$DEFERRABLE */
          char  isc_186 [12];	/* RDB$CONSTRAINT_TYPE */
          short isc_187;	/* isc_utility */
          short isc_188;	/* gds__null_flag */
   } isc_180;
/**************************************
 *
 *	w r i t e _ r e l _ c o n s t r a i n t s
 *
 **************************************
 *
 * Functional description
 * 	write a record in the burp file for
 *	each relation constraint.
 *
 **************************************/
	TEXT temp[GDS_NAME_LEN];
	isc_req_handle req_handle1 = 0;

	BurpGlobals* tdgbl = BurpGlobals::getSpecific();

	/*FOR (REQUEST_HANDLE req_handle1)
		X IN RDB$RELATION_CONSTRAINTS CROSS
		REL IN RDB$RELATIONS
		WITH REL.RDB$RELATION_NAME EQ X.RDB$RELATION_NAME AND
			 (REL.RDB$SYSTEM_FLAG MISSING OR REL.RDB$SYSTEM_FLAG NE 1)*/
	{
        if (!req_handle1)
           isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &req_handle1, (short) sizeof(isc_179), (char*) isc_179);
	if (req_handle1)
	   {
           isc_start_request (isc_status, (FB_API_HANDLE*) &req_handle1, (FB_API_HANDLE*) &gds_trans, (short) 0);
	   }
	if (!isc_status [1]) {
	while (1)
	   {
           isc_receive (isc_status, (FB_API_HANDLE*) &req_handle1, (short) 0, (short) 120, &isc_180, (short) 0);
	   if (!isc_180.isc_187 || isc_status [1]) break;
		put(tdgbl, rec_rel_constraint);
		const SSHORT l = PUT_TEXT (att_rel_constraint_name, /*X.RDB$CONSTRAINT_NAME*/
								    isc_180.isc_183);
		MISC_terminate (/*X.RDB$CONSTRAINT_NAME*/
				isc_180.isc_183, temp, l, sizeof(temp));
		BURP_verbose (207, temp);
		// msg 207 writing constraint %s
		PUT_TEXT (att_rel_constraint_type, /*X.RDB$CONSTRAINT_TYPE*/
						   isc_180.isc_186);
		PUT_TEXT (att_rel_constraint_rel_name, /*X.RDB$RELATION_NAME*/
						       isc_180.isc_182);
		PUT_TEXT (att_rel_constraint_defer, /*X.RDB$DEFERRABLE*/
						    isc_180.isc_185);
		PUT_TEXT (att_rel_constraint_init, /*X.RDB$INITIALLY_DEFERRED*/
						   isc_180.isc_184);
		if (!/*X.RDB$INDEX_NAME.NULL*/
		     isc_180.isc_188)
			PUT_TEXT (att_rel_constraint_index, /*X.RDB$INDEX_NAME*/
							    isc_180.isc_181);
		put(tdgbl, att_end);
	/*END_FOR;*/
	   }
	   };
	/*ON_ERROR*/
	if (isc_status [1])
	   {
		general_on_error();
	/*END_ERROR;*/
	   }
	}

	MISC_release_request_silent(req_handle1);
}

void write_relations()
{
   struct isc_124_struct {
          short isc_125;	/* isc_utility */
          short isc_126;	/* gds__null_flag */
          short isc_127;	/* RDB$RELATION_TYPE */
   } isc_124;
   struct isc_122_struct {
          char  isc_123 [32];	/* RDB$RELATION_NAME */
   } isc_122;
   struct isc_131_struct {
          char  isc_132 [256];	/* RDB$EXTERNAL_FILE */
          char  isc_133 [32];	/* RDB$OWNER_NAME */
          ISC_QUAD isc_134;	/* RDB$EXTERNAL_DESCRIPTION */
          short isc_135;	/* isc_utility */
          short isc_136;	/* gds__null_flag */
   } isc_131;
   struct isc_129_struct {
          char  isc_130 [32];	/* RDB$RELATION_NAME */
   } isc_129;
   struct isc_140_struct {
          char  isc_141 [32];	/* RDB$SECURITY_CLASS */
          short isc_142;	/* isc_utility */
          short isc_143;	/* gds__null_flag */
   } isc_140;
   struct isc_138_struct {
          char  isc_139 [32];	/* RDB$RELATION_NAME */
   } isc_138;
   struct isc_147_struct {
          short isc_148;	/* isc_utility */
          short isc_149;	/* gds__null_flag */
          short isc_150;	/* RDB$FLAGS */
   } isc_147;
   struct isc_145_struct {
          char  isc_146 [32];	/* RDB$RELATION_NAME */
   } isc_145;
   struct isc_152_struct {
          ISC_QUAD isc_153;	/* RDB$VIEW_SOURCE */
          ISC_QUAD isc_154;	/* RDB$DESCRIPTION */
          ISC_QUAD isc_155;	/* RDB$VIEW_BLR */
          char  isc_156 [32];	/* RDB$RELATION_NAME */
          short isc_157;	/* isc_utility */
          short isc_158;	/* RDB$RELATION_ID */
          short isc_159;	/* RDB$SYSTEM_FLAG */
   } isc_152;
   struct isc_161_struct {
          char  isc_162 [256];	/* RDB$EXTERNAL_FILE */
          char  isc_163 [32];	/* RDB$OWNER_NAME */
          ISC_QUAD isc_164;	/* RDB$EXTERNAL_DESCRIPTION */
          ISC_QUAD isc_165;	/* RDB$VIEW_SOURCE */
          ISC_QUAD isc_166;	/* RDB$DESCRIPTION */
          char  isc_167 [32];	/* RDB$SECURITY_CLASS */
          ISC_QUAD isc_168;	/* RDB$VIEW_BLR */
          char  isc_169 [32];	/* RDB$RELATION_NAME */
          short isc_170;	/* isc_utility */
          short isc_171;	/* RDB$RELATION_ID */
          short isc_172;	/* gds__null_flag */
          short isc_173;	/* RDB$RELATION_TYPE */
          short isc_174;	/* gds__null_flag */
          short isc_175;	/* gds__null_flag */
          short isc_176;	/* gds__null_flag */
          short isc_177;	/* RDB$FLAGS */
          short isc_178;	/* RDB$SYSTEM_FLAG */
   } isc_161;
/**************************************
 *
 *	w r i t e _ r e l a t i o n s
 *
 **************************************
 *
 * Functional description
 * 	write a record in the burp file for
 *	each relation.
 *
 **************************************/
	TEXT temp[GDS_NAME_LEN];
	isc_req_handle req_handle1 = 0, req_handle2 = 0,
		req_handle3 = 0, req_handle4 = 0, req_handle5 = 0;

	BurpGlobals* tdgbl = BurpGlobals::getSpecific();

	// if we have all capabilities, use the first request to get the
	// most performance out of the latest engine; if we don't
	// have one of the capabilities we must use the second set of
	// requests--this requires more code but it is well worth it
	// for the performance benefits, especially remotely--deej

	if ((tdgbl->BCK_capabilities & BCK_ods8) &&
		(tdgbl->BCK_capabilities & BCK_security) &&
		(tdgbl->BCK_capabilities & BCK_attributes_v3) &&
		(tdgbl->BCK_capabilities & BCK_ods11_1))
	{
		/*FOR (REQUEST_HANDLE req_handle1)
			X IN RDB$RELATIONS WITH X.RDB$SYSTEM_FLAG NE 1 OR
			X.RDB$SYSTEM_FLAG MISSING*/
		{
                if (!req_handle1)
                   isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &req_handle1, (short) sizeof(isc_160), (char*) isc_160);
		if (req_handle1)
		   {
                   isc_start_request (isc_status, (FB_API_HANDLE*) &req_handle1, (FB_API_HANDLE*) &gds_trans, (short) 0);
		   }
		if (!isc_status [1]) {
		while (1)
		   {
                   isc_receive (isc_status, (FB_API_HANDLE*) &req_handle1, (short) 0, (short) 402, &isc_161, (short) 0);
		   if (!isc_161.isc_170 || isc_status [1]) break;

			SSHORT flags = 0;
			put(tdgbl, rec_relation);
			const SSHORT l = PUT_TEXT (att_relation_name, /*X.RDB$RELATION_NAME*/
								      isc_161.isc_169);
			MISC_terminate (/*X.RDB$RELATION_NAME*/
					isc_161.isc_169, temp, l, sizeof(temp));
			BURP_verbose (153, temp);
			// msg 153 writing relation %.*s

			// RDB$VIEW_BLR must be the first blob field in the backup file.
			// RESTORE.EPP makes this assumption in get_relation().

			if (put_blr_blob (att_relation_view_blr, /*X.RDB$VIEW_BLR*/
								 isc_161.isc_168))
				flags |= REL_view;
			if (/*X.RDB$SYSTEM_FLAG*/
			    isc_161.isc_178)
				put_numeric (att_relation_system_flag, /*X.RDB$SYSTEM_FLAG*/
								       isc_161.isc_178);
			if (!/*X.RDB$FLAGS.NULL*/
			     isc_161.isc_176)
				put_numeric (att_relation_flags, /*X.RDB$FLAGS*/
								 isc_161.isc_177);
			if (!/*X.RDB$SECURITY_CLASS.NULL*/
			     isc_161.isc_175)
				PUT_TEXT (att_relation_security_class, /*X.RDB$SECURITY_CLASS*/
								       isc_161.isc_167);

			put_source_blob (att_relation_description2, att_relation_description,
				/*X.RDB$DESCRIPTION*/
				isc_161.isc_166);
			put_source_blob (att_relation_view_source2, att_relation_view_source, /*X.RDB$VIEW_SOURCE*/
											      isc_161.isc_165);

			put_source_blob(att_relation_ext_description2, att_relation_ext_description,
							/*X.RDB$EXTERNAL_DESCRIPTION*/
							isc_161.isc_164);
			PUT_TEXT (att_relation_owner_name, /*X.RDB$OWNER_NAME*/
							   isc_161.isc_163);
			if (!/*X.RDB$EXTERNAL_FILE.NULL*/
			     isc_161.isc_174)
			{
				if (!tdgbl->gbl_sw_convert_ext_tables)
				{
					PUT_TEXT(att_relation_ext_file_name, /*X.RDB$EXTERNAL_FILE*/
									     isc_161.isc_162);
					flags |= REL_external;
				}
			}

			if (!/*X.RDB$RELATION_TYPE.NULL*/
			     isc_161.isc_172)
				put_numeric (att_relation_type, /*X.RDB$RELATION_TYPE*/
								isc_161.isc_173);

			put(tdgbl, att_end);
			burp_rel* relation = (burp_rel*) BURP_alloc_zero (sizeof(burp_rel));
			relation->rel_next = tdgbl->relations;
			tdgbl->relations = relation;
			relation->rel_id = /*X.RDB$RELATION_ID*/
					   isc_161.isc_171;
			relation->rel_name_length = COPY(/*X.RDB$RELATION_NAME*/
							 isc_161.isc_169, relation->rel_name);
			relation->rel_flags |= flags;
			put_relation (relation);
		/*END_FOR;*/
		   }
		   };
		/*ON_ERROR*/
		if (isc_status [1])
		   {
			general_on_error();
		/*END_ERROR;*/
		   }
		}
	}
	else
	{
		/*FOR (REQUEST_HANDLE req_handle1)
			X IN RDB$RELATIONS WITH X.RDB$SYSTEM_FLAG NE 1 OR
			X.RDB$SYSTEM_FLAG MISSING*/
		{
                if (!req_handle1)
                   isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &req_handle1, (short) sizeof(isc_151), (char*) isc_151);
		if (req_handle1)
		   {
                   isc_start_request (isc_status, (FB_API_HANDLE*) &req_handle1, (FB_API_HANDLE*) &gds_trans, (short) 0);
		   }
		if (!isc_status [1]) {
		while (1)
		   {
                   isc_receive (isc_status, (FB_API_HANDLE*) &req_handle1, (short) 0, (short) 62, &isc_152, (short) 0);
		   if (!isc_152.isc_157 || isc_status [1]) break;

			SSHORT flags = 0;
			put(tdgbl, rec_relation);
			const SSHORT l = PUT_TEXT(att_relation_name, /*X.RDB$RELATION_NAME*/
								     isc_152.isc_156);
			MISC_terminate (/*X.RDB$RELATION_NAME*/
					isc_152.isc_156, temp, l, sizeof(temp));
			BURP_verbose (153, temp);
			// msg 153 writing relation %.*s

			// RDB$VIEW_BLR must be the first blob field in the backup file.
			// RESTORE.EPP makes this assumption in get_relation().

			if (put_blr_blob (att_relation_view_blr, /*X.RDB$VIEW_BLR*/
								 isc_152.isc_155))
				flags |= REL_view;
			if (/*X.RDB$SYSTEM_FLAG*/
			    isc_152.isc_159)
				put_numeric (att_relation_system_flag, /*X.RDB$SYSTEM_FLAG*/
								       isc_152.isc_159);
			if (tdgbl->BCK_capabilities & BCK_ods8)
			{
				/*FOR (REQUEST_HANDLE req_handle2)
					R IN RDB$RELATIONS WITH R.RDB$RELATION_NAME = X.RDB$RELATION_NAME*/
				{
                                if (!req_handle2)
                                   isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &req_handle2, (short) sizeof(isc_144), (char*) isc_144);
				isc_vtov ((const char*) isc_152.isc_156, (char*) isc_145.isc_146, 32);
				if (req_handle2)
				   {
                                   isc_start_and_send (isc_status, (FB_API_HANDLE*) &req_handle2, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 32, &isc_145, (short) 0);
				   }
				if (!isc_status [1]) {
				while (1)
				   {
                                   isc_receive (isc_status, (FB_API_HANDLE*) &req_handle2, (short) 1, (short) 6, &isc_147, (short) 0);
				   if (!isc_147.isc_148 || isc_status [1]) break;
					if (!/*R.RDB$FLAGS.NULL*/
					     isc_147.isc_149)
						put_numeric (att_relation_flags, /*R.RDB$FLAGS*/
										 isc_147.isc_150);
				/*END_FOR;*/
				   }
				   };
				/*ON_ERROR*/
				if (isc_status [1])
				   {
					general_on_error();
				/*END_ERROR;*/
				   }
				}
			}
			if (tdgbl->BCK_capabilities & BCK_security)
			{
				/*FOR (REQUEST_HANDLE req_handle3)
					R IN RDB$RELATIONS WITH R.RDB$RELATION_NAME = X.RDB$RELATION_NAME*/
				{
                                if (!req_handle3)
                                   isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &req_handle3, (short) sizeof(isc_137), (char*) isc_137);
				isc_vtov ((const char*) isc_152.isc_156, (char*) isc_138.isc_139, 32);
				if (req_handle3)
				   {
                                   isc_start_and_send (isc_status, (FB_API_HANDLE*) &req_handle3, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 32, &isc_138, (short) 0);
				   }
				if (!isc_status [1]) {
				while (1)
				   {
                                   isc_receive (isc_status, (FB_API_HANDLE*) &req_handle3, (short) 1, (short) 36, &isc_140, (short) 0);
				   if (!isc_140.isc_142 || isc_status [1]) break;
					if (!/*R.RDB$SECURITY_CLASS.NULL*/
					     isc_140.isc_143)
						PUT_TEXT(att_relation_security_class, /*R.RDB$SECURITY_CLASS*/
										      isc_140.isc_141);
				/*END_FOR;*/
				   }
				   };
				/*ON_ERROR*/
				if (isc_status [1])
				   {
					general_on_error();
				/*END_ERROR;*/
				   }
				}
			}
			put_source_blob (att_relation_description2, att_relation_description, /*X.RDB$DESCRIPTION*/
											      isc_152.isc_154);
			put_source_blob (att_relation_view_source2, att_relation_view_source, /*X.RDB$VIEW_SOURCE*/
											      isc_152.isc_153);
			if (tdgbl->BCK_capabilities & BCK_attributes_v3)
			{
				/*FOR (REQUEST_HANDLE req_handle4)
					R IN RDB$RELATIONS WITH R.RDB$RELATION_NAME = X.RDB$RELATION_NAME*/
				{
                                if (!req_handle4)
                                   isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &req_handle4, (short) sizeof(isc_128), (char*) isc_128);
				isc_vtov ((const char*) isc_152.isc_156, (char*) isc_129.isc_130, 32);
				if (req_handle4)
				   {
                                   isc_start_and_send (isc_status, (FB_API_HANDLE*) &req_handle4, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 32, &isc_129, (short) 0);
				   }
				if (!isc_status [1]) {
				while (1)
				   {
                                   isc_receive (isc_status, (FB_API_HANDLE*) &req_handle4, (short) 1, (short) 300, &isc_131, (short) 0);
				   if (!isc_131.isc_135 || isc_status [1]) break;
					put_source_blob(att_relation_ext_description2, att_relation_ext_description,
									/*R.RDB$EXTERNAL_DESCRIPTION*/
									isc_131.isc_134);
					PUT_TEXT(att_relation_owner_name, /*R.RDB$OWNER_NAME*/
									  isc_131.isc_133);
					if (!/*R.RDB$EXTERNAL_FILE.NULL*/
					     isc_131.isc_136)
					{
						if (!tdgbl->gbl_sw_convert_ext_tables)
						{
							PUT_TEXT(att_relation_ext_file_name, /*R.RDB$EXTERNAL_FILE*/
											     isc_131.isc_132);
							flags |= REL_external;
						}
					}
				/*END_FOR;*/
				   }
				   };
				/*ON_ERROR*/
				if (isc_status [1])
				   {
					general_on_error();
				/*END_ERROR;*/
				   }
				}
			}
			if (tdgbl->BCK_capabilities & BCK_ods11_1)
			{
				/*FOR (REQUEST_HANDLE req_handle5)
					R IN RDB$RELATIONS WITH R.RDB$RELATION_NAME = X.RDB$RELATION_NAME*/
				{
                                if (!req_handle5)
                                   isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &req_handle5, (short) sizeof(isc_121), (char*) isc_121);
				isc_vtov ((const char*) isc_152.isc_156, (char*) isc_122.isc_123, 32);
				if (req_handle5)
				   {
                                   isc_start_and_send (isc_status, (FB_API_HANDLE*) &req_handle5, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 32, &isc_122, (short) 0);
				   }
				if (!isc_status [1]) {
				while (1)
				   {
                                   isc_receive (isc_status, (FB_API_HANDLE*) &req_handle5, (short) 1, (short) 6, &isc_124, (short) 0);
				   if (!isc_124.isc_125 || isc_status [1]) break;
					if (!/*R.RDB$RELATION_TYPE.NULL*/
					     isc_124.isc_126)
						put_numeric (att_relation_type, /*R.RDB$RELATION_TYPE*/
										isc_124.isc_127);
				/*END_FOR;*/
				   }
				   };
				/*ON_ERROR*/
				if (isc_status [1])
				   {
					general_on_error();
				/*END_ERROR;*/
				   }
				}
			}
			put(tdgbl, att_end);
			burp_rel* relation = (burp_rel*) BURP_alloc_zero (sizeof(burp_rel));
			relation->rel_next = tdgbl->relations;
			tdgbl->relations = relation;
			relation->rel_id = /*X.RDB$RELATION_ID*/
					   isc_152.isc_158;
			relation->rel_name_length = COPY(/*X.RDB$RELATION_NAME*/
							 isc_152.isc_156, relation->rel_name);
			relation->rel_flags |= flags;
			put_relation (relation);
		/*END_FOR;*/
		   }
		   };
		/*ON_ERROR*/
		if (isc_status [1])
		   {
			general_on_error();
		/*END_ERROR;*/
		   }
		}
	}

	MISC_release_request_silent(req_handle1);
	MISC_release_request_silent(req_handle2);
	MISC_release_request_silent(req_handle3);
	MISC_release_request_silent(req_handle4);
	MISC_release_request_silent(req_handle5);
}


void write_shadow_files()
{
   struct isc_113_struct {
          char  isc_114 [256];	/* RDB$FILE_NAME */
          ISC_LONG isc_115;	/* RDB$FILE_LENGTH */
          ISC_LONG isc_116;	/* RDB$FILE_START */
          short isc_117;	/* isc_utility */
          short isc_118;	/* RDB$SHADOW_NUMBER */
          short isc_119;	/* RDB$FILE_FLAGS */
          short isc_120;	/* RDB$FILE_SEQUENCE */
   } isc_113;
/**************************************
 *
 *	w r i t e _ s h a d o w _ f i l e s
 *
 **************************************
 *
 * Functional description
 *	Write out files to use as shadows.
 *
 **************************************/
	TEXT temp[GDS_NAME_LEN];
	isc_req_handle req_handle1 = 0;

	BurpGlobals* tdgbl = BurpGlobals::getSpecific();

	/*FOR (REQUEST_HANDLE req_handle1)
		X IN RDB$FILES
		WITH X.RDB$SHADOW_NUMBER NOT MISSING
		AND X.RDB$SHADOW_NUMBER NE 0*/
	{
        if (!req_handle1)
           isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &req_handle1, (short) sizeof(isc_112), (char*) isc_112);
	if (req_handle1)
	   {
           isc_start_request (isc_status, (FB_API_HANDLE*) &req_handle1, (FB_API_HANDLE*) &gds_trans, (short) 0);
	   }
	if (!isc_status [1]) {
	while (1)
	   {
           isc_receive (isc_status, (FB_API_HANDLE*) &req_handle1, (short) 0, (short) 272, &isc_113, (short) 0);
	   if (!isc_113.isc_117 || isc_status [1]) break;
		put(tdgbl, rec_files);
		const SSHORT l = PUT_TEXT (att_file_filename, /*X.RDB$FILE_NAME*/
							      isc_113.isc_114);
		MISC_terminate (/*X.RDB$FILE_NAME*/
				isc_113.isc_114, temp, l, sizeof(temp));
		BURP_verbose (163, temp);
		// msg 163 writing shadow file %s
		put_numeric (att_file_sequence, /*X.RDB$FILE_SEQUENCE*/
						isc_113.isc_120);
		put_numeric (att_file_start, /*X.RDB$FILE_START*/
					     isc_113.isc_116);
		put_numeric (att_file_length, /*X.RDB$FILE_LENGTH*/
					      isc_113.isc_115);
		put_numeric (att_file_flags, /*X.RDB$FILE_FLAGS*/
					     isc_113.isc_119);
		put_numeric (att_shadow_number, /*X.RDB$SHADOW_NUMBER*/
						isc_113.isc_118);
		put(tdgbl, att_end);
	/*END_FOR;*/
	   }
	   };
	/*ON_ERROR*/
	if (isc_status [1])
	   {
		general_on_error();
	/*END_ERROR;*/
	   }
	}

	MISC_release_request_silent(req_handle1);
}

void write_sql_roles()
{
   struct isc_101_struct {
          char  isc_102 [32];	/* RDB$OWNER_NAME */
          char  isc_103 [32];	/* RDB$ROLE_NAME */
          short isc_104;	/* isc_utility */
   } isc_101;
   struct isc_106_struct {
          ISC_QUAD isc_107;	/* RDB$DESCRIPTION */
          char  isc_108 [32];	/* RDB$OWNER_NAME */
          char  isc_109 [32];	/* RDB$ROLE_NAME */
          short isc_110;	/* isc_utility */
          short isc_111;	/* gds__null_flag */
   } isc_106;
/**************************************
 *
 *	w r i t e _ s q l _ r o l e s
 *
 **************************************
 *
 * Functional description
 * 	write a record in the burp file for
 *	each SQL roles.
 *
 **************************************/
	isc_req_handle req_handle1 = 0;
	TEXT temp[GDS_NAME_LEN];

	BurpGlobals* tdgbl = BurpGlobals::getSpecific();

	if (tdgbl->BCK_capabilities & BCK_ods11)
	{
		/*FOR (REQUEST_HANDLE req_handle1)
			X IN RDB$ROLES
			WITH X.RDB$SYSTEM_FLAG EQ 0 OR X.RDB$SYSTEM_FLAG MISSING*/
		{
                if (!req_handle1)
                   isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &req_handle1, (short) sizeof(isc_105), (char*) isc_105);
		if (req_handle1)
		   {
                   isc_start_request (isc_status, (FB_API_HANDLE*) &req_handle1, (FB_API_HANDLE*) &gds_trans, (short) 0);
		   }
		if (!isc_status [1]) {
		while (1)
		   {
                   isc_receive (isc_status, (FB_API_HANDLE*) &req_handle1, (short) 0, (short) 76, &isc_106, (short) 0);
		   if (!isc_106.isc_110 || isc_status [1]) break;

			put(tdgbl, rec_sql_roles);
			const SSHORT l = PUT_TEXT(att_role_name, /*X.RDB$ROLE_NAME*/
								 isc_106.isc_109);
			PUT_TEXT (att_role_owner_name, /*X.RDB$OWNER_NAME*/
						       isc_106.isc_108);
			if (!/*X.RDB$DESCRIPTION.NULL*/
			     isc_106.isc_111) {
				put_source_blob (att_role_description, att_role_description, /*X.RDB$DESCRIPTION*/
											     isc_106.isc_107);
			}
			put(tdgbl, att_end);
			MISC_terminate (/*X.RDB$ROLE_NAME*/
					isc_106.isc_109, temp, l, sizeof(temp));
			BURP_verbose (249, temp);
			// msg 249 writing SQL role: %s

		/*END_FOR;*/
		   }
		   };
		/*ON_ERROR*/
		if (isc_status [1])
		   {
			general_on_error();
		/*END_ERROR;*/
		   }
		}
	}
	else
	{
		/*FOR (REQUEST_HANDLE req_handle1)
			X IN RDB$ROLES*/
		{
                if (!req_handle1)
                   isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &req_handle1, (short) sizeof(isc_100), (char*) isc_100);
		if (req_handle1)
		   {
                   isc_start_request (isc_status, (FB_API_HANDLE*) &req_handle1, (FB_API_HANDLE*) &gds_trans, (short) 0);
		   }
		if (!isc_status [1]) {
		while (1)
		   {
                   isc_receive (isc_status, (FB_API_HANDLE*) &req_handle1, (short) 0, (short) 66, &isc_101, (short) 0);
		   if (!isc_101.isc_104 || isc_status [1]) break;

			put(tdgbl, rec_sql_roles);
			const SSHORT l = PUT_TEXT(att_role_name, /*X.RDB$ROLE_NAME*/
								 isc_101.isc_103);
			PUT_TEXT (att_role_owner_name, /*X.RDB$OWNER_NAME*/
						       isc_101.isc_102);
			put(tdgbl, att_end);
			MISC_terminate (/*X.RDB$ROLE_NAME*/
					isc_101.isc_103, temp, l, sizeof(temp));
			BURP_verbose (249, temp);
			// msg 249 writing SQL role: %s

		/*END_FOR;*/
		   }
		   };
		/*ON_ERROR*/
		if (isc_status [1])
		   {
			general_on_error();
		/*END_ERROR;*/
		   }
		}
	}

	MISC_release_request_silent(req_handle1);
}

void write_mapping()
{
   struct isc_97_struct {
          short isc_98;	/* isc_utility */
          short isc_99;	/* RDB$SYSTEM_FLAG */
   } isc_97;
   struct isc_95_struct {
          char  isc_96 [32];	/* RDB$ROLE_NAME */
   } isc_95;
/**************************************
 *
 *	w r i t e _ m a p p i n g
 *
 **************************************
 *
 * Functional description
 * 	write a record in the burp file for
 *	each names mapping.
 *
 **************************************/
	isc_req_handle req_handle = 0;

	BurpGlobals* tdgbl = BurpGlobals::getSpecific();

	if (tdgbl->BCK_capabilities & BCK_ods11_2)
	{
		/*FOR (REQUEST_HANDLE req_handle)
			X IN RDB$ROLES
			WITH X.RDB$ROLE_NAME EQ ADMIN_ROLE*/
		{
                if (!req_handle)
                   isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &req_handle, (short) sizeof(isc_94), (char*) isc_94);
		isc_vtov ((const char*) ADMIN_ROLE, (char*) isc_95.isc_96, 32);
		if (req_handle)
		   {
                   isc_start_and_send (isc_status, (FB_API_HANDLE*) &req_handle, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 32, &isc_95, (short) 0);
		   }
		if (!isc_status [1]) {
		while (1)
		   {
                   isc_receive (isc_status, (FB_API_HANDLE*) &req_handle, (short) 1, (short) 4, &isc_97, (short) 0);
		   if (!isc_97.isc_98 || isc_status [1]) break;

			if (/*X.RDB$SYSTEM_FLAG*/
			    isc_97.isc_99 == (ROLE_FLAG_MAY_TRUST | ROLE_FLAG_DBO))
			{
				put(tdgbl, rec_mapping);
				//put_text(att_map_os, DOMAIN-ADMINS, strlen(DOMAIN-ADMINS) + 1);
				//put_text(att_map_role, ADMIN-ROLE, strlen(ADMIN-ROLE) + 1);
				put_text(att_auto_map_role, ADMIN_ROLE, strlen(ADMIN_ROLE) + 1);
				put(tdgbl, att_end);
				BURP_verbose (297, ADMIN_ROLE);
				// msg 297 writing mapping for @1
			}

		/*END_FOR;*/
		   }
		   };
		/*ON_ERROR*/
		if (isc_status [1])
		   {
			general_on_error();
		/*END_ERROR;*/
		   }
		}
	}

	MISC_release_request_silent(req_handle);
}

void write_triggers()
{
   struct isc_43_struct {
          short isc_44;	/* isc_utility */
          short isc_45;	/* gds__null_flag */
          short isc_46;	/* RDB$FLAGS */
   } isc_43;
   struct isc_41_struct {
          char  isc_42 [32];	/* RDB$TRIGGER_NAME */
   } isc_41;
   struct isc_48_struct {
          ISC_QUAD isc_49;	/* RDB$DESCRIPTION */
          ISC_QUAD isc_50;	/* RDB$TRIGGER_SOURCE */
          ISC_QUAD isc_51;	/* RDB$TRIGGER_BLR */
          char  isc_52 [32];	/* RDB$RELATION_NAME */
          char  isc_53 [32];	/* RDB$TRIGGER_NAME */
          short isc_54;	/* isc_utility */
          short isc_55;	/* RDB$TRIGGER_INACTIVE */
          short isc_56;	/* RDB$SYSTEM_FLAG */
          short isc_57;	/* RDB$TRIGGER_TYPE */
          short isc_58;	/* RDB$TRIGGER_SEQUENCE */
          short isc_59;	/* gds__null_flag */
   } isc_48;
   struct isc_61_struct {
          ISC_QUAD isc_62;	/* RDB$DESCRIPTION */
          ISC_QUAD isc_63;	/* RDB$TRIGGER_SOURCE */
          ISC_QUAD isc_64;	/* RDB$TRIGGER_BLR */
          char  isc_65 [32];	/* RDB$RELATION_NAME */
          char  isc_66 [32];	/* RDB$TRIGGER_NAME */
          short isc_67;	/* isc_utility */
          short isc_68;	/* gds__null_flag */
          short isc_69;	/* RDB$FLAGS */
          short isc_70;	/* RDB$TRIGGER_INACTIVE */
          short isc_71;	/* RDB$SYSTEM_FLAG */
          short isc_72;	/* RDB$TRIGGER_TYPE */
          short isc_73;	/* RDB$TRIGGER_SEQUENCE */
          short isc_74;	/* gds__null_flag */
   } isc_61;
   struct isc_76_struct {
          ISC_QUAD isc_77;	/* RDB$DEBUG_INFO */
          ISC_QUAD isc_78;	/* RDB$DESCRIPTION */
          ISC_QUAD isc_79;	/* RDB$TRIGGER_SOURCE */
          ISC_QUAD isc_80;	/* RDB$TRIGGER_BLR */
          char  isc_81 [32];	/* RDB$RELATION_NAME */
          char  isc_82 [32];	/* RDB$TRIGGER_NAME */
          short isc_83;	/* isc_utility */
          short isc_84;	/* gds__null_flag */
          short isc_85;	/* gds__null_flag */
          short isc_86;	/* RDB$VALID_BLR */
          short isc_87;	/* gds__null_flag */
          short isc_88;	/* RDB$FLAGS */
          short isc_89;	/* RDB$TRIGGER_INACTIVE */
          short isc_90;	/* RDB$SYSTEM_FLAG */
          short isc_91;	/* RDB$TRIGGER_TYPE */
          short isc_92;	/* RDB$TRIGGER_SEQUENCE */
          short isc_93;	/* gds__null_flag */
   } isc_76;
/**************************************
 *
 *	w r i t e _ t r i g g e r s
 *
 **************************************
 *
 * Functional description
 * 	write the triggers in rdb$triggers
 *
 **************************************/
	TEXT temp[GDS_NAME_LEN];
	isc_req_handle req_handle1 = 0, req_handle2 = 0;

	BurpGlobals* tdgbl = BurpGlobals::getSpecific();

	// if we have all capabilities, use the first request to get the
	// most performance out of the latest engine; if we don't
	// have one of the capabilities we must use the second set of
	// requests--this requires more code but it is well worth it
	// for the performance benefits, especially remotely--deej

	if (tdgbl->BCK_capabilities & BCK_ods11_1)
	{
		/*FOR (REQUEST_HANDLE req_handle1)
			X IN RDB$TRIGGERS WITH
			X.RDB$SYSTEM_FLAG NE 1 OR
			X.RDB$SYSTEM_FLAG MISSING*/
		{
                if (!req_handle1)
                   isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &req_handle1, (short) sizeof(isc_75), (char*) isc_75);
		if (req_handle1)
		   {
                   isc_start_request (isc_status, (FB_API_HANDLE*) &req_handle1, (FB_API_HANDLE*) &gds_trans, (short) 0);
		   }
		if (!isc_status [1]) {
		while (1)
		   {
                   isc_receive (isc_status, (FB_API_HANDLE*) &req_handle1, (short) 0, (short) 118, &isc_76, (short) 0);
		   if (!isc_76.isc_83 || isc_status [1]) break;

			put(tdgbl, rec_trigger);
			const SSHORT l = PUT_TEXT (att_trig_name, /*X.RDB$TRIGGER_NAME*/
								  isc_76.isc_82);
			MISC_terminate (/*X.RDB$TRIGGER_NAME*/
					isc_76.isc_82, temp, l, sizeof(temp));
			BURP_verbose (156, temp);
			// msg 156   writing trigger %s

			if (!/*X.RDB$RELATION_NAME.NULL*/
			     isc_76.isc_93)
				PUT_TEXT (att_trig_relation_name, /*X.RDB$RELATION_NAME*/
								  isc_76.isc_81);

			put_numeric (att_trig_sequence, /*X.RDB$TRIGGER_SEQUENCE*/
							isc_76.isc_92);
			put_numeric (att_trig_type, /*X.RDB$TRIGGER_TYPE*/
						    isc_76.isc_91);
			put_blr_blob (att_trig_blr, /*X.RDB$TRIGGER_BLR*/
						    isc_76.isc_80);
			put_source_blob (att_trig_source2, att_trig_source, /*X.RDB$TRIGGER_SOURCE*/
									    isc_76.isc_79);
			put_source_blob (att_trig_description2, att_trig_description, /*X.RDB$DESCRIPTION*/
										      isc_76.isc_78);
			put_numeric (att_trig_system_flag, /*X.RDB$SYSTEM_FLAG*/
							   isc_76.isc_90);
			put_numeric (att_trig_inactive, /*X.RDB$TRIGGER_INACTIVE*/
							isc_76.isc_89);

			if (!/*X.RDB$FLAGS.NULL*/
			     isc_76.isc_87)
				put_numeric (att_trig_flags, /*X.RDB$FLAGS*/
							     isc_76.isc_88);

			if (!/*X.RDB$VALID_BLR.NULL*/
			     isc_76.isc_85)
				put_numeric (att_trig_valid_blr, /*X.RDB$VALID_BLR*/
								 isc_76.isc_86);

			if (!/*X.RDB$DEBUG_INFO.NULL*/
			     isc_76.isc_84)
				put_blr_blob (att_trig_debug_info, /*X.RDB$DEBUG_INFO*/
								   isc_76.isc_77);

			put(tdgbl, att_end);

		/*END_FOR;*/
		   }
		   };
		/*ON_ERROR*/
		if (isc_status [1])
		   {
			general_on_error();
		/*END_ERROR;*/
		   }
		}
	}
	else if (tdgbl->BCK_capabilities & BCK_ods8)
	{
		/*FOR (REQUEST_HANDLE req_handle1)
			X IN RDB$TRIGGERS WITH
			X.RDB$SYSTEM_FLAG NE 1 OR
			X.RDB$SYSTEM_FLAG MISSING*/
		{
                if (!req_handle1)
                   isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &req_handle1, (short) sizeof(isc_60), (char*) isc_60);
		if (req_handle1)
		   {
                   isc_start_request (isc_status, (FB_API_HANDLE*) &req_handle1, (FB_API_HANDLE*) &gds_trans, (short) 0);
		   }
		if (!isc_status [1]) {
		while (1)
		   {
                   isc_receive (isc_status, (FB_API_HANDLE*) &req_handle1, (short) 0, (short) 104, &isc_61, (short) 0);
		   if (!isc_61.isc_67 || isc_status [1]) break;

			put(tdgbl, rec_trigger);
			const SSHORT l = PUT_TEXT (att_trig_name, /*X.RDB$TRIGGER_NAME*/
								  isc_61.isc_66);
			MISC_terminate (/*X.RDB$TRIGGER_NAME*/
					isc_61.isc_66, temp, l, sizeof(temp));
			BURP_verbose (156, temp);
			// msg 156   writing trigger %s

			if (!/*X.RDB$RELATION_NAME.NULL*/
			     isc_61.isc_74)
				PUT_TEXT (att_trig_relation_name, /*X.RDB$RELATION_NAME*/
								  isc_61.isc_65);

			put_numeric (att_trig_sequence, /*X.RDB$TRIGGER_SEQUENCE*/
							isc_61.isc_73);
			put_numeric (att_trig_type, /*X.RDB$TRIGGER_TYPE*/
						    isc_61.isc_72);
			put_blr_blob (att_trig_blr, /*X.RDB$TRIGGER_BLR*/
						    isc_61.isc_64);
			put_source_blob (att_trig_source2, att_trig_source, /*X.RDB$TRIGGER_SOURCE*/
									    isc_61.isc_63);
			put_source_blob (att_trig_description2, att_trig_description, /*X.RDB$DESCRIPTION*/
										      isc_61.isc_62);
			put_numeric (att_trig_system_flag, /*X.RDB$SYSTEM_FLAG*/
							   isc_61.isc_71);
			put_numeric (att_trig_inactive, /*X.RDB$TRIGGER_INACTIVE*/
							isc_61.isc_70);

			if (!/*X.RDB$FLAGS.NULL*/
			     isc_61.isc_68)
				put_numeric (att_trig_flags, /*X.RDB$FLAGS*/
							     isc_61.isc_69);

			put(tdgbl, att_end);

		/*END_FOR;*/
		   }
		   };
		/*ON_ERROR*/
		if (isc_status [1])
		   {
			general_on_error();
		/*END_ERROR;*/
		   }
		}
	}
	else
	{
		/*FOR (REQUEST_HANDLE req_handle1)
			X IN RDB$TRIGGERS WITH
			X.RDB$SYSTEM_FLAG NE 1 OR
			X.RDB$SYSTEM_FLAG MISSING*/
		{
                if (!req_handle1)
                   isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &req_handle1, (short) sizeof(isc_47), (char*) isc_47);
		if (req_handle1)
		   {
                   isc_start_request (isc_status, (FB_API_HANDLE*) &req_handle1, (FB_API_HANDLE*) &gds_trans, (short) 0);
		   }
		if (!isc_status [1]) {
		while (1)
		   {
                   isc_receive (isc_status, (FB_API_HANDLE*) &req_handle1, (short) 0, (short) 100, &isc_48, (short) 0);
		   if (!isc_48.isc_54 || isc_status [1]) break;

			put(tdgbl, rec_trigger);
			const SSHORT l = PUT_TEXT (att_trig_name, /*X.RDB$TRIGGER_NAME*/
								  isc_48.isc_53);
			MISC_terminate (/*X.RDB$TRIGGER_NAME*/
					isc_48.isc_53, temp, l, sizeof(temp));
			BURP_verbose (156, temp);
			// msg 156   writing trigger %s

			if (!/*X.RDB$RELATION_NAME.NULL*/
			     isc_48.isc_59)
				PUT_TEXT (att_trig_relation_name, /*X.RDB$RELATION_NAME*/
								  isc_48.isc_52);

			put_numeric (att_trig_sequence, /*X.RDB$TRIGGER_SEQUENCE*/
							isc_48.isc_58);
			put_numeric (att_trig_type, /*X.RDB$TRIGGER_TYPE*/
						    isc_48.isc_57);
			put_blr_blob (att_trig_blr, /*X.RDB$TRIGGER_BLR*/
						    isc_48.isc_51);
			put_source_blob (att_trig_source2, att_trig_source, /*X.RDB$TRIGGER_SOURCE*/
									    isc_48.isc_50);
			put_source_blob (att_trig_description2, att_trig_description, /*X.RDB$DESCRIPTION*/
										      isc_48.isc_49);
			put_numeric (att_trig_system_flag, /*X.RDB$SYSTEM_FLAG*/
							   isc_48.isc_56);
			put_numeric (att_trig_inactive, /*X.RDB$TRIGGER_INACTIVE*/
							isc_48.isc_55);

			if (tdgbl->BCK_capabilities & BCK_ods8)
			{
				/*FOR (REQUEST_HANDLE req_handle2)
					Y IN RDB$TRIGGERS WITH
					X.RDB$TRIGGER_NAME = Y.RDB$TRIGGER_NAME*/
				{
                                if (!req_handle2)
                                   isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &req_handle2, (short) sizeof(isc_40), (char*) isc_40);
				isc_vtov ((const char*) isc_48.isc_53, (char*) isc_41.isc_42, 32);
				if (req_handle2)
				   {
                                   isc_start_and_send (isc_status, (FB_API_HANDLE*) &req_handle2, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 32, &isc_41, (short) 0);
				   }
				if (!isc_status [1]) {
				while (1)
				   {
                                   isc_receive (isc_status, (FB_API_HANDLE*) &req_handle2, (short) 1, (short) 6, &isc_43, (short) 0);
				   if (!isc_43.isc_44 || isc_status [1]) break;

					if (!/*Y.RDB$FLAGS.NULL*/
					     isc_43.isc_45)
						put_numeric (att_trig_flags, /*Y.RDB$FLAGS*/
									     isc_43.isc_46);

				/*END_FOR;*/
				   }
				   };
				/*ON_ERROR*/
				if (isc_status [1])
				   {
					general_on_error();
				/*END_ERROR;*/
				   }
				}
			}

			put(tdgbl, att_end);

		/*END_FOR;*/
		   }
		   };
		/*ON_ERROR*/
		if (isc_status [1])
		   {
			general_on_error();
		/*END_ERROR;*/
		   }
		}
	}

	MISC_release_request_silent(req_handle1);
	MISC_release_request_silent(req_handle2);
}


void write_trigger_messages()
{
   struct isc_35_struct {
          char  isc_36 [1024];	/* RDB$MESSAGE */
          char  isc_37 [32];	/* RDB$TRIGGER_NAME */
          short isc_38;	/* isc_utility */
          short isc_39;	/* RDB$MESSAGE_NUMBER */
   } isc_35;
/**************************************
 *
 *	w r i t e _ t r i g g e r _ m e s s a g e s
 *
 **************************************
 *
 * Functional description
 * 	write a record in the burp file for
 *	each trigger message.
 *
 **************************************/
	TEXT temp[GDS_NAME_LEN];
	isc_req_handle req_handle1 = 0;

	BurpGlobals* tdgbl = BurpGlobals::getSpecific();

	/*FOR (REQUEST_HANDLE req_handle1)
		T IN RDB$TRIGGERS CROSS X IN RDB$TRIGGER_MESSAGES
		OVER RDB$TRIGGER_NAME
		WITH T.RDB$SYSTEM_FLAG NE 1 OR T.RDB$SYSTEM_FLAG MISSING*/
	{
        if (!req_handle1)
           isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &req_handle1, (short) sizeof(isc_34), (char*) isc_34);
	if (req_handle1)
	   {
           isc_start_request (isc_status, (FB_API_HANDLE*) &req_handle1, (FB_API_HANDLE*) &gds_trans, (short) 0);
	   }
	if (!isc_status [1]) {
	while (1)
	   {
           isc_receive (isc_status, (FB_API_HANDLE*) &req_handle1, (short) 0, (short) 1060, &isc_35, (short) 0);
	   if (!isc_35.isc_38 || isc_status [1]) break;;

		put(tdgbl, rec_trigger_message);
		const SSHORT l = PUT_TEXT (att_trigmsg_name, /*X.RDB$TRIGGER_NAME*/
							     isc_35.isc_37);
		MISC_terminate (/*X.RDB$TRIGGER_NAME*/
				isc_35.isc_37, temp, l, sizeof(temp));
		BURP_verbose (157, temp);
		// msg 157 writing trigger message for *s
		put_numeric (att_trigmsg_number, /*X.RDB$MESSAGE_NUMBER*/
						 isc_35.isc_39);
		PUT_MESSAGE (att_trigmsg_text, att_end, /*X.RDB$MESSAGE*/
							isc_35.isc_36);
		put(tdgbl, att_end);
	/*END_FOR;*/
	   }
	   };
	/*ON_ERROR*/
	if (isc_status [1])
	   {
		general_on_error();
	/*END_ERROR;*/
	   }
	}

	MISC_release_request_silent(req_handle1);
}

void write_types()
{
   struct isc_27_struct {
          ISC_QUAD isc_28;	/* RDB$DESCRIPTION */
          char  isc_29 [32];	/* RDB$FIELD_NAME */
          char  isc_30 [32];	/* RDB$TYPE_NAME */
          short isc_31;	/* isc_utility */
          short isc_32;	/* RDB$SYSTEM_FLAG */
          short isc_33;	/* RDB$TYPE */
   } isc_27;
/**************************************
 *
 *	w r i t e _ t y p e s
 *
 **************************************
 *
 * Functional description
 * 	write a record in the burp file for
 *	each type.
 *
 **************************************/
	isc_req_handle req_handle1 = 0;

	BurpGlobals* tdgbl = BurpGlobals::getSpecific();

	/*FOR (REQUEST_HANDLE req_handle1)
		X IN RDB$TYPES WITH X.RDB$SYSTEM_FLAG NE 1 OR
		X.RDB$SYSTEM_FLAG MISSING*/
	{
        if (!req_handle1)
           isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &req_handle1, (short) sizeof(isc_26), (char*) isc_26);
	if (req_handle1)
	   {
           isc_start_request (isc_status, (FB_API_HANDLE*) &req_handle1, (FB_API_HANDLE*) &gds_trans, (short) 0);
	   }
	if (!isc_status [1]) {
	while (1)
	   {
           isc_receive (isc_status, (FB_API_HANDLE*) &req_handle1, (short) 0, (short) 78, &isc_27, (short) 0);
	   if (!isc_27.isc_31 || isc_status [1]) break;
		put(tdgbl, rec_system_type);
		PUT_TEXT (att_type_name, /*X.RDB$TYPE_NAME*/
					 isc_27.isc_30);
		PUT_TEXT (att_type_field_name, /*X.RDB$FIELD_NAME*/
					       isc_27.isc_29);
		BURP_verbose (160, SafeArg() << /*X.RDB$TYPE_NAME*/
						isc_27.isc_30 << /*X.RDB$FIELD_NAME*/
    isc_27.isc_29);
		// msg 160 writing type %s for field %s
		put_numeric (att_type_type, /*X.RDB$TYPE*/
					    isc_27.isc_33);
		put_source_blob (att_type_description2, att_type_description, /*X.RDB$DESCRIPTION*/
									      isc_27.isc_28);
		if (/*X.RDB$SYSTEM_FLAG*/
		    isc_27.isc_32)
			put_numeric (att_type_system_flag, /*X.RDB$SYSTEM_FLAG*/
							   isc_27.isc_32);
		put(tdgbl, att_end);
	/*END_FOR;*/
	   }
	   };
	/*ON_ERROR*/
	if (isc_status [1])
	   {
		general_on_error();
	/*END_ERROR;*/
	   }
	}

	MISC_release_request_silent(req_handle1);
}


void write_user_privileges()
{
   struct isc_5_struct {
          char  isc_6 [32];	/* RDB$FIELD_NAME */
          char  isc_7 [32];	/* RDB$RELATION_NAME */
          char  isc_8 [32];	/* RDB$GRANTOR */
          char  isc_9 [32];	/* RDB$USER */
          short isc_10;	/* isc_utility */
          short isc_11;	/* gds__null_flag */
          short isc_12;	/* RDB$GRANT_OPTION */
          char  isc_13 [7];	/* RDB$PRIVILEGE */
   } isc_5;
   struct isc_15_struct {
          char  isc_16 [32];	/* RDB$FIELD_NAME */
          char  isc_17 [32];	/* RDB$RELATION_NAME */
          char  isc_18 [32];	/* RDB$GRANTOR */
          char  isc_19 [32];	/* RDB$USER */
          short isc_20;	/* isc_utility */
          short isc_21;	/* RDB$OBJECT_TYPE */
          short isc_22;	/* RDB$USER_TYPE */
          short isc_23;	/* gds__null_flag */
          short isc_24;	/* RDB$GRANT_OPTION */
          char  isc_25 [7];	/* RDB$PRIVILEGE */
   } isc_15;
/**************************************
 *
 *	w r i t e _ u s e r _ p r i v i l e g e s
 *
 **************************************
 *
 * Functional description
 * 	write a record in the burp file for
 *	each user privilege.
 *
 **************************************/
	TEXT temp[GDS_NAME_LEN];
	isc_req_handle req_handle1 = 0;

	BurpGlobals* tdgbl = BurpGlobals::getSpecific();

	if (tdgbl->BCK_capabilities & BCK_ods8)
	{
		/*FOR (REQUEST_HANDLE req_handle1)
			X IN RDB$USER_PRIVILEGES*/
		{
                if (!req_handle1)
                   isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &req_handle1, (short) sizeof(isc_14), (char*) isc_14);
		if (req_handle1)
		   {
                   isc_start_request (isc_status, (FB_API_HANDLE*) &req_handle1, (FB_API_HANDLE*) &gds_trans, (short) 0);
		   }
		if (!isc_status [1]) {
		while (1)
		   {
                   isc_receive (isc_status, (FB_API_HANDLE*) &req_handle1, (short) 0, (short) 145, &isc_15, (short) 0);
		   if (!isc_15.isc_20 || isc_status [1]) break;
			put(tdgbl, rec_user_privilege);
			const SSHORT l = PUT_TEXT (att_priv_user, /*X.RDB$USER*/
								  isc_15.isc_19);
			MISC_terminate (/*X.RDB$USER*/
					isc_15.isc_19, temp, l, sizeof(temp));
			BURP_verbose (152, temp);
			// msg 152 writing privilege for user %s
			PUT_TEXT (att_priv_grantor, /*X.RDB$GRANTOR*/
						    isc_15.isc_18);
			PUT_TEXT (att_priv_privilege, /*X.RDB$PRIVILEGE*/
						      isc_15.isc_25);
			put_numeric (att_priv_grant_option, /*X.RDB$GRANT_OPTION*/
							    isc_15.isc_24);
			PUT_TEXT (att_priv_object_name, /*X.RDB$RELATION_NAME*/
							isc_15.isc_17);
			if (!/*X.RDB$FIELD_NAME.NULL*/
			     isc_15.isc_23)
			   PUT_TEXT (att_priv_field_name, /*X.RDB$FIELD_NAME*/
							  isc_15.isc_16);
			put_numeric (att_priv_user_type, /*X.RDB$USER_TYPE*/
							 isc_15.isc_22);
			put_numeric (att_priv_obj_type, /*X.RDB$OBJECT_TYPE*/
							isc_15.isc_21);
			put(tdgbl, att_end);
		/*END_FOR*/
		   }
		   };
		/*ON_ERROR*/
		if (isc_status [1])
		   {
			general_on_error();
		/*END_ERROR;*/
		   }
		}
	}
	else
	{
		/*FOR (REQUEST_HANDLE req_handle1)
			X IN RDB$USER_PRIVILEGES*/
		{
                if (!req_handle1)
                   isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &req_handle1, (short) sizeof(isc_4), (char*) isc_4);
		if (req_handle1)
		   {
                   isc_start_request (isc_status, (FB_API_HANDLE*) &req_handle1, (FB_API_HANDLE*) &gds_trans, (short) 0);
		   }
		if (!isc_status [1]) {
		while (1)
		   {
                   isc_receive (isc_status, (FB_API_HANDLE*) &req_handle1, (short) 0, (short) 141, &isc_5, (short) 0);
		   if (!isc_5.isc_10 || isc_status [1]) break;
			put(tdgbl, rec_user_privilege);
			const SSHORT l = PUT_TEXT (att_priv_user, /*X.RDB$USER*/
								  isc_5.isc_9);
			MISC_terminate (/*X.RDB$USER*/
					isc_5.isc_9, temp, l, sizeof(temp));
			BURP_verbose (152, temp);
			// msg 152 writing privilege for user %s
			PUT_TEXT (att_priv_grantor, /*X.RDB$GRANTOR*/
						    isc_5.isc_8);
			PUT_TEXT (att_priv_privilege, /*X.RDB$PRIVILEGE*/
						      isc_5.isc_13);
			put_numeric (att_priv_grant_option, /*X.RDB$GRANT_OPTION*/
							    isc_5.isc_12);
			PUT_TEXT (att_priv_object_name, /*X.RDB$RELATION_NAME*/
							isc_5.isc_7);
			if (!/*X.RDB$FIELD_NAME.NULL*/
			     isc_5.isc_11)
				PUT_TEXT (att_priv_field_name, /*X.RDB$FIELD_NAME*/
							       isc_5.isc_6);
			put(tdgbl, att_end);
		/*END_FOR;*/
		   }
		   };
		/*ON_ERROR*/
		if (isc_status [1])
		   {
			general_on_error();
		/*END_ERROR;*/
		   }
		}
	}

	MISC_release_request_silent(req_handle1);
}

} // namespace

