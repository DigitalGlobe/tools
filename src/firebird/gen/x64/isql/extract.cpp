/*********** Preprocessed module -- do not edit ***************/
/*********** Preprocessed module -- do not edit ***************/
/*********** Preprocessed module -- do not edit ***************/
/*********** Preprocessed module -- do not edit ***************/
/*********** Preprocessed module -- do not edit ***************/
/***************** gpre version WI-V2.5.7.27050 Firebird 2.5 **********************/
/*
 *	PROGRAM:	Interactive SQL utility
 *	MODULE:		extract.epp
 *	DESCRIPTION:	Definition extract routines
 *
 * The contents of this file are subject to the Interbase Public
 * License Version 1.0 (the "License"); you may not use this file
 * except in compliance with the License. You may obtain a copy
 * of the License at http://www.Inprise.com/IPL.html
 *
 * Software distributed under the License is distributed on an
 * "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * rights and limitations under the License.
 *
 * The Original Code was created by Inprise Corporation
 * and its predecessors. Portions created by Inprise Corporation are
 * Copyright (C) Inprise Corporation.
 *
 * All Rights Reserved.
 * Contributor(s): ______________________________________.
 * Revision 1.3  2000/11/22 17:07:25  patrickgriffin
 * In get_procedure_args change comment style from // to c style
 *
 * ...pat
 *
 * 2001.09.09 Claudio Valderrama: procedure's parameter names may need
 *   double quotes if they are in dialect 3 and have special characters.
 * 2001.09.21 Claudio Valderrama: Show correct mechanism for UDF parameters
 *   and support the RETURNS PARAMETER <n> syntax.
 * 2001.10.01 Claudio Valderrama: list_all_grants2() and EXTRACT_list_grants()
 *   to better organize the code that should be called to handle SHOW GRANTS.
 *
 * Revision 1.2  2000/11/18 16:49:24  fsg
 * Increased PRINT_BUFFER_LENGTH to 2048 to show larger plans
 * Fixed Bug #122563 in extract.e get_procedure_args
 * Apparently this has to be done in show.e also,
 * but that is for another day :-)
 *
 * 2003.02.04 Dmitry Yemanov: support for universal triggers
 */

#include "firebird.h"
#include <stdio.h>
#include <string.h>
#include <math.h>
#include <ctype.h>				// isdigit
#include "../jrd/common.h"
#include "../jrd/constants.h"
#include "../jrd/ibase.h"
#include "../jrd/gds_proto.h"
#include "../jrd/intlobj_new.h"
#include "../isql/isql.h"
#include "../isql/extra_proto.h"
#include "../isql/isql_proto.h"
#include "../isql/show_proto.h"
#include "../jrd/ini.h"
#include "../jrd/obj.h"
#include "../jrd/ods.h"
#include "../common/utils_proto.h"
#include "../jrd/constants.h"

using MsgFormat::SafeArg;


/*DATABASE DB = EXTERN COMPILETIME "yachts.lnk";*/
/**** GDS Preprocessor Definitions ****/
#ifndef JRD_IBASE_H
#include <ibase.h>
#endif

static const ISC_QUAD
   isc_blob_null = {0, 0};	/* initializer for blobs */
extern isc_db_handle
   DB;		/* database handle */

extern isc_tr_handle
   gds_trans;		/* default transaction handle */
extern ISC_STATUS
   isc_status [20],	/* status vector */
   isc_status2 [20];	/* status vector */
extern ISC_LONG
   isc_array_length, 	/* array return size */
   SQLCODE;		/* SQL status code */
static isc_req_handle
   isc_0 = 0;		/* request handle */

static const short
   isc_1l = 156;
static const char
   isc_1 [] = {
   4,2,4,1,2,0,41,3,0,32,0,7,0,4,0,1,0,41,3,0,32,0,12,0,2,7,'C',
   1,'J',19,'R','D','B','$','R','E','L','A','T','I','O','N','_',
   'F','I','E','L','D','S',0,'G',47,23,0,17,'R','D','B','$','R',
   'E','L','A','T','I','O','N','_','N','A','M','E',25,0,0,0,'F',
   1,'H',23,0,18,'R','D','B','$','F','I','E','L','D','_','P','O',
   'S','I','T','I','O','N',-1,14,1,2,1,23,0,14,'R','D','B','$',
   'F','I','E','L','D','_','N','A','M','E',25,1,0,0,1,21,8,0,1,
   0,0,0,25,1,1,0,-1,14,1,1,21,8,0,0,0,0,0,25,1,1,0,-1,-1,'L'
   };	/* end of blr string for request isc_1 */

static isc_req_handle
   isc_7 = 0;		/* request handle */

static const short
   isc_8l = 260;
static const char
   isc_8 [] = {
   4,2,4,1,5,0,9,0,41,3,0,32,0,41,3,0,32,0,7,0,7,0,4,0,1,0,7,0,
   12,0,2,7,'C',1,'J',13,'R','D','B','$','R','E','L','A','T','I',
   'O','N','S',0,'G',58,57,48,23,0,15,'R','D','B','$','S','Y','S',
   'T','E','M','_','F','L','A','G',21,8,0,1,0,0,0,61,23,0,15,'R',
   'D','B','$','S','Y','S','T','E','M','_','F','L','A','G',58,59,
   61,23,0,12,'R','D','B','$','V','I','E','W','_','B','L','R',47,
   23,0,9,'R','D','B','$','F','L','A','G','S',25,0,0,0,'F',1,'H',
   23,0,15,'R','D','B','$','R','E','L','A','T','I','O','N','_',
   'I','D',-1,14,1,2,1,23,0,15,'R','D','B','$','V','I','E','W',
   '_','S','O','U','R','C','E',41,1,0,0,4,0,1,23,0,14,'R','D','B',
   '$','O','W','N','E','R','_','N','A','M','E',25,1,1,0,1,23,0,
   17,'R','D','B','$','R','E','L','A','T','I','O','N','_','N','A',
   'M','E',25,1,2,0,1,21,8,0,1,0,0,0,25,1,3,0,-1,14,1,1,21,8,0,
   0,0,0,0,25,1,3,0,-1,-1,'L'
   };	/* end of blr string for request isc_8 */

static isc_req_handle
   isc_17 = 0;		/* request handle */

static const short
   isc_18l = 448;
static const char
   isc_18 [] = {
   4,2,4,0,9,0,9,0,9,0,41,3,0,32,0,41,3,0,32,0,7,0,7,0,7,0,7,0,
   7,0,2,7,'C',2,'J',11,'R','D','B','$','I','N','D','I','C','E',
   'S',0,'J',13,'R','D','B','$','R','E','L','A','T','I','O','N',
   'S',1,'G',58,47,23,1,17,'R','D','B','$','R','E','L','A','T',
   'I','O','N','_','N','A','M','E',23,0,17,'R','D','B','$','R',
   'E','L','A','T','I','O','N','_','N','A','M','E',58,57,48,23,
   1,15,'R','D','B','$','S','Y','S','T','E','M','_','F','L','A',
   'G',21,8,0,1,0,0,0,61,23,1,15,'R','D','B','$','S','Y','S','T',
   'E','M','_','F','L','A','G',59,60,'C',1,'J',24,'R','D','B','$',
   'R','E','L','A','T','I','O','N','_','C','O','N','S','T','R',
   'A','I','N','T','S',2,'G',47,23,2,14,'R','D','B','$','I','N',
   'D','E','X','_','N','A','M','E',23,0,14,'R','D','B','$','I',
   'N','D','E','X','_','N','A','M','E',-1,'F',2,'H',23,0,17,'R',
   'D','B','$','R','E','L','A','T','I','O','N','_','N','A','M',
   'E','H',23,0,14,'R','D','B','$','I','N','D','E','X','_','N',
   'A','M','E',-1,14,0,2,1,23,0,21,'R','D','B','$','E','X','P',
   'R','E','S','S','I','O','N','_','S','O','U','R','C','E',41,0,
   0,0,5,0,1,23,0,18,'R','D','B','$','E','X','P','R','E','S','S',
   'I','O','N','_','B','L','R',41,0,1,0,6,0,1,23,0,14,'R','D','B',
   '$','I','N','D','E','X','_','N','A','M','E',25,0,2,0,1,23,0,
   17,'R','D','B','$','R','E','L','A','T','I','O','N','_','N','A',
   'M','E',25,0,3,0,1,21,8,0,1,0,0,0,25,0,4,0,1,23,0,14,'R','D',
   'B','$','I','N','D','E','X','_','T','Y','P','E',25,0,7,0,1,23,
   0,15,'R','D','B','$','U','N','I','Q','U','E','_','F','L','A',
   'G',25,0,8,0,-1,14,0,1,21,8,0,0,0,0,0,25,0,4,0,-1,-1,'L'
   };	/* end of blr string for request isc_18 */

static isc_req_handle
   isc_29 = 0;		/* request handle */

static const short
   isc_30l = 277;
static const char
   isc_30 [] = {
   4,2,4,0,2,0,41,3,0,32,0,7,0,2,7,'C',1,'J',14,'R','D','B','$',
   'G','E','N','E','R','A','T','O','R','S',0,'G',58,59,106,23,0,
   18,'R','D','B','$','G','E','N','E','R','A','T','O','R','_','N',
   'A','M','E',21,15,3,0,5,0,'R','D','B','$',43,21,15,3,0,15,0,
   43,61,91,48,45,57,93,91,48,45,57,93,42,32,42,58,59,106,23,0,
   18,'R','D','B','$','G','E','N','E','R','A','T','O','R','_','N',
   'A','M','E',21,15,3,0,5,0,'S','Q','L','$',43,21,15,3,0,15,0,
   43,61,91,48,45,57,93,91,48,45,57,93,42,32,42,57,61,23,0,15,'R',
   'D','B','$','S','Y','S','T','E','M','_','F','L','A','G',48,23,
   0,15,'R','D','B','$','S','Y','S','T','E','M','_','F','L','A',
   'G',21,8,0,1,0,0,0,'F',1,'H',23,0,18,'R','D','B','$','G','E',
   'N','E','R','A','T','O','R','_','N','A','M','E',-1,14,0,2,1,
   23,0,18,'R','D','B','$','G','E','N','E','R','A','T','O','R',
   '_','N','A','M','E',25,0,0,0,1,21,8,0,1,0,0,0,25,0,1,0,-1,14,
   0,1,21,8,0,0,0,0,0,25,0,1,0,-1,-1,'L'
   };	/* end of blr string for request isc_30 */

static isc_req_handle
   isc_34 = 0;		/* request handle */

static const short
   isc_35l = 226;
static const char
   isc_35 [] = {
   4,2,4,1,5,0,7,0,7,0,7,0,7,0,7,0,4,0,2,0,41,3,0,32,0,7,0,12,0,
   2,7,'C',1,'J',22,'R','D','B','$','F','U','N','C','T','I','O',
   'N','_','A','R','G','U','M','E','N','T','S',0,'G',58,47,23,0,
   17,'R','D','B','$','F','U','N','C','T','I','O','N','_','N','A',
   'M','E',25,0,0,0,47,23,0,21,'R','D','B','$','A','R','G','U',
   'M','E','N','T','_','P','O','S','I','T','I','O','N',25,0,1,0,
   -1,14,1,2,1,21,8,0,1,0,0,0,25,1,0,0,1,23,0,15,'R','D','B','$',
   'F','I','E','L','D','_','S','C','A','L','E',25,1,1,0,1,23,0,
   18,'R','D','B','$','F','I','E','L','D','_','S','U','B','_','T',
   'Y','P','E',25,1,2,0,1,23,0,19,'R','D','B','$','F','I','E','L',
   'D','_','P','R','E','C','I','S','I','O','N',41,1,4,0,3,0,-1,
   14,1,1,21,8,0,0,0,0,0,25,1,0,0,-1,-1,'L'
   };	/* end of blr string for request isc_35 */

static isc_req_handle
   isc_45 = 0;		/* request handle */

static const short
   isc_46l = 172;
static const char
   isc_46 [] = {
   4,2,4,1,3,0,41,3,0,32,0,7,0,7,0,4,0,1,0,7,0,12,0,2,7,'C',1,'J',
   18,'R','D','B','$','C','H','A','R','A','C','T','E','R','_','S',
   'E','T','S',0,'G',47,23,0,20,'R','D','B','$','C','H','A','R',
   'A','C','T','E','R','_','S','E','T','_','I','D',25,0,0,0,-1,
   14,1,2,1,23,0,22,'R','D','B','$','C','H','A','R','A','C','T',
   'E','R','_','S','E','T','_','N','A','M','E',25,1,0,0,1,21,8,
   0,1,0,0,0,25,1,1,0,1,23,0,23,'R','D','B','$','B','Y','T','E',
   'S','_','P','E','R','_','C','H','A','R','A','C','T','E','R',
   25,1,2,0,-1,14,1,1,21,8,0,0,0,0,0,25,1,1,0,-1,-1,'L'
   };	/* end of blr string for request isc_46 */

static isc_req_handle
   isc_53 = 0;		/* request handle */

static const short
   isc_54l = 324;
static const char
   isc_54 [] = {
   4,2,4,1,8,0,41,3,0,32,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,4,0,1,0,
   41,3,0,32,0,12,0,2,7,'C',1,'J',22,'R','D','B','$','F','U','N',
   'C','T','I','O','N','_','A','R','G','U','M','E','N','T','S',
   0,'G',47,25,0,0,0,23,0,17,'R','D','B','$','F','U','N','C','T',
   'I','O','N','_','N','A','M','E','F',1,'H',23,0,21,'R','D','B',
   '$','A','R','G','U','M','E','N','T','_','P','O','S','I','T',
   'I','O','N',-1,14,1,2,1,23,0,17,'R','D','B','$','F','U','N',
   'C','T','I','O','N','_','N','A','M','E',25,1,0,0,1,21,8,0,1,
   0,0,0,25,1,1,0,1,23,0,13,'R','D','B','$','M','E','C','H','A',
   'N','I','S','M',25,1,2,0,1,23,0,15,'R','D','B','$','F','I','E',
   'L','D','_','S','C','A','L','E',25,1,3,0,1,23,0,21,'R','D','B',
   '$','A','R','G','U','M','E','N','T','_','P','O','S','I','T',
   'I','O','N',25,1,4,0,1,23,0,16,'R','D','B','$','F','I','E','L',
   'D','_','L','E','N','G','T','H',25,1,5,0,1,23,0,20,'R','D','B',
   '$','C','H','A','R','A','C','T','E','R','_','S','E','T','_',
   'I','D',25,1,6,0,1,23,0,14,'R','D','B','$','F','I','E','L','D',
   '_','T','Y','P','E',25,1,7,0,-1,14,1,1,21,8,0,0,0,0,0,25,1,1,
   0,-1,-1,'L'
   };	/* end of blr string for request isc_54 */

static isc_req_handle
   isc_66 = 0;		/* request handle */

static const short
   isc_67l = 246;
static const char
   isc_67 [] = {
   4,2,4,0,5,0,41,0,0,32,0,41,0,0,0,1,41,3,0,32,0,7,0,7,0,2,7,'C',
   1,'J',13,'R','D','B','$','F','U','N','C','T','I','O','N','S',
   0,'G',57,48,23,0,15,'R','D','B','$','S','Y','S','T','E','M',
   '_','F','L','A','G',21,8,0,1,0,0,0,61,23,0,15,'R','D','B','$',
   'S','Y','S','T','E','M','_','F','L','A','G','F',1,'H',23,0,17,
   'R','D','B','$','F','U','N','C','T','I','O','N','_','N','A',
   'M','E',-1,14,0,2,1,23,0,14,'R','D','B','$','E','N','T','R',
   'Y','P','O','I','N','T',25,0,0,0,1,23,0,15,'R','D','B','$','M',
   'O','D','U','L','E','_','N','A','M','E',25,0,1,0,1,23,0,17,'R',
   'D','B','$','F','U','N','C','T','I','O','N','_','N','A','M',
   'E',25,0,2,0,1,21,8,0,1,0,0,0,25,0,3,0,1,23,0,19,'R','D','B',
   '$','R','E','T','U','R','N','_','A','R','G','U','M','E','N',
   'T',25,0,4,0,-1,14,0,1,21,8,0,0,0,0,0,25,0,3,0,-1,-1,'L'
   };	/* end of blr string for request isc_67 */

static isc_req_handle
   isc_74 = 0;		/* request handle */

static const short
   isc_75l = 590;
static const char
   isc_75 [] = {
   4,2,4,0,11,0,41,3,0,32,0,41,3,0,32,0,41,3,0,32,0,41,3,0,32,0,
   41,3,0,32,0,41,0,0,12,0,41,0,0,12,0,7,0,7,0,7,0,7,0,2,7,'C',
   3,'J',24,'R','D','B','$','R','E','L','A','T','I','O','N','_',
   'C','O','N','S','T','R','A','I','N','T','S',0,'J',24,'R','D',
   'B','$','R','E','L','A','T','I','O','N','_','C','O','N','S',
   'T','R','A','I','N','T','S',1,'J',19,'R','D','B','$','R','E',
   'F','_','C','O','N','S','T','R','A','I','N','T','S',2,'G',58,
   47,23,0,19,'R','D','B','$','C','O','N','S','T','R','A','I','N',
   'T','_','T','Y','P','E',21,15,3,0,11,0,'F','O','R','E','I','G',
   'N',32,'K','E','Y',58,47,23,2,17,'R','D','B','$','C','O','N',
   'S','T','_','N','A','M','E','_','U','Q',23,1,19,'R','D','B',
   '$','C','O','N','S','T','R','A','I','N','T','_','N','A','M',
   'E',58,47,23,2,19,'R','D','B','$','C','O','N','S','T','R','A',
   'I','N','T','_','N','A','M','E',23,0,19,'R','D','B','$','C',
   'O','N','S','T','R','A','I','N','T','_','N','A','M','E',57,47,
   23,1,19,'R','D','B','$','C','O','N','S','T','R','A','I','N',
   'T','_','T','Y','P','E',21,15,3,0,6,0,'U','N','I','Q','U','E',
   47,23,1,19,'R','D','B','$','C','O','N','S','T','R','A','I','N',
   'T','_','T','Y','P','E',21,15,3,0,11,0,'P','R','I','M','A','R',
   'Y',32,'K','E','Y','F',2,'H',23,0,17,'R','D','B','$','R','E',
   'L','A','T','I','O','N','_','N','A','M','E','H',23,0,19,'R',
   'D','B','$','C','O','N','S','T','R','A','I','N','T','_','N',
   'A','M','E',-1,14,0,2,1,23,1,14,'R','D','B','$','I','N','D',
   'E','X','_','N','A','M','E',25,0,0,0,1,23,0,19,'R','D','B','$',
   'C','O','N','S','T','R','A','I','N','T','_','N','A','M','E',
   41,0,1,0,10,0,1,23,0,14,'R','D','B','$','I','N','D','E','X',
   '_','N','A','M','E',25,0,2,0,1,23,1,17,'R','D','B','$','R','E',
   'L','A','T','I','O','N','_','N','A','M','E',25,0,3,0,1,23,0,
   17,'R','D','B','$','R','E','L','A','T','I','O','N','_','N','A',
   'M','E',25,0,4,0,1,23,2,15,'R','D','B','$','D','E','L','E','T',
   'E','_','R','U','L','E',41,0,5,0,8,0,1,23,2,15,'R','D','B','$',
   'U','P','D','A','T','E','_','R','U','L','E',41,0,6,0,9,0,1,21,
   8,0,1,0,0,0,25,0,7,0,-1,14,0,1,21,8,0,0,0,0,0,25,0,7,0,-1,-1,
   'L'
   };	/* end of blr string for request isc_75 */

static isc_req_handle
   isc_88 = 0;		/* request handle */

static const short
   isc_89l = 225;
static const char
   isc_89 [] = {
   4,2,4,0,6,0,41,0,0,32,0,41,0,0,0,1,41,3,0,32,0,7,0,7,0,7,0,2,
   7,'C',1,'J',11,'R','D','B','$','F','I','L','T','E','R','S',0,
   'F',1,'H',23,0,17,'R','D','B','$','F','U','N','C','T','I','O',
   'N','_','N','A','M','E',-1,14,0,2,1,23,0,14,'R','D','B','$',
   'E','N','T','R','Y','P','O','I','N','T',25,0,0,0,1,23,0,15,'R',
   'D','B','$','M','O','D','U','L','E','_','N','A','M','E',25,0,
   1,0,1,23,0,17,'R','D','B','$','F','U','N','C','T','I','O','N',
   '_','N','A','M','E',25,0,2,0,1,21,8,0,1,0,0,0,25,0,3,0,1,23,
   0,19,'R','D','B','$','O','U','T','P','U','T','_','S','U','B',
   '_','T','Y','P','E',25,0,4,0,1,23,0,18,'R','D','B','$','I','N',
   'P','U','T','_','S','U','B','_','T','Y','P','E',25,0,5,0,-1,
   14,0,1,21,8,0,0,0,0,0,25,0,3,0,-1,-1,'L'
   };	/* end of blr string for request isc_89 */

static isc_req_handle
   isc_97 = 0;		/* request handle */

static const short
   isc_98l = 142;
static const char
   isc_98 [] = {
   4,2,4,0,3,0,41,0,0,0,4,41,3,0,32,0,7,0,2,7,'C',1,'J',14,'R',
   'D','B','$','E','X','C','E','P','T','I','O','N','S',0,'F',1,
   'H',23,0,18,'R','D','B','$','E','X','C','E','P','T','I','O',
   'N','_','N','A','M','E',-1,14,0,2,1,23,0,11,'R','D','B','$',
   'M','E','S','S','A','G','E',25,0,0,0,1,23,0,18,'R','D','B','$',
   'E','X','C','E','P','T','I','O','N','_','N','A','M','E',25,0,
   1,0,1,21,8,0,1,0,0,0,25,0,2,0,-1,14,0,1,21,8,0,0,0,0,0,25,0,
   2,0,-1,-1,'L'
   };	/* end of blr string for request isc_98 */

static isc_req_handle
   isc_103 = 0;		/* request handle */

static const short
   isc_104l = 179;
static const char
   isc_104 [] = {
   4,2,4,1,5,0,7,0,7,0,7,0,7,0,7,0,4,0,1,0,41,3,0,32,0,12,0,2,7,
   'C',1,'J',10,'R','D','B','$','F','I','E','L','D','S',0,'G',47,
   23,0,14,'R','D','B','$','F','I','E','L','D','_','N','A','M',
   'E',25,0,0,0,-1,14,1,2,1,21,8,0,1,0,0,0,25,1,0,0,1,23,0,15,'R',
   'D','B','$','F','I','E','L','D','_','S','C','A','L','E',25,1,
   1,0,1,23,0,18,'R','D','B','$','F','I','E','L','D','_','S','U',
   'B','_','T','Y','P','E',25,1,2,0,1,23,0,19,'R','D','B','$','F',
   'I','E','L','D','_','P','R','E','C','I','S','I','O','N',41,1,
   4,0,3,0,-1,14,1,1,21,8,0,0,0,0,0,25,1,0,0,-1,-1,'L'
   };	/* end of blr string for request isc_104 */

static isc_req_handle
   isc_113 = 0;		/* request handle */

static const short
   isc_114l = 472;
static const char
   isc_114 [] = {
   4,2,4,0,17,0,9,0,9,0,41,3,0,32,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,
   7,0,7,0,7,0,7,0,7,0,7,0,7,0,2,7,'C',1,'J',10,'R','D','B','$',
   'F','I','E','L','D','S',0,'G',58,59,106,23,0,14,'R','D','B',
   '$','F','I','E','L','D','_','N','A','M','E',21,15,3,0,5,0,'R',
   'D','B','$',43,21,15,3,0,15,0,43,61,91,48,45,57,93,91,48,45,
   57,93,42,32,42,48,23,0,15,'R','D','B','$','S','Y','S','T','E',
   'M','_','F','L','A','G',21,8,0,1,0,0,0,'F',1,'H',23,0,14,'R',
   'D','B','$','F','I','E','L','D','_','N','A','M','E',-1,14,0,
   2,1,23,0,21,'R','D','B','$','V','A','L','I','D','A','T','I',
   'O','N','_','S','O','U','R','C','E',41,0,0,0,5,0,1,23,0,18,'R',
   'D','B','$','D','E','F','A','U','L','T','_','S','O','U','R',
   'C','E',41,0,1,0,6,0,1,23,0,14,'R','D','B','$','F','I','E','L',
   'D','_','N','A','M','E',25,0,2,0,1,21,8,0,1,0,0,0,25,0,3,0,1,
   23,0,13,'R','D','B','$','N','U','L','L','_','F','L','A','G',
   25,0,4,0,1,23,0,14,'R','D','B','$','D','I','M','E','N','S','I',
   'O','N','S',41,0,8,0,7,0,1,23,0,16,'R','D','B','$','C','O','L',
   'L','A','T','I','O','N','_','I','D',41,0,10,0,9,0,1,23,0,20,
   'R','D','B','$','C','H','A','R','A','C','T','E','R','_','S',
   'E','T','_','I','D',41,0,12,0,11,0,1,23,0,18,'R','D','B','$',
   'S','E','G','M','E','N','T','_','L','E','N','G','T','H',25,0,
   13,0,1,23,0,18,'R','D','B','$','F','I','E','L','D','_','S','U',
   'B','_','T','Y','P','E',25,0,14,0,1,23,0,15,'R','D','B','$',
   'F','I','E','L','D','_','S','C','A','L','E',25,0,15,0,1,23,0,
   14,'R','D','B','$','F','I','E','L','D','_','T','Y','P','E',25,
   0,16,0,-1,14,0,1,21,8,0,0,0,0,0,25,0,3,0,-1,-1,'L'
   };	/* end of blr string for request isc_114 */

static isc_req_handle
   isc_133 = 0;		/* request handle */

static const short
   isc_134l = 179;
static const char
   isc_134 [] = {
   4,2,4,1,5,0,7,0,7,0,7,0,7,0,7,0,4,0,1,0,41,3,0,32,0,12,0,2,7,
   'C',1,'J',10,'R','D','B','$','F','I','E','L','D','S',0,'G',47,
   23,0,14,'R','D','B','$','F','I','E','L','D','_','N','A','M',
   'E',25,0,0,0,-1,14,1,2,1,21,8,0,1,0,0,0,25,1,0,0,1,23,0,15,'R',
   'D','B','$','F','I','E','L','D','_','S','C','A','L','E',25,1,
   1,0,1,23,0,18,'R','D','B','$','F','I','E','L','D','_','S','U',
   'B','_','T','Y','P','E',25,1,2,0,1,23,0,19,'R','D','B','$','F',
   'I','E','L','D','_','P','R','E','C','I','S','I','O','N',41,1,
   4,0,3,0,-1,14,1,1,21,8,0,0,0,0,0,25,1,0,0,-1,-1,'L'
   };	/* end of blr string for request isc_134 */

static isc_req_handle
   isc_143 = 0;		/* request handle */

static const short
   isc_144l = 519;
static const char
   isc_144 [] = {
   4,2,4,1,19,0,9,0,9,0,41,3,0,32,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,
   7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,4,0,1,0,41,3,0,32,0,12,0,
   2,7,'C',2,'J',10,'R','D','B','$','F','I','E','L','D','S',0,'J',
   19,'R','D','B','$','R','E','L','A','T','I','O','N','_','F','I',
   'E','L','D','S',1,'G',58,47,23,1,16,'R','D','B','$','F','I',
   'E','L','D','_','S','O','U','R','C','E',23,0,14,'R','D','B',
   '$','F','I','E','L','D','_','N','A','M','E',47,23,1,17,'R','D',
   'B','$','R','E','L','A','T','I','O','N','_','N','A','M','E',
   25,0,0,0,'F',1,'H',23,0,14,'R','D','B','$','F','I','E','L','D',
   '_','N','A','M','E',-1,14,1,2,1,23,0,21,'R','D','B','$','V',
   'A','L','I','D','A','T','I','O','N','_','S','O','U','R','C',
   'E',41,1,0,0,5,0,1,23,0,18,'R','D','B','$','D','E','F','A','U',
   'L','T','_','S','O','U','R','C','E',41,1,1,0,6,0,1,23,0,14,'R',
   'D','B','$','F','I','E','L','D','_','N','A','M','E',25,1,2,0,
   1,21,8,0,1,0,0,0,25,1,3,0,1,23,0,13,'R','D','B','$','N','U',
   'L','L','_','F','L','A','G',25,1,4,0,1,23,0,14,'R','D','B','$',
   'D','I','M','E','N','S','I','O','N','S',41,1,8,0,7,0,1,23,0,
   16,'R','D','B','$','C','O','L','L','A','T','I','O','N','_','I',
   'D',41,1,10,0,9,0,1,23,0,20,'R','D','B','$','C','H','A','R',
   'A','C','T','E','R','_','S','E','T','_','I','D',41,1,12,0,11,
   0,1,23,0,18,'R','D','B','$','S','E','G','M','E','N','T','_',
   'L','E','N','G','T','H',25,1,13,0,1,23,0,18,'R','D','B','$',
   'F','I','E','L','D','_','S','U','B','_','T','Y','P','E',25,1,
   14,0,1,23,0,15,'R','D','B','$','F','I','E','L','D','_','S','C',
   'A','L','E',25,1,15,0,1,23,0,14,'R','D','B','$','F','I','E',
   'L','D','_','T','Y','P','E',25,1,16,0,1,23,0,15,'R','D','B',
   '$','S','Y','S','T','E','M','_','F','L','A','G',41,1,18,0,17,
   0,-1,14,1,1,21,8,0,0,0,0,0,25,1,3,0,-1,-1,'L'
   };	/* end of blr string for request isc_144 */

static isc_req_handle
   isc_167 = 0;		/* request handle */

static const short
   isc_168l = 271;
static const char
   isc_168 [] = {
   4,2,4,0,11,0,41,0,0,0,1,8,0,8,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,
   7,0,2,7,'C',1,'J',9,'R','D','B','$','F','I','L','E','S',0,'F',
   2,'H',23,0,17,'R','D','B','$','S','H','A','D','O','W','_','N',
   'U','M','B','E','R','H',23,0,17,'R','D','B','$','F','I','L',
   'E','_','S','E','Q','U','E','N','C','E',-1,14,0,2,1,23,0,13,
   'R','D','B','$','F','I','L','E','_','N','A','M','E',25,0,0,0,
   1,23,0,14,'R','D','B','$','F','I','L','E','_','S','T','A','R',
   'T',41,0,1,0,5,0,1,23,0,15,'R','D','B','$','F','I','L','E','_',
   'L','E','N','G','T','H',41,0,2,0,8,0,1,21,8,0,1,0,0,0,25,0,3,
   0,1,23,0,17,'R','D','B','$','S','H','A','D','O','W','_','N',
   'U','M','B','E','R',25,0,4,0,1,23,0,17,'R','D','B','$','F','I',
   'L','E','_','S','E','Q','U','E','N','C','E',41,0,7,0,6,0,1,23,
   0,14,'R','D','B','$','F','I','L','E','_','F','L','A','G','S',
   41,0,10,0,9,0,-1,14,0,1,21,8,0,0,0,0,0,25,0,3,0,-1,-1,'L'
   };	/* end of blr string for request isc_168 */

static isc_req_handle
   isc_181 = 0;		/* request handle */

static const short
   isc_182l = 158;
static const char
   isc_182 [] = {
   4,2,4,0,2,0,41,3,0,32,0,7,0,2,7,'C',1,'J',12,'R','D','B','$',
   'D','A','T','A','B','A','S','E',0,'G',58,59,61,23,0,22,'R','D',
   'B','$','C','H','A','R','A','C','T','E','R','_','S','E','T',
   '_','N','A','M','E',48,23,0,22,'R','D','B','$','C','H','A','R',
   'A','C','T','E','R','_','S','E','T','_','N','A','M','E',21,15,
   3,0,1,0,32,-1,14,0,2,1,23,0,22,'R','D','B','$','C','H','A','R',
   'A','C','T','E','R','_','S','E','T','_','N','A','M','E',25,0,
   0,0,1,21,8,0,1,0,0,0,25,0,1,0,-1,14,0,1,21,8,0,0,0,0,0,25,0,
   1,0,-1,-1,'L'
   };	/* end of blr string for request isc_182 */

static isc_req_handle
   isc_186 = 0;		/* request handle */

static const short
   isc_187l = 410;
static const char
   isc_187 [] = {
   4,2,4,0,9,0,9,0,41,3,0,32,0,41,3,0,32,0,41,3,0,32,0,7,0,7,0,
   7,0,7,0,7,0,2,7,'C',2,'J',14,'R','D','B','$','C','O','L','L',
   'A','T','I','O','N','S',0,'J',18,'R','D','B','$','C','H','A',
   'R','A','C','T','E','R','_','S','E','T','S',1,'G',58,47,23,1,
   20,'R','D','B','$','C','H','A','R','A','C','T','E','R','_','S',
   'E','T','_','I','D',23,0,20,'R','D','B','$','C','H','A','R',
   'A','C','T','E','R','_','S','E','T','_','I','D',57,61,23,0,15,
   'R','D','B','$','S','Y','S','T','E','M','_','F','L','A','G',
   48,23,0,15,'R','D','B','$','S','Y','S','T','E','M','_','F','L',
   'A','G',21,8,0,1,0,0,0,'F',2,'H',23,1,22,'R','D','B','$','C',
   'H','A','R','A','C','T','E','R','_','S','E','T','_','N','A',
   'M','E','H',23,0,18,'R','D','B','$','C','O','L','L','A','T',
   'I','O','N','_','N','A','M','E',-1,14,0,2,1,23,0,23,'R','D',
   'B','$','S','P','E','C','I','F','I','C','_','A','T','T','R',
   'I','B','U','T','E','S',41,0,0,0,5,0,1,23,0,23,'R','D','B','$',
   'B','A','S','E','_','C','O','L','L','A','T','I','O','N','_',
   'N','A','M','E',41,0,1,0,8,0,1,23,1,22,'R','D','B','$','C','H',
   'A','R','A','C','T','E','R','_','S','E','T','_','N','A','M',
   'E',25,0,2,0,1,23,0,18,'R','D','B','$','C','O','L','L','A','T',
   'I','O','N','_','N','A','M','E',25,0,3,0,1,21,8,0,1,0,0,0,25,
   0,4,0,1,23,0,24,'R','D','B','$','C','O','L','L','A','T','I',
   'O','N','_','A','T','T','R','I','B','U','T','E','S',41,0,7,0,
   6,0,-1,14,0,1,21,8,0,0,0,0,0,25,0,4,0,-1,-1,'L'
   };	/* end of blr string for request isc_187 */

static isc_req_handle
   isc_198 = 0;		/* request handle */

static const short
   isc_199l = 222;
static const char
   isc_199 [] = {
   4,2,4,0,3,0,41,3,0,32,0,41,3,0,32,0,7,0,2,7,'C',1,'J',18,'R',
   'D','B','$','C','H','A','R','A','C','T','E','R','_','S','E',
   'T','S',0,'G',59,47,23,0,22,'R','D','B','$','C','H','A','R',
   'A','C','T','E','R','_','S','E','T','_','N','A','M','E',23,0,
   24,'R','D','B','$','D','E','F','A','U','L','T','_','C','O','L',
   'L','A','T','E','_','N','A','M','E','F',1,'H',23,0,22,'R','D',
   'B','$','C','H','A','R','A','C','T','E','R','_','S','E','T',
   '_','N','A','M','E',-1,14,0,2,1,23,0,24,'R','D','B','$','D',
   'E','F','A','U','L','T','_','C','O','L','L','A','T','E','_',
   'N','A','M','E',25,0,0,0,1,23,0,22,'R','D','B','$','C','H','A',
   'R','A','C','T','E','R','_','S','E','T','_','N','A','M','E',
   25,0,1,0,1,21,8,0,1,0,0,0,25,0,2,0,-1,14,0,1,21,8,0,0,0,0,0,
   25,0,2,0,-1,-1,'L'
   };	/* end of blr string for request isc_199 */

static isc_req_handle
   isc_204 = 0;		/* request handle */

static const short
   isc_205l = 441;
static const char
   isc_205 [] = {
   4,2,4,1,5,0,9,0,41,3,0,32,0,41,3,0,32,0,7,0,7,0,4,0,1,0,7,0,
   12,0,2,7,'C',2,'J',12,'R','D','B','$','T','R','I','G','G','E',
   'R','S',0,'J',21,'R','D','B','$','C','H','E','C','K','_','C',
   'O','N','S','T','R','A','I','N','T','S',1,'G',58,47,23,0,16,
   'R','D','B','$','T','R','I','G','G','E','R','_','T','Y','P',
   'E',21,8,0,1,0,0,0,58,47,23,0,15,'R','D','B','$','S','Y','S',
   'T','E','M','_','F','L','A','G',25,0,0,0,58,47,23,0,16,'R','D',
   'B','$','T','R','I','G','G','E','R','_','N','A','M','E',23,1,
   16,'R','D','B','$','T','R','I','G','G','E','R','_','N','A','M',
   'E',60,'C',1,'J',24,'R','D','B','$','R','E','L','A','T','I',
   'O','N','_','C','O','N','S','T','R','A','I','N','T','S',2,'G',
   58,47,23,1,19,'R','D','B','$','C','O','N','S','T','R','A','I',
   'N','T','_','N','A','M','E',23,2,19,'R','D','B','$','C','O',
   'N','S','T','R','A','I','N','T','_','N','A','M','E',47,23,2,
   19,'R','D','B','$','C','O','N','S','T','R','A','I','N','T','_',
   'T','Y','P','E',21,15,3,0,5,0,'C','H','E','C','K',-1,'F',1,'H',
   23,1,19,'R','D','B','$','C','O','N','S','T','R','A','I','N',
   'T','_','N','A','M','E','E',1,23,1,19,'R','D','B','$','C','O',
   'N','S','T','R','A','I','N','T','_','N','A','M','E',-1,14,1,
   2,1,23,0,18,'R','D','B','$','T','R','I','G','G','E','R','_',
   'S','O','U','R','C','E',41,1,0,0,4,0,1,23,1,19,'R','D','B','$',
   'C','O','N','S','T','R','A','I','N','T','_','N','A','M','E',
   25,1,1,0,1,23,0,17,'R','D','B','$','R','E','L','A','T','I','O',
   'N','_','N','A','M','E',25,1,2,0,1,21,8,0,1,0,0,0,25,1,3,0,-1,
   14,1,1,21,8,0,0,0,0,0,25,1,3,0,-1,-1,'L'
   };	/* end of blr string for request isc_205 */

static isc_req_handle
   isc_214 = 0;		/* request handle */

static const short
   isc_215l = 453;
static const char
   isc_215 [] = {
   4,2,4,0,10,0,9,0,41,3,0,32,0,41,3,0,32,0,7,0,7,0,7,0,7,0,7,0,
   7,0,7,0,2,7,'C',2,'J',12,'R','D','B','$','T','R','I','G','G',
   'E','R','S',0,'J',13,'R','D','B','$','R','E','L','A','T','I',
   'O','N','S',1,'G',58,47,23,1,17,'R','D','B','$','R','E','L',
   'A','T','I','O','N','_','N','A','M','E',23,0,17,'R','D','B',
   '$','R','E','L','A','T','I','O','N','_','N','A','M','E',57,47,
   23,0,15,'R','D','B','$','S','Y','S','T','E','M','_','F','L',
   'A','G',21,8,0,0,0,0,0,61,23,0,15,'R','D','B','$','S','Y','S',
   'T','E','M','_','F','L','A','G','F',4,'H',23,0,17,'R','D','B',
   '$','R','E','L','A','T','I','O','N','_','N','A','M','E','H',
   23,0,16,'R','D','B','$','T','R','I','G','G','E','R','_','T',
   'Y','P','E','H',23,0,20,'R','D','B','$','T','R','I','G','G',
   'E','R','_','S','E','Q','U','E','N','C','E','H',23,0,16,'R',
   'D','B','$','T','R','I','G','G','E','R','_','N','A','M','E',
   -1,14,0,2,1,23,0,18,'R','D','B','$','T','R','I','G','G','E',
   'R','_','S','O','U','R','C','E',41,0,0,0,4,0,1,23,0,17,'R','D',
   'B','$','R','E','L','A','T','I','O','N','_','N','A','M','E',
   25,0,1,0,1,23,0,16,'R','D','B','$','T','R','I','G','G','E','R',
   '_','N','A','M','E',25,0,2,0,1,21,8,0,1,0,0,0,25,0,3,0,1,23,
   0,20,'R','D','B','$','T','R','I','G','G','E','R','_','S','E',
   'Q','U','E','N','C','E',25,0,5,0,1,23,0,16,'R','D','B','$','T',
   'R','I','G','G','E','R','_','T','Y','P','E',25,0,6,0,1,23,0,
   9,'R','D','B','$','F','L','A','G','S',25,0,7,0,1,23,0,20,'R',
   'D','B','$','T','R','I','G','G','E','R','_','I','N','A','C',
   'T','I','V','E',41,0,9,0,8,0,-1,14,0,1,21,8,0,0,0,0,0,25,0,3,
   0,-1,-1,'L'
   };	/* end of blr string for request isc_215 */

static isc_req_handle
   isc_227 = 0;		/* request handle */

static const short
   isc_228l = 366;
static const char
   isc_228 [] = {
   4,2,4,0,9,0,9,0,41,3,0,32,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,2,7,
   'C',1,'J',12,'R','D','B','$','T','R','I','G','G','E','R','S',
   0,'G',58,57,47,23,0,15,'R','D','B','$','S','Y','S','T','E','M',
   '_','F','L','A','G',21,8,0,0,0,0,0,61,23,0,15,'R','D','B','$',
   'S','Y','S','T','E','M','_','F','L','A','G',61,23,0,17,'R','D',
   'B','$','R','E','L','A','T','I','O','N','_','N','A','M','E',
   'F',3,'H',23,0,16,'R','D','B','$','T','R','I','G','G','E','R',
   '_','T','Y','P','E','H',23,0,20,'R','D','B','$','T','R','I',
   'G','G','E','R','_','S','E','Q','U','E','N','C','E','H',23,0,
   16,'R','D','B','$','T','R','I','G','G','E','R','_','N','A','M',
   'E',-1,14,0,2,1,23,0,18,'R','D','B','$','T','R','I','G','G',
   'E','R','_','S','O','U','R','C','E',41,0,0,0,3,0,1,23,0,16,'R',
   'D','B','$','T','R','I','G','G','E','R','_','N','A','M','E',
   25,0,1,0,1,21,8,0,1,0,0,0,25,0,2,0,1,23,0,20,'R','D','B','$',
   'T','R','I','G','G','E','R','_','S','E','Q','U','E','N','C',
   'E',25,0,4,0,1,23,0,16,'R','D','B','$','T','R','I','G','G','E',
   'R','_','T','Y','P','E',25,0,5,0,1,23,0,9,'R','D','B','$','F',
   'L','A','G','S',25,0,6,0,1,23,0,20,'R','D','B','$','T','R','I',
   'G','G','E','R','_','I','N','A','C','T','I','V','E',41,0,8,0,
   7,0,-1,14,0,1,21,8,0,0,0,0,0,25,0,2,0,-1,-1,'L'
   };	/* end of blr string for request isc_228 */

static isc_req_handle
   isc_239 = 0;		/* request handle */

static const short
   isc_240l = 233;
static const char
   isc_240 [] = {
   4,2,4,0,5,0,41,3,0,32,0,41,3,0,32,0,7,0,7,0,7,0,2,7,'C',1,'J',
   13,'R','D','B','$','R','E','L','A','T','I','O','N','S',0,'G',
   58,57,48,23,0,15,'R','D','B','$','S','Y','S','T','E','M','_',
   'F','L','A','G',21,8,0,1,0,0,0,61,23,0,15,'R','D','B','$','S',
   'Y','S','T','E','M','_','F','L','A','G',61,23,0,12,'R','D','B',
   '$','V','I','E','W','_','B','L','R','F',1,'H',23,0,17,'R','D',
   'B','$','R','E','L','A','T','I','O','N','_','N','A','M','E',
   -1,14,0,2,1,23,0,18,'R','D','B','$','S','E','C','U','R','I',
   'T','Y','_','C','L','A','S','S',25,0,0,0,1,23,0,17,'R','D','B',
   '$','R','E','L','A','T','I','O','N','_','N','A','M','E',25,0,
   1,0,1,21,8,0,1,0,0,0,25,0,2,0,1,23,0,9,'R','D','B','$','F','L',
   'A','G','S',41,0,4,0,3,0,-1,14,0,1,21,8,0,0,0,0,0,25,0,2,0,-1,
   -1,'L'
   };	/* end of blr string for request isc_240 */

static isc_req_handle
   isc_247 = 0;		/* request handle */

static const short
   isc_248l = 152;
static const char
   isc_248 [] = {
   4,2,4,0,4,0,9,0,41,3,0,32,0,7,0,7,0,2,7,'C',1,'J',14,'R','D',
   'B','$','P','R','O','C','E','D','U','R','E','S',0,'F',1,'H',
   23,0,18,'R','D','B','$','P','R','O','C','E','D','U','R','E',
   '_','N','A','M','E',-1,14,0,2,1,23,0,20,'R','D','B','$','P',
   'R','O','C','E','D','U','R','E','_','S','O','U','R','C','E',
   41,0,0,0,3,0,1,23,0,18,'R','D','B','$','P','R','O','C','E','D',
   'U','R','E','_','N','A','M','E',25,0,1,0,1,21,8,0,1,0,0,0,25,
   0,2,0,-1,14,0,1,21,8,0,0,0,0,0,25,0,2,0,-1,-1,'L'
   };	/* end of blr string for request isc_248 */

static isc_req_handle
   isc_254 = 0;		/* request handle */

static const short
   isc_255l = 153;
static const char
   isc_255 [] = {
   4,2,4,1,2,0,7,0,7,0,4,0,1,0,41,3,0,32,0,12,0,2,7,'C',1,'J',14,
   'R','D','B','$','P','R','O','C','E','D','U','R','E','S',0,'G',
   58,47,23,0,18,'R','D','B','$','P','R','O','C','E','D','U','R',
   'E','_','N','A','M','E',25,0,0,0,59,61,23,0,18,'R','D','B','$',
   'P','R','O','C','E','D','U','R','E','_','T','Y','P','E',-1,14,
   1,2,1,21,8,0,1,0,0,0,25,1,0,0,1,23,0,18,'R','D','B','$','P',
   'R','O','C','E','D','U','R','E','_','T','Y','P','E',25,1,1,0,
   -1,14,1,1,21,8,0,0,0,0,0,25,1,0,0,-1,-1,'L'
   };	/* end of blr string for request isc_255 */

static isc_req_handle
   isc_261 = 0;		/* request handle */

static const short
   isc_262l = 118;
static const char
   isc_262 [] = {
   4,2,4,0,2,0,41,3,0,32,0,7,0,2,7,'C',1,'J',14,'R','D','B','$',
   'P','R','O','C','E','D','U','R','E','S',0,'F',1,'H',23,0,18,
   'R','D','B','$','P','R','O','C','E','D','U','R','E','_','N',
   'A','M','E',-1,14,0,2,1,23,0,18,'R','D','B','$','P','R','O',
   'C','E','D','U','R','E','_','N','A','M','E',25,0,0,0,1,21,8,
   0,1,0,0,0,25,0,1,0,-1,14,0,1,21,8,0,0,0,0,0,25,0,1,0,-1,-1,'L'
   
   };	/* end of blr string for request isc_262 */

static isc_req_handle
   isc_266 = 0;		/* request handle */

static const short
   isc_267l = 118;
static const char
   isc_267 [] = {
   4,2,4,0,2,0,41,3,0,32,0,7,0,2,7,'C',1,'J',14,'R','D','B','$',
   'P','R','O','C','E','D','U','R','E','S',0,'F',1,'H',23,0,18,
   'R','D','B','$','P','R','O','C','E','D','U','R','E','_','N',
   'A','M','E',-1,14,0,2,1,23,0,18,'R','D','B','$','P','R','O',
   'C','E','D','U','R','E','_','N','A','M','E',25,0,0,0,1,21,8,
   0,1,0,0,0,25,0,1,0,-1,14,0,1,21,8,0,0,0,0,0,25,0,1,0,-1,-1,'L'
   
   };	/* end of blr string for request isc_267 */

static isc_req_handle
   isc_271 = 0;		/* request handle */

static const short
   isc_272l = 195;
static const char
   isc_272 [] = {
   4,2,4,0,2,0,41,3,0,32,0,7,0,2,7,'C',1,'J',13,'R','D','B','$',
   'R','E','L','A','T','I','O','N','S',0,'G',58,57,48,23,0,15,'R',
   'D','B','$','S','Y','S','T','E','M','_','F','L','A','G',21,8,
   0,1,0,0,0,61,23,0,15,'R','D','B','$','S','Y','S','T','E','M',
   '_','F','L','A','G',55,23,0,18,'R','D','B','$','S','E','C','U',
   'R','I','T','Y','_','C','L','A','S','S',21,15,3,0,4,0,'S','Q',
   'L','$','F',1,'H',23,0,17,'R','D','B','$','R','E','L','A','T',
   'I','O','N','_','N','A','M','E',-1,14,0,2,1,23,0,17,'R','D',
   'B','$','R','E','L','A','T','I','O','N','_','N','A','M','E',
   25,0,0,0,1,21,8,0,1,0,0,0,25,0,1,0,-1,14,0,1,21,8,0,0,0,0,0,
   25,0,1,0,-1,-1,'L'
   };	/* end of blr string for request isc_272 */

static isc_req_handle
   isc_276 = 0;		/* request handle */

static const short
   isc_277l = 118;
static const char
   isc_277 [] = {
   4,2,4,1,1,0,7,0,4,0,1,0,41,3,0,32,0,12,0,2,7,'C',1,'J',9,'R',
   'D','B','$','R','O','L','E','S',0,'G',58,47,23,0,13,'R','D',
   'B','$','R','O','L','E','_','N','A','M','E',25,0,0,0,49,23,0,
   15,'R','D','B','$','S','Y','S','T','E','M','_','F','L','A','G',
   21,8,0,0,0,0,0,-1,14,1,2,1,21,8,0,1,0,0,0,25,1,0,0,-1,14,1,1,
   21,8,0,0,0,0,0,25,1,0,0,-1,-1,'L'
   };	/* end of blr string for request isc_277 */

static isc_req_handle
   isc_282 = 0;		/* request handle */

static const short
   isc_283l = 130;
static const char
   isc_283 [] = {
   4,2,4,0,3,0,41,3,0,32,0,41,3,0,32,0,7,0,2,7,'C',1,'J',9,'R',
   'D','B','$','R','O','L','E','S',0,'F',1,'H',23,0,13,'R','D',
   'B','$','R','O','L','E','_','N','A','M','E',-1,14,0,2,1,23,0,
   14,'R','D','B','$','O','W','N','E','R','_','N','A','M','E',25,
   0,0,0,1,23,0,13,'R','D','B','$','R','O','L','E','_','N','A',
   'M','E',25,0,1,0,1,21,8,0,1,0,0,0,25,0,2,0,-1,14,0,1,21,8,0,
   0,0,0,0,25,0,2,0,-1,-1,'L'
   };	/* end of blr string for request isc_283 */

static isc_req_handle
   isc_288 = 0;		/* request handle */

static const short
   isc_289l = 179;
static const char
   isc_289 [] = {
   4,2,4,1,5,0,7,0,7,0,7,0,7,0,7,0,4,0,1,0,41,3,0,32,0,12,0,2,7,
   'C',1,'J',10,'R','D','B','$','F','I','E','L','D','S',0,'G',47,
   23,0,14,'R','D','B','$','F','I','E','L','D','_','N','A','M',
   'E',25,0,0,0,-1,14,1,2,1,21,8,0,1,0,0,0,25,1,0,0,1,23,0,15,'R',
   'D','B','$','F','I','E','L','D','_','S','C','A','L','E',25,1,
   1,0,1,23,0,18,'R','D','B','$','F','I','E','L','D','_','S','U',
   'B','_','T','Y','P','E',25,1,2,0,1,23,0,19,'R','D','B','$','F',
   'I','E','L','D','_','P','R','E','C','I','S','I','O','N',41,1,
   4,0,3,0,-1,14,1,1,21,8,0,0,0,0,0,25,1,0,0,-1,-1,'L'
   };	/* end of blr string for request isc_289 */

static isc_req_handle
   isc_298 = 0;		/* request handle */

static const short
   isc_299l = 208;
static const char
   isc_299 [] = {
   4,2,4,1,5,0,41,3,0,32,0,41,3,0,32,0,7,0,7,0,7,0,4,0,2,0,41,3,
   0,32,0,41,3,0,32,0,12,0,2,7,'C',1,'J',24,'R','D','B','$','P',
   'R','O','C','E','D','U','R','E','_','P','A','R','A','M','E',
   'T','E','R','S',0,'G',58,47,23,0,18,'R','D','B','$','P','R',
   'O','C','E','D','U','R','E','_','N','A','M','E',25,0,1,0,47,
   23,0,18,'R','D','B','$','P','A','R','A','M','E','T','E','R',
   '_','N','A','M','E',25,0,0,0,-1,14,1,2,1,23,0,14,'R','D','B',
   '$','F','I','E','L','D','_','N','A','M','E',41,1,0,0,3,0,1,23,
   0,17,'R','D','B','$','R','E','L','A','T','I','O','N','_','N',
   'A','M','E',41,1,1,0,4,0,1,21,8,0,1,0,0,0,25,1,2,0,-1,14,1,1,
   21,8,0,0,0,0,0,25,1,2,0,-1,-1,'L'
   };	/* end of blr string for request isc_299 */

static isc_req_handle
   isc_309 = 0;		/* request handle */

static const short
   isc_310l = 269;
static const char
   isc_310 [] = {
   4,2,4,1,9,0,9,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,4,0,2,0,41,3,
   0,32,0,41,3,0,32,0,12,0,2,7,'C',1,'J',24,'R','D','B','$','P',
   'R','O','C','E','D','U','R','E','_','P','A','R','A','M','E',
   'T','E','R','S',0,'G',58,47,23,0,18,'R','D','B','$','P','R',
   'O','C','E','D','U','R','E','_','N','A','M','E',25,0,1,0,47,
   23,0,18,'R','D','B','$','P','A','R','A','M','E','T','E','R',
   '_','N','A','M','E',25,0,0,0,-1,14,1,2,1,23,0,18,'R','D','B',
   '$','D','E','F','A','U','L','T','_','S','O','U','R','C','E',
   41,1,0,0,6,0,1,21,8,0,1,0,0,0,25,1,1,0,1,23,0,23,'R','D','B',
   '$','P','A','R','A','M','E','T','E','R','_','M','E','C','H',
   'A','N','I','S','M',41,1,3,0,2,0,1,23,0,13,'R','D','B','$','N',
   'U','L','L','_','F','L','A','G',41,1,5,0,4,0,1,23,0,16,'R','D',
   'B','$','C','O','L','L','A','T','I','O','N','_','I','D',41,1,
   8,0,7,0,-1,14,1,1,21,8,0,0,0,0,0,25,1,1,0,-1,-1,'L'
   };	/* end of blr string for request isc_310 */

static isc_req_handle
   isc_324 = 0;		/* request handle */

static const short
   isc_325l = 536;
static const char
   isc_325 [] = {
   4,2,4,1,16,0,9,0,41,3,0,32,0,41,3,0,32,0,41,3,0,32,0,7,0,7,0,
   7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,4,0,2,0,41,3,0,32,0,
   7,0,12,0,2,7,'C',2,'J',24,'R','D','B','$','P','R','O','C','E',
   'D','U','R','E','_','P','A','R','A','M','E','T','E','R','S',
   0,'J',10,'R','D','B','$','F','I','E','L','D','S',1,'G',58,47,
   23,0,18,'R','D','B','$','P','R','O','C','E','D','U','R','E',
   '_','N','A','M','E',25,0,0,0,58,47,23,0,16,'R','D','B','$','F',
   'I','E','L','D','_','S','O','U','R','C','E',23,1,14,'R','D',
   'B','$','F','I','E','L','D','_','N','A','M','E',47,23,0,18,'R',
   'D','B','$','P','A','R','A','M','E','T','E','R','_','T','Y',
   'P','E',25,0,1,0,'F',1,'H',23,0,20,'R','D','B','$','P','A','R',
   'A','M','E','T','E','R','_','N','U','M','B','E','R',-1,14,1,
   2,1,23,1,18,'R','D','B','$','D','E','F','A','U','L','T','_',
   'S','O','U','R','C','E',41,1,0,0,5,0,1,23,1,14,'R','D','B','$',
   'F','I','E','L','D','_','N','A','M','E',25,1,1,0,1,23,0,18,'R',
   'D','B','$','P','A','R','A','M','E','T','E','R','_','N','A',
   'M','E',25,1,2,0,1,23,0,18,'R','D','B','$','P','R','O','C','E',
   'D','U','R','E','_','N','A','M','E',25,1,3,0,1,21,8,0,1,0,0,
   0,25,1,4,0,1,23,1,16,'R','D','B','$','C','O','L','L','A','T',
   'I','O','N','_','I','D',41,1,8,0,7,0,1,23,1,16,'R','D','B','$',
   'F','I','E','L','D','_','L','E','N','G','T','H',25,1,9,0,1,23,
   1,20,'R','D','B','$','C','H','A','R','A','C','T','E','R','_',
   'L','E','N','G','T','H',41,1,11,0,10,0,1,23,1,15,'R','D','B',
   '$','F','I','E','L','D','_','S','C','A','L','E',25,1,12,0,1,
   23,1,20,'R','D','B','$','C','H','A','R','A','C','T','E','R',
   '_','S','E','T','_','I','D',41,1,13,0,6,0,1,23,1,14,'R','D',
   'B','$','F','I','E','L','D','_','T','Y','P','E',25,1,14,0,1,
   23,1,15,'R','D','B','$','S','Y','S','T','E','M','_','F','L',
   'A','G',25,1,15,0,-1,14,1,1,21,8,0,0,0,0,0,25,1,4,0,-1,-1,'L'
   
   };	/* end of blr string for request isc_325 */

static isc_req_handle
   isc_346 = 0;		/* request handle */

static const short
   isc_347l = 431;
static const char
   isc_347 [] = {
   4,2,4,1,7,0,41,3,0,32,0,41,3,0,32,0,41,3,0,32,0,41,0,0,12,0,
   7,0,7,0,7,0,4,0,1,0,41,3,0,32,0,12,0,2,7,'C',2,'J',24,'R','D',
   'B','$','R','E','L','A','T','I','O','N','_','C','O','N','S',
   'T','R','A','I','N','T','S',0,'J',11,'R','D','B','$','I','N',
   'D','I','C','E','S',1,'G',58,47,23,1,14,'R','D','B','$','I',
   'N','D','E','X','_','N','A','M','E',23,0,14,'R','D','B','$',
   'I','N','D','E','X','_','N','A','M','E',58,57,47,23,0,19,'R',
   'D','B','$','C','O','N','S','T','R','A','I','N','T','_','T',
   'Y','P','E',21,15,3,0,11,0,'P','R','I','M','A','R','Y',32,'K',
   'E','Y',47,23,0,19,'R','D','B','$','C','O','N','S','T','R','A',
   'I','N','T','_','T','Y','P','E',21,15,3,0,6,0,'U','N','I','Q',
   'U','E',47,23,0,17,'R','D','B','$','R','E','L','A','T','I','O',
   'N','_','N','A','M','E',25,0,0,0,'F',2,'H',23,0,19,'R','D','B',
   '$','C','O','N','S','T','R','A','I','N','T','_','T','Y','P',
   'E','H',23,0,19,'R','D','B','$','C','O','N','S','T','R','A',
   'I','N','T','_','N','A','M','E',-1,14,1,2,1,23,0,14,'R','D',
   'B','$','I','N','D','E','X','_','N','A','M','E',25,1,0,0,1,23,
   1,14,'R','D','B','$','I','N','D','E','X','_','N','A','M','E',
   25,1,1,0,1,23,0,19,'R','D','B','$','C','O','N','S','T','R','A',
   'I','N','T','_','N','A','M','E',25,1,2,0,1,23,0,19,'R','D','B',
   '$','C','O','N','S','T','R','A','I','N','T','_','T','Y','P',
   'E',25,1,3,0,1,21,8,0,1,0,0,0,25,1,4,0,1,23,1,14,'R','D','B',
   '$','I','N','D','E','X','_','T','Y','P','E',41,1,6,0,5,0,-1,
   14,1,1,21,8,0,0,0,0,0,25,1,4,0,-1,-1,'L'
   };	/* end of blr string for request isc_347 */

static isc_req_handle
   isc_358 = 0;		/* request handle */

static const short
   isc_359l = 280;
static const char
   isc_359 [] = {
   4,2,4,1,2,0,41,3,0,32,0,7,0,4,0,2,0,41,3,0,32,0,41,3,0,32,0,
   12,0,2,7,'C',2,'J',24,'R','D','B','$','R','E','L','A','T','I',
   'O','N','_','C','O','N','S','T','R','A','I','N','T','S',0,'J',
   21,'R','D','B','$','C','H','E','C','K','_','C','O','N','S','T',
   'R','A','I','N','T','S',1,'G',58,47,23,1,16,'R','D','B','$',
   'T','R','I','G','G','E','R','_','N','A','M','E',25,0,1,0,58,
   47,23,1,19,'R','D','B','$','C','O','N','S','T','R','A','I','N',
   'T','_','N','A','M','E',23,0,19,'R','D','B','$','C','O','N',
   'S','T','R','A','I','N','T','_','N','A','M','E',58,47,23,0,19,
   'R','D','B','$','C','O','N','S','T','R','A','I','N','T','_',
   'T','Y','P','E',21,15,3,0,8,0,'N','O','T',32,'N','U','L','L',
   47,23,0,17,'R','D','B','$','R','E','L','A','T','I','O','N','_',
   'N','A','M','E',25,0,0,0,-1,14,1,2,1,23,1,19,'R','D','B','$',
   'C','O','N','S','T','R','A','I','N','T','_','N','A','M','E',
   25,1,0,0,1,21,8,0,1,0,0,0,25,1,1,0,-1,14,1,1,21,8,0,0,0,0,0,
   25,1,1,0,-1,-1,'L'
   };	/* end of blr string for request isc_359 */

static isc_req_handle
   isc_366 = 0;		/* request handle */

static const short
   isc_367l = 179;
static const char
   isc_367 [] = {
   4,2,4,1,5,0,7,0,7,0,7,0,7,0,7,0,4,0,1,0,41,3,0,32,0,12,0,2,7,
   'C',1,'J',10,'R','D','B','$','F','I','E','L','D','S',0,'G',47,
   23,0,14,'R','D','B','$','F','I','E','L','D','_','N','A','M',
   'E',25,0,0,0,-1,14,1,2,1,21,8,0,1,0,0,0,25,1,0,0,1,23,0,15,'R',
   'D','B','$','F','I','E','L','D','_','S','C','A','L','E',25,1,
   1,0,1,23,0,18,'R','D','B','$','F','I','E','L','D','_','S','U',
   'B','_','T','Y','P','E',25,1,2,0,1,23,0,19,'R','D','B','$','F',
   'I','E','L','D','_','P','R','E','C','I','S','I','O','N',41,1,
   4,0,3,0,-1,14,1,1,21,8,0,0,0,0,0,25,1,0,0,-1,-1,'L'
   };	/* end of blr string for request isc_367 */

static isc_req_handle
   isc_376 = 0;		/* request handle */

static const short
   isc_377l = 831;
static const char
   isc_377 [] = {
   4,2,4,1,30,0,41,3,0,32,0,9,0,41,3,0,32,0,9,0,9,0,41,3,0,32,0,
   41,0,0,0,1,41,3,0,32,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,
   0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,4,0,1,0,41,
   3,0,32,0,12,0,2,7,'C',3,'J',13,'R','D','B','$','R','E','L','A',
   'T','I','O','N','S',0,'J',19,'R','D','B','$','R','E','L','A',
   'T','I','O','N','_','F','I','E','L','D','S',1,'J',10,'R','D',
   'B','$','F','I','E','L','D','S',2,'G',58,47,23,1,16,'R','D',
   'B','$','F','I','E','L','D','_','S','O','U','R','C','E',23,2,
   14,'R','D','B','$','F','I','E','L','D','_','N','A','M','E',58,
   47,23,1,17,'R','D','B','$','R','E','L','A','T','I','O','N','_',
   'N','A','M','E',23,0,17,'R','D','B','$','R','E','L','A','T',
   'I','O','N','_','N','A','M','E',47,23,0,17,'R','D','B','$','R',
   'E','L','A','T','I','O','N','_','N','A','M','E',25,0,0,0,'F',
   2,'H',23,1,18,'R','D','B','$','F','I','E','L','D','_','P','O',
   'S','I','T','I','O','N','H',23,1,14,'R','D','B','$','F','I',
   'E','L','D','_','N','A','M','E',-1,14,1,2,1,23,1,17,'R','D',
   'B','$','R','E','L','A','T','I','O','N','_','N','A','M','E',
   25,1,0,0,1,23,1,18,'R','D','B','$','D','E','F','A','U','L','T',
   '_','S','O','U','R','C','E',41,1,1,0,10,0,1,23,2,14,'R','D',
   'B','$','F','I','E','L','D','_','N','A','M','E',25,1,2,0,1,23,
   2,19,'R','D','B','$','C','O','M','P','U','T','E','D','_','S',
   'O','U','R','C','E',41,1,3,0,27,0,1,23,2,16,'R','D','B','$',
   'C','O','M','P','U','T','E','D','_','B','L','R',41,1,4,0,28,
   0,1,23,1,14,'R','D','B','$','F','I','E','L','D','_','N','A',
   'M','E',25,1,5,0,1,23,0,17,'R','D','B','$','E','X','T','E','R',
   'N','A','L','_','F','I','L','E',41,1,6,0,29,0,1,23,0,14,'R',
   'D','B','$','O','W','N','E','R','_','N','A','M','E',25,1,7,0,
   1,21,8,0,1,0,0,0,25,1,8,0,1,23,1,13,'R','D','B','$','N','U',
   'L','L','_','F','L','A','G',25,1,9,0,1,23,2,16,'R','D','B','$',
   'C','O','L','L','A','T','I','O','N','_','I','D',41,1,12,0,11,
   0,1,23,2,18,'R','D','B','$','S','E','G','M','E','N','T','_',
   'L','E','N','G','T','H',25,1,14,0,1,23,2,18,'R','D','B','$',
   'F','I','E','L','D','_','S','U','B','_','T','Y','P','E',25,1,
   15,0,1,23,2,14,'R','D','B','$','D','I','M','E','N','S','I','O',
   'N','S',41,1,17,0,16,0,1,23,2,16,'R','D','B','$','F','I','E',
   'L','D','_','L','E','N','G','T','H',25,1,18,0,1,23,2,20,'R',
   'D','B','$','C','H','A','R','A','C','T','E','R','_','L','E',
   'N','G','T','H',41,1,20,0,19,0,1,23,2,15,'R','D','B','$','F',
   'I','E','L','D','_','S','C','A','L','E',25,1,21,0,1,23,2,20,
   'R','D','B','$','C','H','A','R','A','C','T','E','R','_','S',
   'E','T','_','I','D',41,1,22,0,13,0,1,23,1,16,'R','D','B','$',
   'C','O','L','L','A','T','I','O','N','_','I','D',41,1,24,0,23,
   0,1,23,2,14,'R','D','B','$','F','I','E','L','D','_','T','Y',
   'P','E',25,1,25,0,1,23,2,15,'R','D','B','$','S','Y','S','T',
   'E','M','_','F','L','A','G',25,1,26,0,-1,14,1,1,21,8,0,0,0,0,
   0,25,1,8,0,-1,-1,'L'
   };	/* end of blr string for request isc_377 */

static isc_req_handle
   isc_411 = 0;		/* request handle */

static const short
   isc_412l = 149;
static const char
   isc_412 [] = {
   4,2,4,1,2,0,7,0,7,0,4,0,1,0,41,3,0,32,0,12,0,2,7,'C',1,'J',13,
   'R','D','B','$','R','E','L','A','T','I','O','N','S',0,'G',58,
   47,23,0,17,'R','D','B','$','R','E','L','A','T','I','O','N','_',
   'N','A','M','E',25,0,0,0,59,61,23,0,17,'R','D','B','$','R','E',
   'L','A','T','I','O','N','_','T','Y','P','E',-1,14,1,2,1,21,8,
   0,1,0,0,0,25,1,0,0,1,23,0,17,'R','D','B','$','R','E','L','A',
   'T','I','O','N','_','T','Y','P','E',25,1,1,0,-1,14,1,1,21,8,
   0,0,0,0,0,25,1,0,0,-1,-1,'L'
   };	/* end of blr string for request isc_412 */


#define gds_blob_null	isc_blob_null	/* compatibility symbols */
#define gds_status	isc_status
#define gds_status2	isc_status2
#define gds_array_length	isc_array_length
#define gds_count	isc_count
#define gds_slack	isc_slack
#define gds_utility	isc_utility	/* end of compatibility symbols */

#ifndef isc_version4
    Generate a compile-time error.
    Picking up a V3 include file after preprocessing with V4 GPRE.
#endif

/**** end of GPRE definitions ****/


static bool extract_rel_constraints(const char* relation_name);
static void get_procedure_args(const char*);
static void list_all_grants();
static processing_state list_all_grants2(bool, const SCHAR*);
static void list_all_procs();
static void list_all_tables(LegacyTables flag, SSHORT);
static void list_all_triggers();
static void list_check();
static void list_charsets();
static void list_collations();
static void list_create_db();
static void list_domain_table(const SCHAR*, SSHORT);
static void list_domains(SSHORT);
static void list_exception();
static void list_filters();
static void list_foreign();
static void list_functions();
static void list_generators();
static void list_index();
static void list_views();

extern const char* trigger_action(int);

static const char* Procterm = "^";	// TXNN: script use only

/* Maybe 512 would be really enough as Print_buffer size, but
   as we have PRINT_BUFFER_LENGTH in isql.h, we should use it
   FSG 17.Nov.2000
*/

static TEXT Print_buffer[PRINT_BUFFER_LENGTH];
static TEXT SQL_identifier[BUFFER_LENGTH128];
static TEXT SQL_identifier2[BUFFER_XLARGE];



int EXTRACT_ddl(LegacyTables flag, const SCHAR* tabname)
{
/**************************************
 *
 *	E X T R A C T _ d d l
 *
 **************************************
 *
 * Functional description
 *	Extract all sql information
 *	0 flag means SQL only tables. 1 flag means all tables
 *
 **************************************/
	bool did_attach = false;

	if (!DB)
	{
		if (isc_attach_database(gds_status, 0, isqlGlob.global_Db_name, &DB, 0, NULL))
		{
			ISQL_errmsg(gds_status);
			return FINI_ERROR;
		}
		did_attach = true;

		// Make it read owner name to display grantor correctly
		SHOW_read_owner();
	}

	ISQL_get_version(false);
	if (isqlGlob.SQL_dialect != isqlGlob.db_SQL_dialect)
	{
		isqlGlob.printf("/*=========================================================*/%s", NEWLINE);
		isqlGlob.printf("/*=                                                      ==*/%s", NEWLINE);
		isqlGlob.printf("/*=     Command Line -sqldialect %d is overwritten by    ==*/%s",
				isqlGlob.SQL_dialect, NEWLINE);
		isqlGlob.printf("/*=     Database SQL Dialect %d.                          ==*/%s",
				isqlGlob.db_SQL_dialect, NEWLINE);
		isqlGlob.printf("/*=                                                      ==*/%s", NEWLINE);
		isqlGlob.printf("/*=========================================================*/%s", NEWLINE);
	}
	isqlGlob.printf(NEWLINE);

	isqlGlob.printf("SET SQL DIALECT %d; %s", isqlGlob.db_SQL_dialect, NEWLINE);

	isqlGlob.printf(NEWLINE);

	bool did_start = false;
	if (!gds_trans)
	{
		if (isc_start_transaction(gds_status, &gds_trans, 1, &DB, 0, NULL))
		{
			ISQL_errmsg(gds_status);
			return FINI_ERROR;
		}
		did_start = true;
	}

	const SSHORT default_char_set_id = ISQL_get_default_char_set_id();
	int ret_code = FINI_OK;

	// If a table name was passed, extract only that table and domains
	if (*tabname)
	{
		if (EXTRACT_list_table(tabname, NULL, true, default_char_set_id))
		{
			SCHAR errbuf[MSG_LENGTH];
			ISQL_msg_get(NOT_FOUND_MSG, errbuf, SafeArg() << tabname);
			STDERROUT(errbuf);
			ret_code = FINI_ERROR;
		}
	}
	else
	{
		list_create_db();
		list_filters();
		list_charsets();
		list_collations();
		list_functions();
		list_generators();
		list_domains(default_char_set_id);
		list_all_tables(flag, default_char_set_id);
		list_index();
		list_foreign();
		list_views();
		list_check();
		list_exception();
		list_all_procs();
		list_all_triggers();
		list_all_grants();
		SHOW_comments(false); // Let's make this an option later.
	}

	if (gds_trans && did_start)
		if (isc_commit_transaction(gds_status, &gds_trans))
		{
			ISQL_errmsg(gds_status);
			return FINI_ERROR;
		}

	if (DB && did_attach)
	{
		if (isc_detach_database(gds_status, &DB))
		{
			ISQL_errmsg(gds_status);
			return FINI_ERROR;
		}
		DB = 0;
	}

	return ret_code;
}


processing_state EXTRACT_list_grants(const SCHAR* terminator)
{
/**************************************
 *
 *	E X T R A C T _ l i s t _ g r a n t s
 *
 **************************************
 *
 * Functional description
 *	Print the permissions on all user tables, views and procedures.
 *
 **************************************/
	return list_all_grants2(false, terminator);
}


int EXTRACT_list_table(const SCHAR* relation_name,
						  const SCHAR* new_name,
						  bool domain_flag,
						  SSHORT default_char_set_id)
{
   struct isc_363_struct {
          char  isc_364 [32];	/* RDB$CONSTRAINT_NAME */
          short isc_365;	/* isc_utility */
   } isc_363;
   struct isc_360_struct {
          char  isc_361 [32];	/* RDB$RELATION_NAME */
          char  isc_362 [32];	/* RDB$FIELD_NAME */
   } isc_360;
   struct isc_370_struct {
          short isc_371;	/* isc_utility */
          short isc_372;	/* RDB$FIELD_SCALE */
          short isc_373;	/* RDB$FIELD_SUB_TYPE */
          short isc_374;	/* gds__null_flag */
          short isc_375;	/* RDB$FIELD_PRECISION */
   } isc_370;
   struct isc_368_struct {
          char  isc_369 [32];	/* RDB$FIELD_NAME */
   } isc_368;
   struct isc_380_struct {
          char  isc_381 [32];	/* RDB$RELATION_NAME */
          ISC_QUAD isc_382;	/* RDB$DEFAULT_SOURCE */
          char  isc_383 [32];	/* RDB$FIELD_NAME */
          ISC_QUAD isc_384;	/* RDB$COMPUTED_SOURCE */
          ISC_QUAD isc_385;	/* RDB$COMPUTED_BLR */
          char  isc_386 [32];	/* RDB$FIELD_NAME */
          char  isc_387 [256];	/* RDB$EXTERNAL_FILE */
          char  isc_388 [32];	/* RDB$OWNER_NAME */
          short isc_389;	/* isc_utility */
          short isc_390;	/* RDB$NULL_FLAG */
          short isc_391;	/* gds__null_flag */
          short isc_392;	/* gds__null_flag */
          short isc_393;	/* RDB$COLLATION_ID */
          short isc_394;	/* gds__null_flag */
          short isc_395;	/* RDB$SEGMENT_LENGTH */
          short isc_396;	/* RDB$FIELD_SUB_TYPE */
          short isc_397;	/* gds__null_flag */
          short isc_398;	/* RDB$DIMENSIONS */
          short isc_399;	/* RDB$FIELD_LENGTH */
          short isc_400;	/* gds__null_flag */
          short isc_401;	/* RDB$CHARACTER_LENGTH */
          short isc_402;	/* RDB$FIELD_SCALE */
          short isc_403;	/* RDB$CHARACTER_SET_ID */
          short isc_404;	/* gds__null_flag */
          short isc_405;	/* RDB$COLLATION_ID */
          short isc_406;	/* RDB$FIELD_TYPE */
          short isc_407;	/* RDB$SYSTEM_FLAG */
          short isc_408;	/* gds__null_flag */
          short isc_409;	/* gds__null_flag */
          short isc_410;	/* gds__null_flag */
   } isc_380;
   struct isc_378_struct {
          char  isc_379 [32];	/* RDB$RELATION_NAME */
   } isc_378;
   struct isc_415_struct {
          short isc_416;	/* isc_utility */
          short isc_417;	/* RDB$RELATION_TYPE */
   } isc_415;
   struct isc_413_struct {
          char  isc_414 [32];	/* RDB$RELATION_NAME */
   } isc_413;
/**************************************
 *
 *	E X T R A C T _ l i s t _ t a b l e
 *
 **************************************
 *
 * Functional description
 *	Shows columns, types, info for a given table name
 *	and text of views.
 *	Use a GDML query to get the info and print it.
 *	If a new_name is passed, substitute it for relation_name
 *
 *	relation_name -- Name of table to investigate
 *	new_name -- Name of a new name for a replacement table
 *	domain_flag -- extract needed domains before the table
 *	default_char_set_id -- character set def to supress
 *
 **************************************/
/**************************************
 *	default_char_set_id warrants special
 *	consideration.  If the metadata for a
 *	table is being extracted when there is
 *	really no need to redundantly and repeatedly
 *	list the databases default character set
 *	for every field.
 *
 *	At the same time there is a need to list
 *	the character set NONE when it is not
 *	the default character set for the database.
 *
 *	EXCEPT!  If the metadata is being extracted
 *	with the intention of coping that tables structure
 *	into another database, and it is not possible
 *	to know the default character set for the
 *	target database, then list every fields
 *	character set.  This includes the character
 *	set NONE.
 *
 *	Fields with no character set definition will
 *	not have any character set listed.
 *
 *	Use -1 as the default_char_set_id
 *	in this case.
 *
 *	POTENTIAL TRAP!  Consider the following:
 *	When copying a table from one database
 *	to another how should fields using the
 *	default character set be handled?
 *
 *	If both databases have the same default
 *	character set, then there is no problem
 *	or confusion.
 *
 *	If the databases have different default
 *	character sets then should fields using
 *	the default is the source database use
 *	the default of the target database?
 *
 **************************************/

	bool first = true;
	SCHAR char_sets[86];
	//USHORT rel_flags = 0;
	//bool intchar = false;
	// CVC: shouldn't this var be initialized inside the FOR statement instead?
	// CVC: 2004.12.03: I discovered someone made this variable obsolete;
	// it's set but never used. Hope the change was right. I commented it.

	rel_t rel_type = rel_persistent;

	if (ENCODE_ODS(isqlGlob.major_ods, isqlGlob.minor_ods) >= ODS_11_1)
	{
		/*FOR RT IN RDB$RELATIONS
			WITH RT.RDB$RELATION_NAME EQ relation_name AND
			RT.RDB$RELATION_TYPE NOT MISSING*/
		{
                if (!isc_411)
                   isc_compile_request2 (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &isc_411, (short) sizeof(isc_412), (char*) isc_412);
		isc_vtov ((const char*) relation_name, (char*) isc_413.isc_414, 32);
		if (isc_411)
		   {
                   isc_start_and_send (isc_status, (FB_API_HANDLE*) &isc_411, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 32, &isc_413, (short) 0);
		   }
		if (!isc_status [1]) {
		while (1)
		   {
                   isc_receive (isc_status, (FB_API_HANDLE*) &isc_411, (short) 1, (short) 4, &isc_415, (short) 0);
		   if (!isc_415.isc_416 || isc_status [1]) break;

			rel_type = (rel_t) /*RT.RDB$RELATION_TYPE*/
					   isc_415.isc_417;

		/*END_FOR*/
		   }
		   };
		/*ON_ERROR*/
		if (isc_status [1])
		   {
			ISQL_errmsg(gds_status);
			return FINI_ERROR;
		/*END_ERROR;*/
		   }
		}
	}

// Query to obtain relation detail information

	/*FOR REL IN RDB$RELATIONS CROSS
		RFR IN RDB$RELATION_FIELDS CROSS
		FLD IN RDB$FIELDS WITH
		RFR.RDB$FIELD_SOURCE EQ FLD.RDB$FIELD_NAME AND
		RFR.RDB$RELATION_NAME EQ REL.RDB$RELATION_NAME AND
		REL.RDB$RELATION_NAME EQ relation_name
		SORTED BY RFR.RDB$FIELD_POSITION, RFR.RDB$FIELD_NAME*/
	{
        if (!isc_376)
           isc_compile_request2 (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &isc_376, (short) sizeof(isc_377), (char*) isc_377);
	isc_vtov ((const char*) relation_name, (char*) isc_378.isc_379, 32);
	if (isc_376)
	   {
           isc_start_and_send (isc_status, (FB_API_HANDLE*) &isc_376, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 32, &isc_378, (short) 0);
	   }
	if (!isc_status [1]) {
	while (1)
	   {
           isc_receive (isc_status, (FB_API_HANDLE*) &isc_376, (short) 1, (short) 452, &isc_380, (short) 0);
	   if (!isc_380.isc_389 || isc_status [1]) break;

		SSHORT collation = 0;
		SSHORT char_set_id = 0;

		if (first)
		{
			first = false;
			// Do we need to print domains
			if (domain_flag)
				list_domain_table (relation_name, default_char_set_id);

			fb_utils::exact_name(/*REL.RDB$OWNER_NAME*/
					     isc_380.isc_388);
			isqlGlob.printf("%s/* Table: %s, Owner: %s */%s",
					 NEWLINE,
					 relation_name,
					 /*REL.RDB$OWNER_NAME*/
					 isc_380.isc_388,
					 NEWLINE);

			if (rel_type == rel_global_temp_preserve || rel_type == rel_global_temp_delete)
			{
				isqlGlob.printf("CREATE GLOBAL TEMPORARY TABLE ");
			}
			else
			{
				isqlGlob.printf("CREATE TABLE ");
			}

			if (isqlGlob.db_SQL_dialect > SQL_DIALECT_V6_TRANSITION)
			{
				if (new_name)
					ISQL_copy_SQL_id (new_name, SQL_identifier, DBL_QUOTE);
				else
					ISQL_copy_SQL_id (relation_name, SQL_identifier, DBL_QUOTE);
				isqlGlob.printf("%s ", SQL_identifier);
			}
			else
			{
				isqlGlob.printf("%s ", new_name ? new_name : relation_name);
			}

			if (!/*REL.RDB$EXTERNAL_FILE.NULL*/
			     isc_380.isc_410)
			{
				ISQL_copy_SQL_id (/*REL.RDB$EXTERNAL_FILE*/
						  isc_380.isc_387, SQL_identifier2, SINGLE_QUOTE);
				isqlGlob.printf("EXTERNAL FILE %s ", SQL_identifier2);
			}
			isqlGlob.printf("(");
		}
		else
		{
			isqlGlob.printf(",%s%s", NEWLINE, TAB_AS_SPACES);
		}

		if (isqlGlob.db_SQL_dialect > SQL_DIALECT_V6_TRANSITION)
		{
			ISQL_copy_SQL_id (fb_utils::exact_name(/*RFR.RDB$FIELD_NAME*/
							       isc_380.isc_386), SQL_identifier, DBL_QUOTE);
			isqlGlob.printf("%s ", SQL_identifier);
		}
		else
			isqlGlob.printf("%s ", fb_utils::exact_name(/*RFR.RDB$FIELD_NAME*/
								    isc_380.isc_386));

		/*
		** Check first for computed fields, then domains.
		** If this is a known domain, then just print the domain rather than type
		** Domains won't have length, array, or blob definitions, but they
		** may have not null, default and check overriding their definitions
		*/

		if (!/*FLD.RDB$COMPUTED_BLR.NULL*/
		     isc_380.isc_409)
		{
			isqlGlob.printf("COMPUTED BY ");
			if (!/*FLD.RDB$COMPUTED_SOURCE.NULL*/
			     isc_380.isc_408)
				ISQL_print_validation (isqlGlob.Out, &/*FLD.RDB$COMPUTED_SOURCE*/
								      isc_380.isc_384, true, gds_trans);
		}
		else if (!(fb_utils::implicit_domain(/*FLD.RDB$FIELD_NAME*/
						     isc_380.isc_383) && /*FLD.RDB$SYSTEM_FLAG*/
     isc_380.isc_407 != 1))
		{
			fb_utils::exact_name(/*FLD.RDB$FIELD_NAME*/
					     isc_380.isc_383);
			if (isqlGlob.db_SQL_dialect > SQL_DIALECT_V6_TRANSITION)
			{
				ISQL_copy_SQL_id (/*FLD.RDB$FIELD_NAME*/
						  isc_380.isc_383, SQL_identifier, DBL_QUOTE);
				isqlGlob.prints(SQL_identifier);
			}
			else
				isqlGlob.prints(/*FLD.RDB$FIELD_NAME*/
						isc_380.isc_383);

			// International character sets
			// Print only the character set
			if ((/*FLD.RDB$FIELD_TYPE*/
			     isc_380.isc_406 == T_CHAR || /*FLD.RDB$FIELD_TYPE*/
	      isc_380.isc_406 == VARCHAR) &&
				!/*RFR.RDB$COLLATION_ID.NULL*/
				 isc_380.isc_404 && /*RFR.RDB$COLLATION_ID*/
    isc_380.isc_405)
			{
				char_sets[0] = '\0';
				collation = /*RFR.RDB$COLLATION_ID*/
					    isc_380.isc_405;
				char_set_id = /*FLD.RDB$CHARACTER_SET_ID*/
					      isc_380.isc_403;
				ISQL_get_character_sets (/*FLD.RDB$CHARACTER_SET_ID*/
							 isc_380.isc_403, 0, true, false, char_sets);
				if (char_sets[0])
					isqlGlob.prints(char_sets);
			}
		}
		else
		{
			// Look through types array
			for (int i = 0; Column_types[i].type; i++)
			{
				if (/*FLD.RDB$FIELD_TYPE*/
				    isc_380.isc_406 == Column_types[i].type)
				{
					bool precision_known = false;

					if (isqlGlob.major_ods >= ODS_VERSION10)
					{
						// Handle Integral subtypes NUMERIC and DECIMAL
						if ((/*FLD.RDB$FIELD_TYPE*/
						     isc_380.isc_406 == SMALLINT) ||
							(/*FLD.RDB$FIELD_TYPE*/
							 isc_380.isc_406 == INTEGER)  ||
							(/*FLD.RDB$FIELD_TYPE*/
							 isc_380.isc_406 == BIGINT))
						{
							/*FOR FLD1 IN RDB$FIELDS WITH
								FLD1.RDB$FIELD_NAME EQ FLD.RDB$FIELD_NAME*/
							{
                                                        if (!isc_366)
                                                           isc_compile_request2 (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &isc_366, (short) sizeof(isc_367), (char*) isc_367);
							isc_vtov ((const char*) isc_380.isc_383, (char*) isc_368.isc_369, 32);
							if (isc_366)
							   {
                                                           isc_start_and_send (isc_status, (FB_API_HANDLE*) &isc_366, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 32, &isc_368, (short) 0);
							   }
							if (!isc_status [1]) {
							while (1)
							   {
                                                           isc_receive (isc_status, (FB_API_HANDLE*) &isc_366, (short) 1, (short) 10, &isc_370, (short) 0);
							   if (!isc_370.isc_371 || isc_status [1]) break;

								/* We are ODS >= 10 and could be any Dialect */
								if (!/*FLD1.RDB$FIELD_PRECISION.NULL*/
								     isc_370.isc_374)
								{
									/* We are Dialect >=3 since FIELD_PRECISION is non-NULL */
									if (/*FLD1.RDB$FIELD_SUB_TYPE*/
									    isc_370.isc_373 > 0 &&
										/*FLD1.RDB$FIELD_SUB_TYPE*/
										isc_370.isc_373 <= MAX_INTSUBTYPES)
									{
										sprintf (Print_buffer, "%s(%d, %d)",
												 Integral_subtypes[/*FLD1.RDB$FIELD_SUB_TYPE*/
														   isc_370.isc_373],
												 /*FLD1.RDB$FIELD_PRECISION*/
												 isc_370.isc_375,
												 -/*FLD1.RDB$FIELD_SCALE*/
												  isc_370.isc_372);
										precision_known = true;
									}
								}
							/*END_FOR*/
							   }
							   };
							/*ON_ERROR*/
							if (isc_status [1])
							   {
								ISQL_errmsg (isc_status);
								return ps_ERR;
							/*END_ERROR;*/
							   }
							}
						}
					}

					if (!precision_known)
					{

						// Take a stab at numerics and decimals
						if ((/*FLD.RDB$FIELD_TYPE*/
						     isc_380.isc_406 == SMALLINT) && (/*FLD.RDB$FIELD_SCALE*/
		  isc_380.isc_402 < 0))
						{
							sprintf (Print_buffer, "NUMERIC(4, %d)", -/*FLD.RDB$FIELD_SCALE*/
												  isc_380.isc_402);
						}
						else if ((/*FLD.RDB$FIELD_TYPE*/
							  isc_380.isc_406 == INTEGER) && (/*FLD.RDB$FIELD_SCALE*/
		 isc_380.isc_402 < 0))
						{
							sprintf (Print_buffer, "NUMERIC(9, %d)", -/*FLD.RDB$FIELD_SCALE*/
												  isc_380.isc_402);
						}
						else if ((/*FLD.RDB$FIELD_TYPE*/
							  isc_380.isc_406 == DOUBLE_PRECISION) && (/*FLD.RDB$FIELD_SCALE*/
			  isc_380.isc_402 < 0))
						{
							sprintf (Print_buffer, "NUMERIC(15, %d)", -/*FLD.RDB$FIELD_SCALE*/
												   isc_380.isc_402);
						}
						else
							sprintf (Print_buffer, "%s", Column_types[i].type_name);
					}
					isqlGlob.prints(Print_buffer);
					break;
				}
			}

			if ((/*FLD.RDB$FIELD_TYPE*/
			     isc_380.isc_406 == T_CHAR) || (/*FLD.RDB$FIELD_TYPE*/
		isc_380.isc_406 == VARCHAR))
			{
				if (/*FLD.RDB$CHARACTER_LENGTH.NULL*/
				    isc_380.isc_400)
				{

					isqlGlob.printf("(%d)", /*FLD.RDB$FIELD_LENGTH*/
								isc_380.isc_399);
				}
				else
				{
					isqlGlob.printf("(%d)", /*FLD.RDB$CHARACTER_LENGTH*/
								isc_380.isc_401);
				}
			}

			// Catch arrays after printing the type

			if (!/*FLD.RDB$DIMENSIONS.NULL*/
			     isc_380.isc_397)
				ISQL_array_dimensions (/*FLD.RDB$FIELD_NAME*/
						       isc_380.isc_383);

			if (/*FLD.RDB$FIELD_TYPE*/
			    isc_380.isc_406 == BLOB)
			{
				const int subtype = /*FLD.RDB$FIELD_SUB_TYPE*/
						    isc_380.isc_396;
				isqlGlob.printf(" SUB_TYPE ");
				if ((subtype > 0) && (subtype <= MAX_BLOBSUBTYPES))
					isqlGlob.prints(Sub_types[subtype]);
				else
				{
					isqlGlob.printf("%d", subtype);
				}
				isqlGlob.printf(" SEGMENT SIZE %u", (USHORT) /*FLD.RDB$SEGMENT_LENGTH*/
									     isc_380.isc_395);
			}

			// International character sets
			if ((/*FLD.RDB$FIELD_TYPE*/
			     isc_380.isc_406 == T_CHAR || /*FLD.RDB$FIELD_TYPE*/
	      isc_380.isc_406 == VARCHAR ||
				 /*FLD.RDB$FIELD_TYPE*/
				 isc_380.isc_406 == BLOB) &&
				!/*FLD.RDB$CHARACTER_SET_ID.NULL*/
				 isc_380.isc_394)
			{
				char_sets[0] = '\0';

				// Override rdb$fields id with relation_fields if present

				if (!/*RFR.RDB$COLLATION_ID.NULL*/
				     isc_380.isc_404)
					collation = /*RFR.RDB$COLLATION_ID*/
						    isc_380.isc_405;
				else if (!/*FLD.RDB$COLLATION_ID.NULL*/
					  isc_380.isc_392)
					collation = /*FLD.RDB$COLLATION_ID*/
						    isc_380.isc_393;

				if (!/*FLD.RDB$CHARACTER_SET_ID.NULL*/
				     isc_380.isc_394)
					char_set_id = /*FLD.RDB$CHARACTER_SET_ID*/
						      isc_380.isc_403;
				if ((char_set_id != default_char_set_id) || collation)
					ISQL_get_character_sets (char_set_id, 0, false, false, char_sets);
				if (char_sets[0])
					isqlGlob.prints(char_sets);
				// CVC: Someone deleted the code that checks intchar when handling collations
				// several lines below, so it didn't have any effect. Commented it.
				//if (!char_set_id)
				//	intchar = true;
			}
		}


		// Handle defaults for columns

		if (!/*RFR.RDB$DEFAULT_SOURCE.NULL*/
		     isc_380.isc_391)
		{
			isqlGlob.printf(" ");
			SHOW_print_metadata_text_blob (isqlGlob.Out, &/*RFR.RDB$DEFAULT_SOURCE*/
								      isc_380.isc_382);
		}

		/* The null flag is either 1 or null (for nullable) .  if there is
		**  a constraint name, print that too.  Domains cannot have named
		**  constraints.  The column name is in rdb$trigger_name in
		**  rdb$check_constraints.  We hope we get at most one row back.
		*/

		if (/*RFR.RDB$NULL_FLAG*/
		    isc_380.isc_390 == 1)
		{
			/*FOR RCO IN RDB$RELATION_CONSTRAINTS CROSS
				CON IN RDB$CHECK_CONSTRAINTS WITH
				CON.RDB$TRIGGER_NAME = RFR.RDB$FIELD_NAME AND
				CON.RDB$CONSTRAINT_NAME = RCO.RDB$CONSTRAINT_NAME AND
				RCO.RDB$CONSTRAINT_TYPE EQ "NOT NULL" AND
				RCO.RDB$RELATION_NAME = RFR.RDB$RELATION_NAME*/
			{
                        if (!isc_358)
                           isc_compile_request2 (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &isc_358, (short) sizeof(isc_359), (char*) isc_359);
			isc_vtov ((const char*) isc_380.isc_381, (char*) isc_360.isc_361, 32);
			isc_vtov ((const char*) isc_380.isc_386, (char*) isc_360.isc_362, 32);
			if (isc_358)
			   {
                           isc_start_and_send (isc_status, (FB_API_HANDLE*) &isc_358, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 64, &isc_360, (short) 0);
			   }
			if (!isc_status [1]) {
			while (1)
			   {
                           isc_receive (isc_status, (FB_API_HANDLE*) &isc_358, (short) 1, (short) 34, &isc_363, (short) 0);
			   if (!isc_363.isc_365 || isc_status [1]) break;

				if (!fb_utils::implicit_integrity(/*CON.RDB$CONSTRAINT_NAME*/
								  isc_363.isc_364))
				{
					fb_utils::exact_name(/*CON.RDB$CONSTRAINT_NAME*/
							     isc_363.isc_364);
					if (isqlGlob.db_SQL_dialect > SQL_DIALECT_V6_TRANSITION)
					{
						ISQL_copy_SQL_id (/*CON.RDB$CONSTRAINT_NAME*/
								  isc_363.isc_364, SQL_identifier, DBL_QUOTE);
						isqlGlob.printf(" CONSTRAINT %s", SQL_identifier);
					}
					else
						isqlGlob.printf(" CONSTRAINT %s", /*CON.RDB$CONSTRAINT_NAME*/
										  isc_363.isc_364);
				}
			/*END_FOR*/
			   }
			   };
			/*ON_ERROR*/
			if (isc_status [1])
			   {
				ISQL_errmsg (gds_status);
				return FINI_ERROR;
			/*END_ERROR;*/
			   }
			}

			isqlGlob.printf(" NOT NULL");
		}

		// Handle collations after defaults

		if (collation)
		{
			char_sets[0] = '\0';
			ISQL_get_character_sets (char_set_id, collation, true, false, char_sets);
			if (char_sets[0])
				isqlGlob.prints(char_sets);
		}
	/*END_FOR*/
	   }
	   };
	/*ON_ERROR*/
	if (isc_status [1])
	   {
		ISQL_errmsg(gds_status);
		return FINI_ERROR;
	/*END_ERROR;*/
	   }
	}

	// Do primary and unique keys only. References come later.
	if (!extract_rel_constraints(relation_name))
		return FINI_ERROR;

	// Check constaints are now deferred

	if (first) // we extracted nothing
		return FINI_ERROR;

	if (rel_type == rel_global_temp_preserve)
	{
		isqlGlob.printf(")%sON COMMIT PRESERVE ROWS", NEWLINE);
	}
	else if (rel_type == rel_global_temp_delete)
	{
		isqlGlob.printf(")%sON COMMIT DELETE ROWS", NEWLINE);
	}
	else
	{
		isqlGlob.printf(")");
	}
	isqlGlob.printf("%s%s", isqlGlob.global_Term, NEWLINE);
	return FINI_OK;
}


static bool extract_rel_constraints(const char* relation_name)
{
   struct isc_350_struct {
          char  isc_351 [32];	/* RDB$INDEX_NAME */
          char  isc_352 [32];	/* RDB$INDEX_NAME */
          char  isc_353 [32];	/* RDB$CONSTRAINT_NAME */
          char  isc_354 [12];	/* RDB$CONSTRAINT_TYPE */
          short isc_355;	/* isc_utility */
          short isc_356;	/* gds__null_flag */
          short isc_357;	/* RDB$INDEX_TYPE */
   } isc_350;
   struct isc_348_struct {
          char  isc_349 [32];	/* RDB$RELATION_NAME */
   } isc_348;
/**************************************************
 *
 *	e x t r a c t _ r e l _ c o n s t r a i n t s
 *
 **************************************************
 *
 * Functional description
 *	This function extracts the relation constraints of type PK and UK.
 *
 **************************************/

	SCHAR collist[BUFFER_LENGTH512 * 2];

	// PK and UK are always based on indices for now, hence this join is safe.
	/*FOR RELC IN RDB$RELATION_CONSTRAINTS
		CROSS IDX IN RDB$INDICES OVER RDB$INDEX_NAME
		WITH
		(RELC.RDB$CONSTRAINT_TYPE EQ "PRIMARY KEY" OR
		RELC.RDB$CONSTRAINT_TYPE EQ "UNIQUE") AND
		RELC.RDB$RELATION_NAME EQ relation_name
		SORTED BY RELC.RDB$CONSTRAINT_TYPE, RELC.RDB$CONSTRAINT_NAME*/
	{
        if (!isc_346)
           isc_compile_request2 (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &isc_346, (short) sizeof(isc_347), (char*) isc_347);
	isc_vtov ((const char*) relation_name, (char*) isc_348.isc_349, 32);
	if (isc_346)
	   {
           isc_start_and_send (isc_status, (FB_API_HANDLE*) &isc_346, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 32, &isc_348, (short) 0);
	   }
	if (!isc_status [1]) {
	while (1)
	   {
           isc_receive (isc_status, (FB_API_HANDLE*) &isc_346, (short) 1, (short) 114, &isc_350, (short) 0);
	   if (!isc_350.isc_355 || isc_status [1]) break;

		isqlGlob.printf(",%s", NEWLINE);
		fb_utils::exact_name(/*RELC.RDB$CONSTRAINT_NAME*/
				     isc_350.isc_353);
		fb_utils::exact_name(/*IDX.RDB$INDEX_NAME*/
				     isc_350.isc_352);

		// If the name of the constraint is not INTEG_..., print it
 		if (!fb_utils::implicit_integrity(/*RELC.RDB$CONSTRAINT_NAME*/
						  isc_350.isc_353))
		{
			if (isqlGlob.db_SQL_dialect > SQL_DIALECT_V6_TRANSITION)
			{
				ISQL_copy_SQL_id (/*RELC.RDB$CONSTRAINT_NAME*/
						  isc_350.isc_353, SQL_identifier, DBL_QUOTE);
				isqlGlob.printf("CONSTRAINT %s ", SQL_identifier);
			}
			else
				isqlGlob.printf("CONSTRAINT %s ", /*RELC.RDB$CONSTRAINT_NAME*/
								  isc_350.isc_353);
		}

		ISQL_get_index_segments (collist, sizeof(collist), /*RELC.RDB$INDEX_NAME*/
								   isc_350.isc_351, true);

		const bool isPK = !strncmp (/*RELC.RDB$CONSTRAINT_TYPE*/
					    isc_350.isc_354, "PRIMARY", 7);
		if (isPK)
			isqlGlob.printf("PRIMARY KEY (%s)", collist);
		else //if (!strncmp (RELC.RDB$CONSTRAINT_TYPE, "UNIQUE", 6)) // redundant
			isqlGlob.printf("UNIQUE (%s)", collist);

		// Yes, the same RDB$... naming convention is used for both domains and indices.
		const bool explicit_index = (isPK && !fb_utils::implicit_pk(/*IDX.RDB$INDEX_NAME*/
									    isc_350.isc_352) ||
			!isPK && !fb_utils::implicit_domain(/*IDX.RDB$INDEX_NAME*/
							    isc_350.isc_352)) &&
		    strcmp(/*RELC.RDB$CONSTRAINT_NAME*/
			   isc_350.isc_353, /*IDX.RDB$INDEX_NAME*/
  isc_350.isc_352);
		const bool descending_index = !/*IDX.RDB$INDEX_TYPE.NULL*/
					       isc_350.isc_356 && /*IDX.RDB$INDEX_TYPE*/
    isc_350.isc_357 == 1;
		if (explicit_index || descending_index)
		{
			isqlGlob.printf(" USING %sINDEX", descending_index ? "DESCENDING " : "");
			if (isqlGlob.db_SQL_dialect > SQL_DIALECT_V6_TRANSITION)
			{
				ISQL_copy_SQL_id(/*IDX.RDB$INDEX_NAME*/
						 isc_350.isc_352, SQL_identifier, DBL_QUOTE);
				isqlGlob.printf(" %s", SQL_identifier);
			}
			else
				isqlGlob.printf(" %s", /*IDX.RDB$INDEX_NAME*/
						       isc_350.isc_352);
		}

	/*END_FOR*/
	   }
	   };
	/*ON_ERROR*/
	if (isc_status [1])
	   {
		ISQL_errmsg(gds_status);
		return false;
	/*END_ERROR;*/
	   }
	}

	return true;
}


static void get_procedure_args(const char* proc_name)
{
   struct isc_292_struct {
          short isc_293;	/* isc_utility */
          short isc_294;	/* RDB$FIELD_SCALE */
          short isc_295;	/* RDB$FIELD_SUB_TYPE */
          short isc_296;	/* gds__null_flag */
          short isc_297;	/* RDB$FIELD_PRECISION */
   } isc_292;
   struct isc_290_struct {
          char  isc_291 [32];	/* RDB$FIELD_NAME */
   } isc_290;
   struct isc_303_struct {
          char  isc_304 [32];	/* RDB$FIELD_NAME */
          char  isc_305 [32];	/* RDB$RELATION_NAME */
          short isc_306;	/* isc_utility */
          short isc_307;	/* gds__null_flag */
          short isc_308;	/* gds__null_flag */
   } isc_303;
   struct isc_300_struct {
          char  isc_301 [32];	/* RDB$PARAMETER_NAME */
          char  isc_302 [32];	/* RDB$PROCEDURE_NAME */
   } isc_300;
   struct isc_314_struct {
          ISC_QUAD isc_315;	/* RDB$DEFAULT_SOURCE */
          short isc_316;	/* isc_utility */
          short isc_317;	/* gds__null_flag */
          short isc_318;	/* RDB$PARAMETER_MECHANISM */
          short isc_319;	/* gds__null_flag */
          short isc_320;	/* RDB$NULL_FLAG */
          short isc_321;	/* gds__null_flag */
          short isc_322;	/* gds__null_flag */
          short isc_323;	/* RDB$COLLATION_ID */
   } isc_314;
   struct isc_311_struct {
          char  isc_312 [32];	/* RDB$PARAMETER_NAME */
          char  isc_313 [32];	/* RDB$PROCEDURE_NAME */
   } isc_311;
   struct isc_329_struct {
          ISC_QUAD isc_330;	/* RDB$DEFAULT_SOURCE */
          char  isc_331 [32];	/* RDB$FIELD_NAME */
          char  isc_332 [32];	/* RDB$PARAMETER_NAME */
          char  isc_333 [32];	/* RDB$PROCEDURE_NAME */
          short isc_334;	/* isc_utility */
          short isc_335;	/* gds__null_flag */
          short isc_336;	/* gds__null_flag */
          short isc_337;	/* gds__null_flag */
          short isc_338;	/* RDB$COLLATION_ID */
          short isc_339;	/* RDB$FIELD_LENGTH */
          short isc_340;	/* gds__null_flag */
          short isc_341;	/* RDB$CHARACTER_LENGTH */
          short isc_342;	/* RDB$FIELD_SCALE */
          short isc_343;	/* RDB$CHARACTER_SET_ID */
          short isc_344;	/* RDB$FIELD_TYPE */
          short isc_345;	/* RDB$SYSTEM_FLAG */
   } isc_329;
   struct isc_326_struct {
          char  isc_327 [32];	/* RDB$PROCEDURE_NAME */
          short isc_328;	/* RDB$PARAMETER_TYPE */
   } isc_326;
/**************************************
 *
 *	g e t _ p r o c e d u r e _ a r g s
 *
 **************************************
 *
 * Functional description
 *	This function extracts the procedure parameters and adds it to the
 *	extract file
 *
 **************************************/
	SCHAR char_sets[95];

// query to retrieve the parameters.


/* placed the two identical code blocks into one
   for loop as suggested by Ann H. and Claudio V.
   FSG 18.Nov.2000
*/

	//  Parameter types 0 = input
	//  Parameter types 1 = return

	for (SSHORT ptype = 0; ptype < 2; ptype++)
	{
		bool first_time = true;

		/*FOR PRM IN RDB$PROCEDURE_PARAMETERS CROSS
			FLD IN RDB$FIELDS WITH
			PRM.RDB$PROCEDURE_NAME = proc_name AND
			PRM.RDB$FIELD_SOURCE EQ FLD.RDB$FIELD_NAME AND
			PRM.RDB$PARAMETER_TYPE = ptype
			SORTED BY PRM.RDB$PARAMETER_NUMBER*/
		{
                if (!isc_324)
                   isc_compile_request2 (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &isc_324, (short) sizeof(isc_325), (char*) isc_325);
		isc_vtov ((const char*) proc_name, (char*) isc_326.isc_327, 32);
		isc_326.isc_328 = ptype;
		if (isc_324)
		   {
                   isc_start_and_send (isc_status, (FB_API_HANDLE*) &isc_324, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 34, &isc_326, (short) 0);
		   }
		if (!isc_status [1]) {
		while (1)
		   {
                   isc_receive (isc_status, (FB_API_HANDLE*) &isc_324, (short) 1, (short) 128, &isc_329, (short) 0);
		   if (!isc_329.isc_334 || isc_status [1]) break;

			bool prm_collation_id_null = true;
			SSHORT prm_collation_id = 0;

			bool prm_default_source_null = true;
			ISC_QUAD prm_default_source;

			bool prm_null_flag_null = true;
			bool prm_null_flag;

			prm_mech_t prm_mech = prm_mech_normal;

			if (ENCODE_ODS(isqlGlob.major_ods, isqlGlob.minor_ods) >= ODS_11_1)
			{
				/*FOR PRM2 IN RDB$PROCEDURE_PARAMETERS
					WITH PRM2.RDB$PROCEDURE_NAME EQ PRM.RDB$PROCEDURE_NAME AND
						 PRM2.RDB$PARAMETER_NAME EQ PRM.RDB$PARAMETER_NAME*/
				{
                                if (!isc_309)
                                   isc_compile_request2 (NULL, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &isc_309, (short) sizeof(isc_310), (char*) isc_310);
				isc_vtov ((const char*) isc_329.isc_332, (char*) isc_311.isc_312, 32);
				isc_vtov ((const char*) isc_329.isc_333, (char*) isc_311.isc_313, 32);
                                isc_start_and_send (NULL, (FB_API_HANDLE*) &isc_309, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 64, &isc_311, (short) 0);
				while (1)
				   {
                                   isc_receive (NULL, (FB_API_HANDLE*) &isc_309, (short) 1, (short) 24, &isc_314, (short) 0);
				   if (!isc_314.isc_316) break;

					prm_collation_id_null = /*PRM2.RDB$COLLATION_ID.NULL*/
								isc_314.isc_322;
					prm_collation_id = /*PRM2.RDB$COLLATION_ID*/
							   isc_314.isc_323;

					prm_default_source_null = /*PRM2.RDB$DEFAULT_SOURCE.NULL*/
								  isc_314.isc_321;
					prm_default_source = /*PRM2.RDB$DEFAULT_SOURCE*/
							     isc_314.isc_315;

					prm_null_flag_null = /*PRM2.RDB$NULL_FLAG.NULL*/
							     isc_314.isc_319;
					prm_null_flag = /*PRM2.RDB$NULL_FLAG*/
							isc_314.isc_320;

					if (!/*PRM2.RDB$PARAMETER_MECHANISM.NULL*/
					     isc_314.isc_317)
						prm_mech = (prm_mech_t) /*PRM2.RDB$PARAMETER_MECHANISM*/
									isc_314.isc_318;
				/*END_FOR*/
				   }
				}
			}

			char relationName[BUFFER_LENGTH128] = "";
			char relationField[BUFFER_LENGTH128] = "";

			if (ENCODE_ODS(isqlGlob.major_ods, isqlGlob.minor_ods) >= ODS_11_2)
			{
				/*FOR PRM2 IN RDB$PROCEDURE_PARAMETERS
					WITH PRM2.RDB$PROCEDURE_NAME EQ PRM.RDB$PROCEDURE_NAME AND
						 PRM2.RDB$PARAMETER_NAME EQ PRM.RDB$PARAMETER_NAME*/
				{
                                if (!isc_298)
                                   isc_compile_request2 (NULL, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &isc_298, (short) sizeof(isc_299), (char*) isc_299);
				isc_vtov ((const char*) isc_329.isc_332, (char*) isc_300.isc_301, 32);
				isc_vtov ((const char*) isc_329.isc_333, (char*) isc_300.isc_302, 32);
                                isc_start_and_send (NULL, (FB_API_HANDLE*) &isc_298, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 64, &isc_300, (short) 0);
				while (1)
				   {
                                   isc_receive (NULL, (FB_API_HANDLE*) &isc_298, (short) 1, (short) 70, &isc_303, (short) 0);
				   if (!isc_303.isc_306) break;

					if (!/*PRM2.RDB$RELATION_NAME.NULL*/
					     isc_303.isc_308)
					{
						fb_utils::exact_name(/*PRM2.RDB$RELATION_NAME*/
								     isc_303.isc_305);
						if (isqlGlob.db_SQL_dialect > SQL_DIALECT_V6_TRANSITION)
							ISQL_copy_SQL_id(/*PRM2.RDB$RELATION_NAME*/
									 isc_303.isc_305, relationName, DBL_QUOTE);
						else
							strcpy(relationName, /*PRM2.RDB$RELATION_NAME*/
									     isc_303.isc_305);
					}

					if (!/*PRM2.RDB$FIELD_NAME.NULL*/
					     isc_303.isc_307)
					{
						fb_utils::exact_name(/*PRM2.RDB$FIELD_NAME*/
								     isc_303.isc_304);
						if (isqlGlob.db_SQL_dialect > SQL_DIALECT_V6_TRANSITION)
							ISQL_copy_SQL_id(/*PRM2.RDB$FIELD_NAME*/
									 isc_303.isc_304, relationField, DBL_QUOTE);
						else
							strcpy(relationField, /*PRM2.RDB$FIELD_NAME*/
									      isc_303.isc_304);
					}

				/*END_FOR*/
				   }
				}
			}

			if (first_time)
			{
				first_time = false;
				if (ptype == 0)
				{ // this is the input part
					isqlGlob.printf("(");
				}
				else
				{ // we are in the output part
					isqlGlob.printf("RETURNS (");
				}
			}
			else
			{
				isqlGlob.printf(",%s", NEWLINE);
			}

			fb_utils::exact_name(/*PRM.RDB$PARAMETER_NAME*/
					     isc_329.isc_332);

			// CVC: Parameter names need check for dialect 3, too.

			if (isqlGlob.db_SQL_dialect > SQL_DIALECT_V6_TRANSITION)
				ISQL_copy_SQL_id (/*PRM.RDB$PARAMETER_NAME*/
						  isc_329.isc_332, SQL_identifier, DBL_QUOTE);
			else
				strcpy (SQL_identifier, /*PRM.RDB$PARAMETER_NAME*/
							isc_329.isc_332);

			isqlGlob.printf("%s ", SQL_identifier);

			const bool basedOnColumn = relationName[0] && relationField[0];
			if (!fb_utils::implicit_domain(/*FLD.RDB$FIELD_NAME*/
						       isc_329.isc_331) || /*FLD.RDB$SYSTEM_FLAG*/
     isc_329.isc_345 == 1 ||
				basedOnColumn)
			{
				if (prm_mech == prm_mech_type_of)
					isqlGlob.printf("TYPE OF ");

				if (basedOnColumn)
					isqlGlob.printf("COLUMN %s.%s", relationName, relationField);
				else
				{
					fb_utils::exact_name(/*FLD.RDB$FIELD_NAME*/
							     isc_329.isc_331);
					if (isqlGlob.db_SQL_dialect > SQL_DIALECT_V6_TRANSITION)
					{
						ISQL_copy_SQL_id (/*FLD.RDB$FIELD_NAME*/
								  isc_329.isc_331, SQL_identifier, DBL_QUOTE);
						isqlGlob.prints(SQL_identifier);
					}
					else
						isqlGlob.prints(/*FLD.RDB$FIELD_NAME*/
								isc_329.isc_331);
				}

				// International character sets
				// Print only the collation
				if ((/*FLD.RDB$FIELD_TYPE*/
				     isc_329.isc_344 == T_CHAR || /*FLD.RDB$FIELD_TYPE*/
	      isc_329.isc_344 == VARCHAR) &&
					!prm_collation_id_null && prm_collation_id)
				{
					char_sets[0] = '\0';
					ISQL_get_character_sets(/*FLD.RDB$CHARACTER_SET_ID*/
								isc_329.isc_343, prm_collation_id, true,
						!prm_null_flag_null && prm_null_flag, char_sets);
					if (char_sets[0])
						isqlGlob.prints(char_sets);
				}
				else if (!prm_null_flag_null && prm_null_flag)
					isqlGlob.printf(" NOT NULL");

				if (ptype == 0) // input, try to extract default and make Vlad happy.
				{
					if (!prm_default_source_null)
					{
						isqlGlob.printf(" ");
						SHOW_print_metadata_text_blob(isqlGlob.Out, &prm_default_source);
					}
				}
			}
			else
			{
				// Get column type name to print
				for (int i = 0; Column_types[i].type; i++)
				{
					if (/*FLD.RDB$FIELD_TYPE*/
					    isc_329.isc_344 == Column_types[i].type)
					{
						bool precision_known = false;

						if (isqlGlob.major_ods >= ODS_VERSION10)
						{
							// Handle Integral subtypes NUMERIC and DECIMAL
							if ((/*FLD.RDB$FIELD_TYPE*/
							     isc_329.isc_344 == SMALLINT) ||
								(/*FLD.RDB$FIELD_TYPE*/
								 isc_329.isc_344 == INTEGER) ||
								(/*FLD.RDB$FIELD_TYPE*/
								 isc_329.isc_344 == BIGINT))
							{
								/* We are ODS >= 10 and could be any Dialect */

								/*FOR FLD1 IN RDB$FIELDS WITH
									FLD1.RDB$FIELD_NAME EQ FLD.RDB$FIELD_NAME*/
								{
                                                                if (!isc_288)
                                                                   isc_compile_request2 (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &isc_288, (short) sizeof(isc_289), (char*) isc_289);
								isc_vtov ((const char*) isc_329.isc_331, (char*) isc_290.isc_291, 32);
								if (isc_288)
								   {
                                                                   isc_start_and_send (isc_status, (FB_API_HANDLE*) &isc_288, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 32, &isc_290, (short) 0);
								   }
								if (!isc_status [1]) {
								while (1)
								   {
                                                                   isc_receive (isc_status, (FB_API_HANDLE*) &isc_288, (short) 1, (short) 10, &isc_292, (short) 0);
								   if (!isc_292.isc_293 || isc_status [1]) break;

									if (!/*FLD1.RDB$FIELD_PRECISION.NULL*/
									     isc_292.isc_296)
									{
										/* We are Dialect >=3 since FIELD_PRECISION is non-NULL */
										if (/*FLD1.RDB$FIELD_SUB_TYPE*/
										    isc_292.isc_295 > 0 &&
											/*FLD1.RDB$FIELD_SUB_TYPE*/
											isc_292.isc_295 <= MAX_INTSUBTYPES)
										{
											sprintf (Print_buffer, "%s(%d, %d)",
													Integral_subtypes[/*FLD1.RDB$FIELD_SUB_TYPE*/
															  isc_292.isc_295],
													/*FLD1.RDB$FIELD_PRECISION*/
													isc_292.isc_297,
													-/*FLD1.RDB$FIELD_SCALE*/
													 isc_292.isc_294);
											precision_known = true;
										}
									}
								/*END_FOR*/
								   }
								   };
								/*ON_ERROR*/
								if (isc_status [1])
								   {
									ISQL_errmsg (isc_status);
									return;
								/*END_ERROR;*/
								   }
								}
							}
						}
						if (!precision_known)
						{
							// Take a stab at numerics and decimals
							if ((/*FLD.RDB$FIELD_TYPE*/
							     isc_329.isc_344 == SMALLINT) && (/*FLD.RDB$FIELD_SCALE*/
		  isc_329.isc_342 < 0))
							{
								sprintf (Print_buffer, "NUMERIC(4, %d)", -/*FLD.RDB$FIELD_SCALE*/
													  isc_329.isc_342);
							}
							else if ((/*FLD.RDB$FIELD_TYPE*/
								  isc_329.isc_344 == INTEGER) && (/*FLD.RDB$FIELD_SCALE*/
		 isc_329.isc_342 < 0))
							{
								sprintf (Print_buffer, "NUMERIC(9, %d)", -/*FLD.RDB$FIELD_SCALE*/
													  isc_329.isc_342);
							}
							else if ((/*FLD.RDB$FIELD_TYPE*/
								  isc_329.isc_344 == DOUBLE_PRECISION) && (/*FLD.RDB$FIELD_SCALE*/
			  isc_329.isc_342 < 0))
							{
								sprintf (Print_buffer, "NUMERIC(15, %d)", -/*FLD.RDB$FIELD_SCALE*/
													   isc_329.isc_342);
							}
							else
							{
								sprintf (Print_buffer, "%s", Column_types[i].type_name);
							}
						}
						isqlGlob.prints(Print_buffer);
						break;
					}
				}

				/* Changed this to return RDB$CHARACTER_LENGTH if available
				   Fix for Bug #122563
				   FSG 18.Nov.2000
				*/
				if ((/*FLD.RDB$FIELD_TYPE*/
				     isc_329.isc_344 == T_CHAR) || (/*FLD.RDB$FIELD_TYPE*/
		isc_329.isc_344 == VARCHAR))
				{
					if (/*FLD.RDB$CHARACTER_LENGTH.NULL*/
					    isc_329.isc_340)
					{
						isqlGlob.printf("(%d)", /*FLD.RDB$FIELD_LENGTH*/
									isc_329.isc_339);
					}
					else
					{
						isqlGlob.printf("(%d)", /*FLD.RDB$CHARACTER_LENGTH*/
									isc_329.isc_341);
					}
				}

				// Show international character sets and collations
				if (!/*FLD.RDB$COLLATION_ID.NULL*/
				     isc_329.isc_337 || !/*FLD.RDB$CHARACTER_SET_ID.NULL*/
     isc_329.isc_336)
				{
					char_sets[0] = 0;

					SSHORT collation = 0;

					if (!prm_collation_id_null)
						collation = prm_collation_id;
					else if (!/*FLD.RDB$COLLATION_ID.NULL*/
						  isc_329.isc_337)
						collation = /*FLD.RDB$COLLATION_ID*/
							    isc_329.isc_338;

					if (/*FLD.RDB$CHARACTER_SET_ID.NULL*/
					    isc_329.isc_336)
						/*FLD.RDB$CHARACTER_SET_ID*/
						isc_329.isc_343 = 0;

					ISQL_get_character_sets (/*FLD.RDB$CHARACTER_SET_ID*/
								 isc_329.isc_343, collation, false,
						!prm_null_flag_null && prm_null_flag, char_sets);
					if (char_sets[0])
						isqlGlob.prints(char_sets);
				}
				else if (!prm_null_flag_null && prm_null_flag)
					isqlGlob.printf(" NOT NULL");

				if (ptype == 0) // input, try to extract default and make Vlad happy.
				{
					if (!prm_default_source_null)
					{
						isqlGlob.printf(" ");
						SHOW_print_metadata_text_blob(isqlGlob.Out, &prm_default_source);
					}
					else if (!/*FLD.RDB$DEFAULT_SOURCE.NULL*/
						  isc_329.isc_335)
					{
						isqlGlob.printf(" ");
						SHOW_print_metadata_text_blob(isqlGlob.Out, &/*FLD.RDB$DEFAULT_SOURCE*/
											     isc_329.isc_330);
					}
				}
			}
		/*END_FOR*/
		   }
		   };
		/*ON_ERROR*/
		if (isc_status [1])
		   {
			ISQL_errmsg(gds_status);
			return;
		/*END_ERROR;*/
		   }
		}

		// If there was at least one param, close parens

		if (!first_time)
		{
			isqlGlob.printf(")%s", NEWLINE);
		}

	}						// end for ptype
	isqlGlob.printf("AS %s", NEWLINE);
}


static void list_all_grants()
{
/**************************************
 *
 *	l i s t _ a l l _ g r a n t s
 *
 **************************************
 *
 * Functional description
 *	Print the permissions on all user tables, views and procedures.
 *
 *	Wrapper around list_all_grants2().
 *
 **************************************/
	list_all_grants2(true, isqlGlob.global_Term);
}


static processing_state list_all_grants2(bool show_role_list, const SCHAR* terminator)
{
   struct isc_268_struct {
          char  isc_269 [32];	/* RDB$PROCEDURE_NAME */
          short isc_270;	/* isc_utility */
   } isc_268;
   struct isc_273_struct {
          char  isc_274 [32];	/* RDB$RELATION_NAME */
          short isc_275;	/* isc_utility */
   } isc_273;
   struct isc_280_struct {
          short isc_281;	/* isc_utility */
   } isc_280;
   struct isc_278_struct {
          char  isc_279 [32];	/* RDB$ROLE_NAME */
   } isc_278;
   struct isc_284_struct {
          char  isc_285 [32];	/* RDB$OWNER_NAME */
          char  isc_286 [32];	/* RDB$ROLE_NAME */
          short isc_287;	/* isc_utility */
   } isc_284;
/**************************************
 *
 *	l i s t _ a l l _ g r a n t s
 *
 **************************************
 *
 * Functional description
 *	Print the permissions on all user tables.
 *
 *	Get separate permissions on table/views and then procedures.
 *
 **************************************/
	bool first_role = true;
	TEXT prev_owner[44];

	// Only extract (not show) wants the role list and with escaped quoted identifiers.
	const bool mangle = show_role_list;

	// Process GRANT roles
	if (isqlGlob.major_ods >= ODS_VERSION9 && show_role_list)
	{
		prev_owner[0] = '\0';

		/*FOR XX IN RDB$ROLES
			SORTED BY XX.RDB$ROLE_NAME*/
		{
                if (!isc_282)
                   isc_compile_request2 (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &isc_282, (short) sizeof(isc_283), (char*) isc_283);
		if (isc_282)
		   {
                   isc_start_request (isc_status, (FB_API_HANDLE*) &isc_282, (FB_API_HANDLE*) &gds_trans, (short) 0);
		   }
		if (!isc_status [1]) {
		while (1)
		   {
                   isc_receive (isc_status, (FB_API_HANDLE*) &isc_282, (short) 0, (short) 66, &isc_284, (short) 0);
		   if (!isc_284.isc_287 || isc_status [1]) break;

			bool system_flag = false;
			if (isqlGlob.major_ods >= ODS_VERSION11)
			{
				/*FOR SF IN RDB$ROLES
					WITH SF.RDB$ROLE_NAME = XX.RDB$ROLE_NAME
					 AND SF.RDB$SYSTEM_FLAG > 0*/
				{
                                if (!isc_276)
                                   isc_compile_request2 (NULL, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &isc_276, (short) sizeof(isc_277), (char*) isc_277);
				isc_vtov ((const char*) isc_284.isc_286, (char*) isc_278.isc_279, 32);
                                isc_start_and_send (NULL, (FB_API_HANDLE*) &isc_276, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 32, &isc_278, (short) 0);
				while (1)
				   {
                                   isc_receive (NULL, (FB_API_HANDLE*) &isc_276, (short) 1, (short) 2, &isc_280, (short) 0);
				   if (!isc_280.isc_281) break;

					system_flag = true;

				/*END_FOR*/
				   }
				}
			}

			if (! system_flag)
			{
				if (first_role)
				{
					isqlGlob.printf("%s/* Grant roles for this database */%s", NEWLINE, NEWLINE);
					first_role = false;
				}

				// Null terminate name string
				fb_utils::exact_name(/*XX.RDB$ROLE_NAME*/
						     isc_284.isc_286);
				fb_utils::exact_name(/*XX.RDB$OWNER_NAME*/
						     isc_284.isc_285);

				if (strcmp (prev_owner, /*XX.RDB$OWNER_NAME*/
							isc_284.isc_285) != 0)
				{
					isqlGlob.printf("%s/* Role: %s, Owner: %s */%s",
							 NEWLINE,
							 /*XX.RDB$ROLE_NAME*/
							 isc_284.isc_286,
							 /*XX.RDB$OWNER_NAME*/
							 isc_284.isc_285,
							 NEWLINE);
					strcpy (prev_owner, /*XX.RDB$OWNER_NAME*/
							    isc_284.isc_285);
				}

				if (isqlGlob.db_SQL_dialect > SQL_DIALECT_V6_TRANSITION)
				{
					ISQL_copy_SQL_id (/*XX.RDB$ROLE_NAME*/
							  isc_284.isc_286, SQL_identifier, DBL_QUOTE);
					isqlGlob.printf("CREATE ROLE %s;%s", SQL_identifier, NEWLINE);
				}
				else
					isqlGlob.printf("CREATE ROLE %s;%s", /*XX.RDB$ROLE_NAME*/
									     isc_284.isc_286, NEWLINE);
			}

		/*END_FOR*/
		   }
		   };
		/*ON_ERROR*/
		if (isc_status [1])
		   {
			ISQL_errmsg(gds_status);
		    return OBJECT_NOT_FOUND;
		/*END_ERROR;*/
		   }
		}
	}

	// This version of cursor gets only sql tables identified by security class
	// and misses views, getting only null view_source

	char banner[100];
	sprintf(banner, "%s/* Grant permissions for this database */%s", NEWLINE, NEWLINE);

	bool first = true;

	/*FOR REL IN RDB$RELATIONS WITH
		(REL.RDB$SYSTEM_FLAG NE 1 OR REL.RDB$SYSTEM_FLAG MISSING) AND
		REL.RDB$SECURITY_CLASS STARTING "SQL$"
		SORTED BY REL.RDB$RELATION_NAME*/
	{
        if (!isc_271)
           isc_compile_request2 (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &isc_271, (short) sizeof(isc_272), (char*) isc_272);
	if (isc_271)
	   {
           isc_start_request (isc_status, (FB_API_HANDLE*) &isc_271, (FB_API_HANDLE*) &gds_trans, (short) 0);
	   }
	if (!isc_status [1]) {
	while (1)
	   {
           isc_receive (isc_status, (FB_API_HANDLE*) &isc_271, (short) 0, (short) 34, &isc_273, (short) 0);
	   if (!isc_273.isc_275 || isc_status [1]) break;

		// Null terminate name string

		fb_utils::exact_name(/*REL.RDB$RELATION_NAME*/
				     isc_273.isc_274);

		const processing_state rc =
			SHOW_grants2(/*REL.RDB$RELATION_NAME*/
				     isc_273.isc_274, terminator, obj_relation,
						   first ? banner : 0, mangle);
		if (rc == SKIP) {
			first = false;
		}

	/*END_FOR*/
	   }
	   };
	/*ON_ERROR*/
	if (isc_status [1])
	   {
		ISQL_errmsg(gds_status);
		return OBJECT_NOT_FOUND;
	/*END_ERROR;*/
	   }
	}

	if (first)
		SHOW_grant_roles2(terminator, &first, banner, mangle);
	else
		SHOW_grant_roles2(terminator, 0, 0, mangle);


	// Again for stored procedures
	/*FOR PRC IN RDB$PROCEDURES
		SORTED BY PRC.RDB$PROCEDURE_NAME*/
	{
        if (!isc_266)
           isc_compile_request2 (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &isc_266, (short) sizeof(isc_267), (char*) isc_267);
	if (isc_266)
	   {
           isc_start_request (isc_status, (FB_API_HANDLE*) &isc_266, (FB_API_HANDLE*) &gds_trans, (short) 0);
	   }
	if (!isc_status [1]) {
	while (1)
	   {
           isc_receive (isc_status, (FB_API_HANDLE*) &isc_266, (short) 0, (short) 34, &isc_268, (short) 0);
	   if (!isc_268.isc_270 || isc_status [1]) break;

		// Null terminate name string

		fb_utils::exact_name(/*PRC.RDB$PROCEDURE_NAME*/
				     isc_268.isc_269);

		const processing_state rc =
			SHOW_grants2(/*PRC.RDB$PROCEDURE_NAME*/
				     isc_268.isc_269, terminator, obj_procedure,
						   first ? banner: 0, mangle);
		if (rc == SKIP)
			first = false;

	/*END_FOR*/
	   }
	   };
	/*ON_ERROR*/
	if (isc_status [1])
	   {
		ISQL_errmsg(gds_status);
		return OBJECT_NOT_FOUND;
	/*END_ERROR;*/
	   }
	}

	return first_role && first ? OBJECT_NOT_FOUND : SKIP;
}


static void list_all_procs()
{
   struct isc_249_struct {
          ISC_QUAD isc_250;	/* RDB$PROCEDURE_SOURCE */
          char  isc_251 [32];	/* RDB$PROCEDURE_NAME */
          short isc_252;	/* isc_utility */
          short isc_253;	/* gds__null_flag */
   } isc_249;
   struct isc_258_struct {
          short isc_259;	/* isc_utility */
          short isc_260;	/* RDB$PROCEDURE_TYPE */
   } isc_258;
   struct isc_256_struct {
          char  isc_257 [32];	/* RDB$PROCEDURE_NAME */
   } isc_256;
   struct isc_263_struct {
          char  isc_264 [32];	/* RDB$PROCEDURE_NAME */
          short isc_265;	/* isc_utility */
   } isc_263;
/**************************************
 *
 *	l i s t _ a l l _ p r o c s
 *
 **************************************
 *
 * Functional description
 *	Shows text of a stored procedure given a name.
 *	or lists procedures if no argument.
 *	Since procedures may reference each other, we will create all
 *	dummy procedures of the correct name, then alter these to their
 *	correct form.
 *      Add the parameter names when these procedures are created.
 *
 *	procname -- Name of procedure to investigate
 *
 **************************************/
	bool header = true;
	static const char* create_procedure_str1 = "CREATE PROCEDURE %s ";
	static const char* create_procedure_str2 = "BEGIN EXIT; END %s%s";
	static const char* create_procedure_str3 = "BEGIN SUSPEND; END %s%s";


	//  First the dummy procedures
	// create the procedures with their parameters

	/*FOR PRC IN RDB$PROCEDURES
		SORTED BY PRC.RDB$PROCEDURE_NAME*/
	{
        if (!isc_261)
           isc_compile_request2 (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &isc_261, (short) sizeof(isc_262), (char*) isc_262);
	if (isc_261)
	   {
           isc_start_request (isc_status, (FB_API_HANDLE*) &isc_261, (FB_API_HANDLE*) &gds_trans, (short) 0);
	   }
	if (!isc_status [1]) {
	while (1)
	   {
           isc_receive (isc_status, (FB_API_HANDLE*) &isc_261, (short) 0, (short) 34, &isc_263, (short) 0);
	   if (!isc_263.isc_265 || isc_status [1]) break;
		if (header)
		{
			isqlGlob.printf("COMMIT WORK;%s", NEWLINE);
			isqlGlob.printf("SET AUTODDL OFF;%s", NEWLINE);
			isqlGlob.printf("SET TERM %s %s%s", Procterm, isqlGlob.global_Term, NEWLINE);
			isqlGlob.printf("%s/* Stored procedures */%s", NEWLINE, NEWLINE);
			header = false;
		}
		fb_utils::exact_name(/*PRC.RDB$PROCEDURE_NAME*/
				     isc_263.isc_264);
		if (isqlGlob.db_SQL_dialect > SQL_DIALECT_V6_TRANSITION)
		{
			ISQL_copy_SQL_id (/*PRC.RDB$PROCEDURE_NAME*/
					  isc_263.isc_264, SQL_identifier, DBL_QUOTE);
			isqlGlob.printf(create_procedure_str1, SQL_identifier);
		}
		else
		{
			isqlGlob.printf(create_procedure_str1, /*PRC.RDB$PROCEDURE_NAME*/
							       isc_263.isc_264);
		}

		get_procedure_args (/*PRC.RDB$PROCEDURE_NAME*/
				    isc_263.isc_264);

		prc_t proc_type = prc_legacy;

		if (ENCODE_ODS(isqlGlob.major_ods, isqlGlob.minor_ods) >= ODS_11_1)
		{
			/*FOR PRC2 IN RDB$PROCEDURES
				WITH PRC2.RDB$PROCEDURE_NAME EQ PRC.RDB$PROCEDURE_NAME AND
				PRC2.RDB$PROCEDURE_TYPE NOT MISSING*/
			{
                        if (!isc_254)
                           isc_compile_request2 (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &isc_254, (short) sizeof(isc_255), (char*) isc_255);
			isc_vtov ((const char*) isc_263.isc_264, (char*) isc_256.isc_257, 32);
			if (isc_254)
			   {
                           isc_start_and_send (isc_status, (FB_API_HANDLE*) &isc_254, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 32, &isc_256, (short) 0);
			   }
			if (!isc_status [1]) {
			while (1)
			   {
                           isc_receive (isc_status, (FB_API_HANDLE*) &isc_254, (short) 1, (short) 4, &isc_258, (short) 0);
			   if (!isc_258.isc_259 || isc_status [1]) break;

				proc_type = (prc_t) /*PRC2.RDB$PROCEDURE_TYPE*/
						    isc_258.isc_260;

			/*END_FOR*/
			   }
			   };
			/*ON_ERROR*/
			if (isc_status [1])
			   {
				ISQL_errmsg(gds_status);
				return;
			/*END_ERROR;*/
			   }
			}
		}

		// We'll assume for safety that prc_legacy can be mapped to prc_selectable.
		if (proc_type == prc_executable)
			isqlGlob.printf(create_procedure_str2, Procterm, NEWLINE);
		else
			isqlGlob.printf(create_procedure_str3, Procterm, NEWLINE);

	/*END_FOR*/
	   }
	   };
	/*ON_ERROR*/
	if (isc_status [1])
	   {
		ISQL_errmsg(gds_status);
		return;
	/*END_ERROR;*/
	   }
	}

	// This query gets the procedure name and the source.  We then nest a query
	// to retrieve the parameters. Alter is used, because the procedures are already there
	TEXT msg[MSG_LENGTH];

	/*FOR PRC IN RDB$PROCEDURES
		SORTED BY PRC.RDB$PROCEDURE_NAME*/
	{
        if (!isc_247)
           isc_compile_request2 (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &isc_247, (short) sizeof(isc_248), (char*) isc_248);
	if (isc_247)
	   {
           isc_start_request (isc_status, (FB_API_HANDLE*) &isc_247, (FB_API_HANDLE*) &gds_trans, (short) 0);
	   }
	if (!isc_status [1]) {
	while (1)
	   {
           isc_receive (isc_status, (FB_API_HANDLE*) &isc_247, (short) 0, (short) 44, &isc_249, (short) 0);
	   if (!isc_249.isc_252 || isc_status [1]) break;

		fb_utils::exact_name(/*PRC.RDB$PROCEDURE_NAME*/
				     isc_249.isc_251);

		if (isqlGlob.db_SQL_dialect > SQL_DIALECT_V6_TRANSITION)
		{
			ISQL_copy_SQL_id (/*PRC.RDB$PROCEDURE_NAME*/
					  isc_249.isc_251, SQL_identifier, DBL_QUOTE);
			isqlGlob.printf("%sALTER PROCEDURE %s ", NEWLINE, SQL_identifier);
		}
		else
			isqlGlob.printf("%sALTER PROCEDURE %s ", NEWLINE, /*PRC.RDB$PROCEDURE_NAME*/
									  isc_249.isc_251);
		get_procedure_args (/*PRC.RDB$PROCEDURE_NAME*/
				    isc_249.isc_251);

		// Print the procedure body

		if (!/*PRC.RDB$PROCEDURE_SOURCE.NULL*/
		     isc_249.isc_253)
			SHOW_print_metadata_text_blob (isqlGlob.Out, &/*PRC.RDB$PROCEDURE_SOURCE*/
								      isc_249.isc_250);

		isqlGlob.printf(" %s%s", Procterm, NEWLINE);

	/*END_FOR*/
	   }
	   };
	/*ON_ERROR*/
	if (isc_status [1])
	   {
		ISQL_msg_get(GEN_ERR, msg, SafeArg() << isc_sqlcode(gds_status));
		STDERROUT(msg);			// Statement failed, SQLCODE = %d\n\n
		ISQL_errmsg(gds_status);
		return;
	/*END_ERROR;*/
	   }
	}

	// Only reset the terminators is there were procs to print
	if (!header)
	{
		isqlGlob.printf("SET TERM %s %s%s", isqlGlob.global_Term, Procterm, NEWLINE);
		isqlGlob.printf("COMMIT WORK %s%s", isqlGlob.global_Term, NEWLINE);
		isqlGlob.printf("SET AUTODDL ON;%s", NEWLINE);
	}
}


static void list_all_tables(LegacyTables flag, SSHORT default_char_set_id)
{
   struct isc_241_struct {
          char  isc_242 [32];	/* RDB$SECURITY_CLASS */
          char  isc_243 [32];	/* RDB$RELATION_NAME */
          short isc_244;	/* isc_utility */
          short isc_245;	/* gds__null_flag */
          short isc_246;	/* RDB$FLAGS */
   } isc_241;
/**************************************
 *
 *	l i s t _ a l l _ t a b l e s
 *
 **************************************
 *
 * Functional description
 *	Extract the names of all user tables from
 *	rdb$relations.  Filter SQL tables by
 *	security class after we fetch them
 *	Parameters:  flag -- 0, get all tables
 *
 **************************************/

/* This version of cursor gets only sql tables identified by security class
   and misses views, getting only null view_source */

	/*FOR REL IN RDB$RELATIONS WITH
		(REL.RDB$SYSTEM_FLAG NE 1 OR REL.RDB$SYSTEM_FLAG MISSING) AND
		REL.RDB$VIEW_BLR MISSING
		SORTED BY REL.RDB$RELATION_NAME*/
	{
        if (!isc_239)
           isc_compile_request2 (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &isc_239, (short) sizeof(isc_240), (char*) isc_240);
	if (isc_239)
	   {
           isc_start_request (isc_status, (FB_API_HANDLE*) &isc_239, (FB_API_HANDLE*) &gds_trans, (short) 0);
	   }
	if (!isc_status [1]) {
	while (1)
	   {
           isc_receive (isc_status, (FB_API_HANDLE*) &isc_239, (short) 0, (short) 70, &isc_241, (short) 0);
	   if (!isc_241.isc_244 || isc_status [1]) break;

		// If this is not an SQL table and we aren't doing ALL objects
		if ((/*REL.RDB$FLAGS.NULL*/
		     isc_241.isc_245 || !(/*REL.RDB$FLAGS*/
      isc_241.isc_246 & REL_sql)) && (flag != ALL_objects) )
			continue;
		// Null terminate name string

		fb_utils::exact_name(/*REL.RDB$RELATION_NAME*/
				     isc_241.isc_243);

		if (flag || !strncmp (/*REL.RDB$SECURITY_CLASS*/
				      isc_241.isc_242, "SQL$", 4))
			EXTRACT_list_table (/*REL.RDB$RELATION_NAME*/
					    isc_241.isc_243, NULL,  false, default_char_set_id);
	/*END_FOR*/
	   }
	   };
	/*ON_ERROR*/
	if (isc_status [1])
	   {
		ISQL_errmsg(gds_status);
		/*ROLLBACK;*/
		{
		isc_rollback_transaction (NULL, (FB_API_HANDLE*) &gds_trans);
		}
		return;
	/*END_ERROR;*/
	   }
	}

}


static void list_all_triggers()
{
   struct isc_216_struct {
          ISC_QUAD isc_217;	/* RDB$TRIGGER_SOURCE */
          char  isc_218 [32];	/* RDB$RELATION_NAME */
          char  isc_219 [32];	/* RDB$TRIGGER_NAME */
          short isc_220;	/* isc_utility */
          short isc_221;	/* gds__null_flag */
          short isc_222;	/* RDB$TRIGGER_SEQUENCE */
          short isc_223;	/* RDB$TRIGGER_TYPE */
          short isc_224;	/* RDB$FLAGS */
          short isc_225;	/* gds__null_flag */
          short isc_226;	/* RDB$TRIGGER_INACTIVE */
   } isc_216;
   struct isc_229_struct {
          ISC_QUAD isc_230;	/* RDB$TRIGGER_SOURCE */
          char  isc_231 [32];	/* RDB$TRIGGER_NAME */
          short isc_232;	/* isc_utility */
          short isc_233;	/* gds__null_flag */
          short isc_234;	/* RDB$TRIGGER_SEQUENCE */
          short isc_235;	/* RDB$TRIGGER_TYPE */
          short isc_236;	/* RDB$FLAGS */
          short isc_237;	/* gds__null_flag */
          short isc_238;	/* RDB$TRIGGER_INACTIVE */
   } isc_229;
/**************************************
 *
 *	l i s t _ a l l _ t r i g g e r s
 *
 **************************************
 *
 * Functional description
 *	Lists triggers in general on non-system
 *	tables with sql source only.
 *
 **************************************/
	bool header = true;

	// Query gets the trigger info for non-system triggers with
	// source that are not part of an SQL constraint.

	/*FOR TRG IN RDB$TRIGGERS
		WITH (TRG.RDB$SYSTEM_FLAG EQ 0 OR TRG.RDB$SYSTEM_FLAG MISSING) AND
			 TRG.RDB$RELATION_NAME MISSING
		SORTED BY TRG.RDB$TRIGGER_TYPE, TRG.RDB$TRIGGER_SEQUENCE, TRG.RDB$TRIGGER_NAME*/
	{
        if (!isc_227)
           isc_compile_request2 (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &isc_227, (short) sizeof(isc_228), (char*) isc_228);
	if (isc_227)
	   {
           isc_start_request (isc_status, (FB_API_HANDLE*) &isc_227, (FB_API_HANDLE*) &gds_trans, (short) 0);
	   }
	if (!isc_status [1]) {
	while (1)
	   {
           isc_receive (isc_status, (FB_API_HANDLE*) &isc_227, (short) 0, (short) 54, &isc_229, (short) 0);
	   if (!isc_229.isc_232 || isc_status [1]) break;

		if (header)
		{
			isqlGlob.printf("SET TERM %s %s%s", Procterm, isqlGlob.global_Term, NEWLINE);
			isqlGlob.printf("%s/* Triggers only will work for SQL triggers */%s",
					 NEWLINE,
					 NEWLINE);
			header = false;
		}
		fb_utils::exact_name(/*TRG.RDB$TRIGGER_NAME*/
				     isc_229.isc_231);

		if (/*TRG.RDB$TRIGGER_INACTIVE.NULL*/
		    isc_229.isc_237)
			/*TRG.RDB$TRIGGER_INACTIVE*/
			isc_229.isc_238 = 0;

		//  If trigger is not SQL put it in comments
		if (!(/*TRG.RDB$FLAGS*/
		      isc_229.isc_236 & TRG_sql))
			isqlGlob.printf("/* ");

		if (isqlGlob.db_SQL_dialect > SQL_DIALECT_V6_TRANSITION)
			ISQL_copy_SQL_id (/*TRG.RDB$TRIGGER_NAME*/
					  isc_229.isc_231, SQL_identifier,  DBL_QUOTE);
		else
			strcpy (SQL_identifier,  /*TRG.RDB$TRIGGER_NAME*/
						 isc_229.isc_231);

		isqlGlob.printf("CREATE TRIGGER %s %s%s %s POSITION %d %s",
				 SQL_identifier, NEWLINE,
				 (/*TRG.RDB$TRIGGER_INACTIVE*/
				  isc_229.isc_238 ? "INACTIVE" : "ACTIVE"),
				 trigger_action (/*TRG.RDB$TRIGGER_TYPE*/
						 isc_229.isc_235), /*TRG.RDB$TRIGGER_SEQUENCE*/
   isc_229.isc_234,
				 NEWLINE);

		if (!/*TRG.RDB$TRIGGER_SOURCE.NULL*/
		     isc_229.isc_233)
			SHOW_print_metadata_text_blob (isqlGlob.Out, &/*TRG.RDB$TRIGGER_SOURCE*/
								      isc_229.isc_230);

		isqlGlob.printf(" %s%s", Procterm, NEWLINE);
		isqlGlob.printf(NEWLINE);

		if (!(/*TRG.RDB$FLAGS*/
		      isc_229.isc_236 & TRG_sql))
		{
			isqlGlob.printf("*/%s", NEWLINE);
		}

	/*END_FOR*/
	   }
	   };
	/*ON_ERROR*/
	if (isc_status [1])
	   {
		ISQL_errmsg(gds_status);
		return;
	/*END_ERROR;*/
	   }
	}

	/*FOR TRG IN RDB$TRIGGERS CROSS REL IN RDB$RELATIONS OVER RDB$RELATION_NAME
		//WITH (REL.RDB$SYSTEM_FLAG NE 1 OR REL.RDB$SYSTEM_FLAG MISSING) AND
		//NOT (ANY CHK IN RDB$CHECK_CONSTRAINTS WITH
		//TRG.RDB$TRIGGER_NAME EQ CHK.RDB$TRIGGER_NAME)
		WITH (TRG.RDB$SYSTEM_FLAG EQ 0 OR TRG.RDB$SYSTEM_FLAG MISSING)
		SORTED BY TRG.RDB$RELATION_NAME, TRG.RDB$TRIGGER_TYPE,
			TRG.RDB$TRIGGER_SEQUENCE, TRG.RDB$TRIGGER_NAME*/
	{
        if (!isc_214)
           isc_compile_request2 (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &isc_214, (short) sizeof(isc_215), (char*) isc_215);
	if (isc_214)
	   {
           isc_start_request (isc_status, (FB_API_HANDLE*) &isc_214, (FB_API_HANDLE*) &gds_trans, (short) 0);
	   }
	if (!isc_status [1]) {
	while (1)
	   {
           isc_receive (isc_status, (FB_API_HANDLE*) &isc_214, (short) 0, (short) 86, &isc_216, (short) 0);
	   if (!isc_216.isc_220 || isc_status [1]) break;

		if (header)
		{
			isqlGlob.printf("SET TERM %s %s%s", Procterm, isqlGlob.global_Term, NEWLINE);
			isqlGlob.printf("%s/* Triggers only will work for SQL triggers */%s",
					 NEWLINE,
					 NEWLINE);
			header = false;
		}
		fb_utils::exact_name(/*TRG.RDB$TRIGGER_NAME*/
				     isc_216.isc_219);
		fb_utils::exact_name(/*TRG.RDB$RELATION_NAME*/
				     isc_216.isc_218);

		if (/*TRG.RDB$TRIGGER_INACTIVE.NULL*/
		    isc_216.isc_225)
			/*TRG.RDB$TRIGGER_INACTIVE*/
			isc_216.isc_226 = 0;

		//  If trigger is not SQL put it in comments
		if (!(/*TRG.RDB$FLAGS*/
		      isc_216.isc_224 & TRG_sql))
			isqlGlob.printf("/* ");

		if (isqlGlob.db_SQL_dialect > SQL_DIALECT_V6_TRANSITION)
		{
			ISQL_copy_SQL_id (/*TRG.RDB$TRIGGER_NAME*/
					  isc_216.isc_219, SQL_identifier,  DBL_QUOTE);
			ISQL_copy_SQL_id (/*TRG.RDB$RELATION_NAME*/
					  isc_216.isc_218, SQL_identifier2, DBL_QUOTE);
		}
		else
		{
			strcpy (SQL_identifier,  /*TRG.RDB$TRIGGER_NAME*/
						 isc_216.isc_219);
			strcpy (SQL_identifier2, /*TRG.RDB$RELATION_NAME*/
						 isc_216.isc_218);
		}

		isqlGlob.printf("CREATE TRIGGER %s FOR %s %s%s %s POSITION %d %s",
				 SQL_identifier, SQL_identifier2, NEWLINE,
				 (/*TRG.RDB$TRIGGER_INACTIVE*/
				  isc_216.isc_226 ? "INACTIVE" : "ACTIVE"),
				 trigger_action (/*TRG.RDB$TRIGGER_TYPE*/
						 isc_216.isc_223), /*TRG.RDB$TRIGGER_SEQUENCE*/
   isc_216.isc_222,
				 NEWLINE);

		if (!/*TRG.RDB$TRIGGER_SOURCE.NULL*/
		     isc_216.isc_221)
			SHOW_print_metadata_text_blob (isqlGlob.Out, &/*TRG.RDB$TRIGGER_SOURCE*/
								      isc_216.isc_217);

		isqlGlob.printf(" %s%s", Procterm, NEWLINE);
		isqlGlob.printf(NEWLINE);

		if (!(/*TRG.RDB$FLAGS*/
		      isc_216.isc_224 & TRG_sql))
		{
			isqlGlob.printf("*/%s", NEWLINE);
		}

	/*END_FOR*/
	   }
	   };
	/*ON_ERROR*/
	if (isc_status [1])
	   {
		ISQL_errmsg(gds_status);
		return;
	/*END_ERROR;*/
	   }
	}

	if (!header)
	{
		isqlGlob.printf("COMMIT WORK %s%s", Procterm, NEWLINE);
		isqlGlob.printf("SET TERM %s %s%s", isqlGlob.global_Term, Procterm, NEWLINE);
	}
}


static void list_check()
{
   struct isc_208_struct {
          ISC_QUAD isc_209;	/* RDB$TRIGGER_SOURCE */
          char  isc_210 [32];	/* RDB$CONSTRAINT_NAME */
          char  isc_211 [32];	/* RDB$RELATION_NAME */
          short isc_212;	/* isc_utility */
          short isc_213;	/* gds__null_flag */
   } isc_208;
   struct isc_206_struct {
          short isc_207;	/* RDB$SYSTEM_FLAG */
   } isc_206;
/**************************************
 *
 *	l i s t _ c h e c k
 *
 **************************************
 *
 * Functional description
 *	List check constraints for all objects to allow forward references
 *
 **************************************/

	// Query gets the check clauses for triggers stored for check constraints

	/*FOR TRG IN RDB$TRIGGERS CROSS
		CHK IN RDB$CHECK_CONSTRAINTS WITH
		TRG.RDB$TRIGGER_TYPE EQ 1 AND
		TRG.RDB$SYSTEM_FLAG EQ int(fb_sysflag_check_constraint) AND
		TRG.RDB$TRIGGER_NAME EQ CHK.RDB$TRIGGER_NAME AND
		(ANY RELC IN RDB$RELATION_CONSTRAINTS WITH
		CHK.RDB$CONSTRAINT_NAME EQ RELC.RDB$CONSTRAINT_NAME
		AND RELC.RDB$CONSTRAINT_TYPE EQ "CHECK")
		REDUCED TO CHK.RDB$CONSTRAINT_NAME
		SORTED BY CHK.RDB$CONSTRAINT_NAME*/
	{
        if (!isc_204)
           isc_compile_request2 (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &isc_204, (short) sizeof(isc_205), (char*) isc_205);
	isc_206.isc_207 = int(fb_sysflag_check_constraint);
	if (isc_204)
	   {
           isc_start_and_send (isc_status, (FB_API_HANDLE*) &isc_204, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 2, &isc_206, (short) 0);
	   }
	if (!isc_status [1]) {
	while (1)
	   {
           isc_receive (isc_status, (FB_API_HANDLE*) &isc_204, (short) 1, (short) 76, &isc_208, (short) 0);
	   if (!isc_208.isc_212 || isc_status [1]) break;

		fb_utils::exact_name(/*TRG.RDB$RELATION_NAME*/
				     isc_208.isc_211);

		isqlGlob.printf(NEWLINE);

		if (isqlGlob.db_SQL_dialect > SQL_DIALECT_V6_TRANSITION)
		{
			ISQL_copy_SQL_id (/*TRG.RDB$RELATION_NAME*/
					  isc_208.isc_211, SQL_identifier, DBL_QUOTE);
			isqlGlob.printf("ALTER TABLE %s ADD %s%s", SQL_identifier, NEWLINE, TAB_AS_SPACES);
		}
		else
			isqlGlob.printf("ALTER TABLE %s ADD %s%s", /*TRG.RDB$RELATION_NAME*/
								   isc_208.isc_211, NEWLINE, TAB_AS_SPACES);

		// If the name of the constraint is not INTEG_..., print it
		if (!fb_utils::implicit_integrity(/*CHK.RDB$CONSTRAINT_NAME*/
						  isc_208.isc_210))
		{
			fb_utils::exact_name(/*CHK.RDB$CONSTRAINT_NAME*/
					     isc_208.isc_210);
			if (isqlGlob.db_SQL_dialect > SQL_DIALECT_V6_TRANSITION)
			{
				ISQL_copy_SQL_id (/*CHK.RDB$CONSTRAINT_NAME*/
						  isc_208.isc_210, SQL_identifier, DBL_QUOTE);
				isqlGlob.printf("CONSTRAINT %s ", SQL_identifier);
			}
			else
				isqlGlob.printf("CONSTRAINT %s ", /*CHK.RDB$CONSTRAINT_NAME*/
								  isc_208.isc_210);
		}

		if (!/*TRG.RDB$TRIGGER_SOURCE.NULL*/
		     isc_208.isc_213)
			SHOW_print_metadata_text_blob (isqlGlob.Out, &/*TRG.RDB$TRIGGER_SOURCE*/
								      isc_208.isc_209);

		isqlGlob.printf("%s%s", isqlGlob.global_Term, NEWLINE);

	/*END_FOR*/
	   }
	   };
	/*ON_ERROR*/
	if (isc_status [1])
	   {
		ISQL_errmsg(gds_status);
		return;
	/*END_ERROR;*/
	   }
	}
}


static void list_charsets()
{
   struct isc_200_struct {
          char  isc_201 [32];	/* RDB$DEFAULT_COLLATE_NAME */
          char  isc_202 [32];	/* RDB$CHARACTER_SET_NAME */
          short isc_203;	/* isc_utility */
   } isc_200;
/**************************************
 *
 *	l i s t _ c h a r s e t s
 *
 **************************************
 *
 * Functional description
 *	Alter character sets.
 *
 **************************************/

	bool first = true;

	/*FOR CS IN RDB$CHARACTER_SETS
		WITH NOT CS.RDB$CHARACTER_SET_NAME EQ CS.RDB$DEFAULT_COLLATE_NAME
		SORTED BY CS.RDB$CHARACTER_SET_NAME*/
	{
        if (!isc_198)
           isc_compile_request2 (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &isc_198, (short) sizeof(isc_199), (char*) isc_199);
	if (isc_198)
	   {
           isc_start_request (isc_status, (FB_API_HANDLE*) &isc_198, (FB_API_HANDLE*) &gds_trans, (short) 0);
	   }
	if (!isc_status [1]) {
	while (1)
	   {
           isc_receive (isc_status, (FB_API_HANDLE*) &isc_198, (short) 0, (short) 66, &isc_200, (short) 0);
	   if (!isc_200.isc_203 || isc_status [1]) break;

		if (first)
		{
			isqlGlob.printf("%s/*  Character sets */%s", NEWLINE, NEWLINE);
			first = false;
		}

		isqlGlob.printf("ALTER CHARACTER SET ");

		fb_utils::exact_name(/*CS.RDB$CHARACTER_SET_NAME*/
				     isc_200.isc_202);
		if (isqlGlob.db_SQL_dialect > SQL_DIALECT_V6_TRANSITION)
			ISQL_copy_SQL_id (/*CS.RDB$CHARACTER_SET_NAME*/
					  isc_200.isc_202, SQL_identifier, DBL_QUOTE);
		else
			strcpy (SQL_identifier, /*CS.RDB$CHARACTER_SET_NAME*/
						isc_200.isc_202);
		isqlGlob.printf("%s", SQL_identifier);

		fb_utils::exact_name(/*CS.RDB$DEFAULT_COLLATE_NAME*/
				     isc_200.isc_201);
		if (isqlGlob.db_SQL_dialect > SQL_DIALECT_V6_TRANSITION)
			ISQL_copy_SQL_id (/*CS.RDB$DEFAULT_COLLATE_NAME*/
					  isc_200.isc_201, SQL_identifier, DBL_QUOTE);
		else
			strcpy (SQL_identifier, /*CS.RDB$DEFAULT_COLLATE_NAME*/
						isc_200.isc_201);
		isqlGlob.printf(" SET DEFAULT COLLATION %s", SQL_identifier);

		isqlGlob.printf("%s%s", isqlGlob.global_Term, NEWLINE);
	/*END_FOR*/
	   }
	   };
	/*ON_ERROR*/
	if (isc_status [1])
	   {
		ISQL_errmsg(gds_status);
		return;
	/*END_ERROR;*/
	   }
	}

	if (! first)
		isqlGlob.printf(NEWLINE);
}


static void list_collations()
{
   struct isc_188_struct {
          ISC_QUAD isc_189;	/* RDB$SPECIFIC_ATTRIBUTES */
          char  isc_190 [32];	/* RDB$BASE_COLLATION_NAME */
          char  isc_191 [32];	/* RDB$CHARACTER_SET_NAME */
          char  isc_192 [32];	/* RDB$COLLATION_NAME */
          short isc_193;	/* isc_utility */
          short isc_194;	/* gds__null_flag */
          short isc_195;	/* gds__null_flag */
          short isc_196;	/* RDB$COLLATION_ATTRIBUTES */
          short isc_197;	/* gds__null_flag */
   } isc_188;
/**************************************
 *
 *	l i s t _ c o l l a t i o n s
 *
 **************************************
 *
 * Functional description
 *	Re create all non-system collations
 *
 **************************************/

	if (isqlGlob.major_ods < ODS_VERSION11)
		return;

	bool first = true;

	/*FOR CL IN RDB$COLLATIONS CROSS
		CS IN RDB$CHARACTER_SETS WITH
		CS.RDB$CHARACTER_SET_ID EQ CL.RDB$CHARACTER_SET_ID AND
		(CL.RDB$SYSTEM_FLAG MISSING OR CL.RDB$SYSTEM_FLAG NE 1)
		SORTED BY CS.RDB$CHARACTER_SET_NAME, CL.RDB$COLLATION_NAME*/
	{
        if (!isc_186)
           isc_compile_request2 (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &isc_186, (short) sizeof(isc_187), (char*) isc_187);
	if (isc_186)
	   {
           isc_start_request (isc_status, (FB_API_HANDLE*) &isc_186, (FB_API_HANDLE*) &gds_trans, (short) 0);
	   }
	if (!isc_status [1]) {
	while (1)
	   {
           isc_receive (isc_status, (FB_API_HANDLE*) &isc_186, (short) 0, (short) 114, &isc_188, (short) 0);
	   if (!isc_188.isc_193 || isc_status [1]) break;

		if (first)
		{
			isqlGlob.printf("%s/*  Collations */%s", NEWLINE, NEWLINE);
			first = false;
		}

		isqlGlob.printf("CREATE COLLATION ");

		fb_utils::exact_name(/*CL.RDB$COLLATION_NAME*/
				     isc_188.isc_192);
		if (isqlGlob.db_SQL_dialect > SQL_DIALECT_V6_TRANSITION)
			ISQL_copy_SQL_id (/*CL.RDB$COLLATION_NAME*/
					  isc_188.isc_192, SQL_identifier, DBL_QUOTE);
		else
			strcpy (SQL_identifier, /*CL.RDB$COLLATION_NAME*/
						isc_188.isc_192);
		isqlGlob.printf("%s", SQL_identifier);

		fb_utils::exact_name(/*CS.RDB$CHARACTER_SET_NAME*/
				     isc_188.isc_191);
		if (isqlGlob.db_SQL_dialect > SQL_DIALECT_V6_TRANSITION)
			ISQL_copy_SQL_id (/*CS.RDB$CHARACTER_SET_NAME*/
					  isc_188.isc_191, SQL_identifier, DBL_QUOTE);
		else
			strcpy (SQL_identifier, /*CS.RDB$CHARACTER_SET_NAME*/
						isc_188.isc_191);
		isqlGlob.printf(" FOR %s", SQL_identifier);

		if (!/*CL.RDB$BASE_COLLATION_NAME.NULL*/
		     isc_188.isc_197)
		{
			fb_utils::exact_name(/*CL.RDB$BASE_COLLATION_NAME*/
					     isc_188.isc_190);
			ISQL_copy_SQL_id (/*CL.RDB$BASE_COLLATION_NAME*/
					  isc_188.isc_190, SQL_identifier, SINGLE_QUOTE);
			isqlGlob.printf(" FROM EXTERNAL (%s)", SQL_identifier);
		}

		if (!/*CL.RDB$COLLATION_ATTRIBUTES.NULL*/
		     isc_188.isc_195)
		{
			if (/*CL.RDB$COLLATION_ATTRIBUTES*/
			    isc_188.isc_196 & TEXTTYPE_ATTR_PAD_SPACE)
				isqlGlob.printf(" PAD SPACE");

			if (/*CL.RDB$COLLATION_ATTRIBUTES*/
			    isc_188.isc_196 & TEXTTYPE_ATTR_CASE_INSENSITIVE)
				isqlGlob.printf(" CASE INSENSITIVE");

			if (/*CL.RDB$COLLATION_ATTRIBUTES*/
			    isc_188.isc_196 & TEXTTYPE_ATTR_ACCENT_INSENSITIVE)
				isqlGlob.printf(" ACCENT INSENSITIVE");
		}

		if (!/*CL.RDB$SPECIFIC_ATTRIBUTES.NULL*/
		     isc_188.isc_194)
		{
			isqlGlob.printf(" '");
			SHOW_print_metadata_text_blob (isqlGlob.Out, &/*CL.RDB$SPECIFIC_ATTRIBUTES*/
								      isc_188.isc_189);
			isqlGlob.printf("'");
		}

		isqlGlob.printf("%s%s", isqlGlob.global_Term, NEWLINE);
	/*END_FOR*/
	   }
	   };
	/*ON_ERROR*/
	if (isc_status [1])
	   {
		ISQL_errmsg(gds_status);
		return;
	/*END_ERROR;*/
	   }
	}

	isqlGlob.printf(NEWLINE);
}


#ifdef NOT_USED_OR_REPLACED
static void print_set(bool* set_used)
{
/**************************************
 *
 *	p r i n t _ s e t
 *
 **************************************
 *
 * Functional description
 *    print the word "SET"
 *    in the first line of the ALTER DATABASE
 *    settings options. Also, add trailing
 *    comma for end of prior line if needed.
 *
 * uses Print_buffer, a global
 *
 **************************************/
	if (!*set_used)
	{
		isqlGlob.printf("  SET ");
		*set_used = true;
	}
	else
	{
		isqlGlob.printf(", %s      ", NEWLINE);
	}
}
#endif


static void list_create_db()
{
   struct isc_169_struct {
          char  isc_170 [256];	/* RDB$FILE_NAME */
          ISC_LONG isc_171;	/* RDB$FILE_START */
          ISC_LONG isc_172;	/* RDB$FILE_LENGTH */
          short isc_173;	/* isc_utility */
          short isc_174;	/* RDB$SHADOW_NUMBER */
          short isc_175;	/* gds__null_flag */
          short isc_176;	/* gds__null_flag */
          short isc_177;	/* RDB$FILE_SEQUENCE */
          short isc_178;	/* gds__null_flag */
          short isc_179;	/* gds__null_flag */
          short isc_180;	/* RDB$FILE_FLAGS */
   } isc_169;
   struct isc_183_struct {
          char  isc_184 [32];	/* RDB$CHARACTER_SET_NAME */
          short isc_185;	/* isc_utility */
   } isc_183;
/**************************************
 *
 *	l i s t _ c r e a t e _ d b
 *
 **************************************
 *
 * Functional description
 *	Print the create database command if requested.  At least put
 *	the page size in a comment with the extracted db name
 *
 **************************************/
	static const SCHAR page_items[] =
	{
		isc_info_page_size,
		isc_info_end
	};

// Comment out the create database if no db param was specified
	bool nodb = false;
	if (!*isqlGlob.global_Target_db)
	{
		isqlGlob.printf("/* ");
		strcpy(isqlGlob.global_Target_db, isqlGlob.global_Db_name);
		nodb = true;
	}
	isqlGlob.printf("CREATE DATABASE '%s' ", isqlGlob.global_Target_db);

	// Get the page size from db_info call
	SCHAR info_buf[20];
	// CVC: Finally I got the idea: translate is associated with WISQL that
	// no longer exists. Localizing the messages means also not printing
	// any CRLF and therefore the output looks ugly.
	const bool translate = true;
	if (SHOW_dbb_parameters(DB, info_buf, page_items, sizeof(page_items), translate, " "))
	{
		isqlGlob.printf("%s", info_buf);
	}

	/*FOR DBP IN RDB$DATABASE
		WITH DBP.RDB$CHARACTER_SET_NAME NOT MISSING
		AND DBP.RDB$CHARACTER_SET_NAME != " "*/
	{
        if (!isc_181)
           isc_compile_request2 (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &isc_181, (short) sizeof(isc_182), (char*) isc_182);
	if (isc_181)
	   {
           isc_start_request (isc_status, (FB_API_HANDLE*) &isc_181, (FB_API_HANDLE*) &gds_trans, (short) 0);
	   }
	if (!isc_status [1]) {
	while (1)
	   {
           isc_receive (isc_status, (FB_API_HANDLE*) &isc_181, (short) 0, (short) 34, &isc_183, (short) 0);
	   if (!isc_183.isc_185 || isc_status [1]) break;;
		isqlGlob.printf("DEFAULT CHARACTER SET %s",
			fb_utils::exact_name(/*DBP.RDB$CHARACTER_SET_NAME*/
					     isc_183.isc_184));
	/*END_FOR*/
	   }
	   };
	/*ON_ERROR*/
	if (isc_status [1])
	   {
		ISQL_errmsg(gds_status);
		return;
	/*END_ERROR;*/
	   }
	}

	if (nodb)
	{
		isqlGlob.printf(" */%s", NEWLINE);
	}
	else
	{
		isqlGlob.printf("%s%s", isqlGlob.global_Term, NEWLINE);
	}

// List secondary files and shadows as alter db and create shadow in comment

	bool first = true;

	/*FOR FIL IN RDB$FILES
		SORTED BY FIL.RDB$SHADOW_NUMBER, FIL.RDB$FILE_SEQUENCE*/
	{
        if (!isc_167)
           isc_compile_request2 (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &isc_167, (short) sizeof(isc_168), (char*) isc_168);
	if (isc_167)
	   {
           isc_start_request (isc_status, (FB_API_HANDLE*) &isc_167, (FB_API_HANDLE*) &gds_trans, (short) 0);
	   }
	if (!isc_status [1]) {
	while (1)
	   {
           isc_receive (isc_status, (FB_API_HANDLE*) &isc_167, (short) 0, (short) 280, &isc_169, (short) 0);
	   if (!isc_169.isc_173 || isc_status [1]) break;

		if (first)
		{
			isqlGlob.printf("%s/* Add secondary files in comments %s", NEWLINE, NEWLINE);
		}

		first = false;
		// reset nulls to zero

		if (/*FIL.RDB$FILE_FLAGS.NULL*/
		    isc_169.isc_179)
			/*FIL.RDB$FILE_FLAGS*/
			isc_169.isc_180 = 0;
		if (/*FIL.RDB$FILE_LENGTH.NULL*/
		    isc_169.isc_178)
			/*FIL.RDB$FILE_LENGTH*/
			isc_169.isc_172 = 0;
		if (/*FIL.RDB$FILE_SEQUENCE.NULL*/
		    isc_169.isc_176)
			/*FIL.RDB$FILE_SEQUENCE*/
			isc_169.isc_177 = 0;
		if (/*FIL.RDB$FILE_START.NULL*/
		    isc_169.isc_175)
			/*FIL.RDB$FILE_START*/
			isc_169.isc_171 = 0;
		fb_utils::exact_name(/*FIL.RDB$FILE_NAME*/
				     isc_169.isc_170);

		// Pure secondary files
		if (/*FIL.RDB$FILE_FLAGS*/
		    isc_169.isc_180 == 0)
		{
			isqlGlob.printf("%sALTER DATABASE ADD FILE '%s'", NEWLINE, /*FIL.RDB$FILE_NAME*/
										   isc_169.isc_170);
			if (/*FIL.RDB$FILE_START*/
			    isc_169.isc_171)
			{
				isqlGlob.printf(" STARTING %ld", /*FIL.RDB$FILE_START*/
								 isc_169.isc_171);
			}
			if (/*FIL.RDB$FILE_LENGTH*/
			    isc_169.isc_172)
			{
				isqlGlob.printf(" LENGTH %ld", /*FIL.RDB$FILE_LENGTH*/
							       isc_169.isc_172);
			}
			isqlGlob.printf(NEWLINE);
		}

		if (/*FIL.RDB$FILE_FLAGS*/
		    isc_169.isc_180 & FILE_shadow)
		{
			if (/*FIL.RDB$FILE_SEQUENCE*/
			    isc_169.isc_177)
			{
				isqlGlob.printf("%sFILE '%s' ", TAB_AS_SPACES, /*FIL.RDB$FILE_NAME*/
									       isc_169.isc_170);
			}
			else
			{
				isqlGlob.printf("%sCREATE SHADOW %d '%s' ",
						 NEWLINE,
						 /*FIL.RDB$SHADOW_NUMBER*/
						 isc_169.isc_174,
						 /*FIL.RDB$FILE_NAME*/
						 isc_169.isc_170);
				if (/*FIL.RDB$FILE_FLAGS*/
				    isc_169.isc_180 & FILE_inactive)
					isqlGlob.printf("INACTIVE ");
				if (/*FIL.RDB$FILE_FLAGS*/
				    isc_169.isc_180 & FILE_manual)
					isqlGlob.printf("MANUAL ");
				else
					isqlGlob.printf("AUTO ");
				if (/*FIL.RDB$FILE_FLAGS*/
				    isc_169.isc_180 & FILE_conditional)
					isqlGlob.printf("CONDITIONAL ");
			}
			if (/*FIL.RDB$FILE_LENGTH*/
			    isc_169.isc_172)
			{
				isqlGlob.printf("LENGTH %ld ", /*FIL.RDB$FILE_LENGTH*/
							       isc_169.isc_172);
			}
			if (/*FIL.RDB$FILE_START*/
			    isc_169.isc_171)
			{
				isqlGlob.printf("STARTING %ld ", /*FIL.RDB$FILE_START*/
								 isc_169.isc_171);
			}
			isqlGlob.printf(NEWLINE);
		}

	/*END_FOR*/
	   }
	   };
	/*ON_ERROR*/
	if (isc_status [1])
	   {
		ISQL_errmsg(gds_status);
		return;
	/*END_ERROR;*/
	   }
	}

	if (!first)
	{
		if (nodb)
		{
			isqlGlob.printf("%s */%s", NEWLINE, NEWLINE);
		}
		else
		{
			isqlGlob.printf("%s%s%s", isqlGlob.global_Term, NEWLINE, NEWLINE);
		}
	}
}


static void list_domain_table(const SCHAR* table_name, SSHORT default_char_set_id)
{
   struct isc_137_struct {
          short isc_138;	/* isc_utility */
          short isc_139;	/* RDB$FIELD_SCALE */
          short isc_140;	/* RDB$FIELD_SUB_TYPE */
          short isc_141;	/* gds__null_flag */
          short isc_142;	/* RDB$FIELD_PRECISION */
   } isc_137;
   struct isc_135_struct {
          char  isc_136 [32];	/* RDB$FIELD_NAME */
   } isc_135;
   struct isc_147_struct {
          ISC_QUAD isc_148;	/* RDB$VALIDATION_SOURCE */
          ISC_QUAD isc_149;	/* RDB$DEFAULT_SOURCE */
          char  isc_150 [32];	/* RDB$FIELD_NAME */
          short isc_151;	/* isc_utility */
          short isc_152;	/* RDB$NULL_FLAG */
          short isc_153;	/* gds__null_flag */
          short isc_154;	/* gds__null_flag */
          short isc_155;	/* gds__null_flag */
          short isc_156;	/* RDB$DIMENSIONS */
          short isc_157;	/* gds__null_flag */
          short isc_158;	/* RDB$COLLATION_ID */
          short isc_159;	/* gds__null_flag */
          short isc_160;	/* RDB$CHARACTER_SET_ID */
          short isc_161;	/* RDB$SEGMENT_LENGTH */
          short isc_162;	/* RDB$FIELD_SUB_TYPE */
          short isc_163;	/* RDB$FIELD_SCALE */
          short isc_164;	/* RDB$FIELD_TYPE */
          short isc_165;	/* gds__null_flag */
          short isc_166;	/* RDB$SYSTEM_FLAG */
   } isc_147;
   struct isc_145_struct {
          char  isc_146 [32];	/* RDB$RELATION_NAME */
   } isc_145;
/**************************************
 *
 *	l i s t _ d o m a i n _ t a b l e
 *
 **************************************
 *
 * Functional description
 *	List domains as identified by fields with any constraints on them
 *	for the named table
 *
 *	Parameters:  table_name == only extract domains for this table
 *	default_char_set_id -- character set def to supress
 *
 **************************************/
	bool first = true;
	SCHAR char_sets[86];

	/*FOR FLD IN RDB$FIELDS CROSS
		RFR IN RDB$RELATION_FIELDS WITH
		RFR.RDB$FIELD_SOURCE EQ FLD.RDB$FIELD_NAME AND
		RFR.RDB$RELATION_NAME EQ table_name
		SORTED BY FLD.RDB$FIELD_NAME*/
	{
        if (!isc_143)
           isc_compile_request2 (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &isc_143, (short) sizeof(isc_144), (char*) isc_144);
	isc_vtov ((const char*) table_name, (char*) isc_145.isc_146, 32);
	if (isc_143)
	   {
           isc_start_and_send (isc_status, (FB_API_HANDLE*) &isc_143, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 32, &isc_145, (short) 0);
	   }
	if (!isc_status [1]) {
	while (1)
	   {
           isc_receive (isc_status, (FB_API_HANDLE*) &isc_143, (short) 1, (short) 80, &isc_147, (short) 0);
	   if (!isc_147.isc_151 || isc_status [1]) break;

		// Skip over artificial domains
		if (fb_utils::implicit_domain(/*FLD.RDB$FIELD_NAME*/
					      isc_147.isc_150) &&
			(/*FLD.RDB$SYSTEM_FLAG.NULL*/
			 isc_147.isc_165 || /*FLD.RDB$SYSTEM_FLAG*/
    isc_147.isc_166 != 1))
		{
			continue;
		}

		if (first)
		{
			isqlGlob.printf("/* Domain definitions */%s", NEWLINE);
			first = false;
		}
		fb_utils::exact_name(/*FLD.RDB$FIELD_NAME*/
				     isc_147.isc_150);

		isqlGlob.printf("CREATE DOMAIN %s AS ", /*FLD.RDB$FIELD_NAME*/
							isc_147.isc_150);

		for (int i = 0; Column_types[i].type; i++)
			if (/*FLD.RDB$FIELD_TYPE*/
			    isc_147.isc_164 == Column_types[i].type)
			{
				bool precision_known = false;

				if (isqlGlob.major_ods >= ODS_VERSION10)
				{
					// Handle Integral subtypes NUMERIC and DECIMAL
					if ((/*FLD.RDB$FIELD_TYPE*/
					     isc_147.isc_164 == SMALLINT) ||
						(/*FLD.RDB$FIELD_TYPE*/
						 isc_147.isc_164 == INTEGER) ||
						(/*FLD.RDB$FIELD_TYPE*/
						 isc_147.isc_164 == BIGINT))
					{
						/* We are ODS >= 10 and could be any Dialect */

						/*FOR FLD1 IN RDB$FIELDS WITH
							FLD1.RDB$FIELD_NAME EQ FLD.RDB$FIELD_NAME*/
						{
                                                if (!isc_133)
                                                   isc_compile_request2 (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &isc_133, (short) sizeof(isc_134), (char*) isc_134);
						isc_vtov ((const char*) isc_147.isc_150, (char*) isc_135.isc_136, 32);
						if (isc_133)
						   {
                                                   isc_start_and_send (isc_status, (FB_API_HANDLE*) &isc_133, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 32, &isc_135, (short) 0);
						   }
						if (!isc_status [1]) {
						while (1)
						   {
                                                   isc_receive (isc_status, (FB_API_HANDLE*) &isc_133, (short) 1, (short) 10, &isc_137, (short) 0);
						   if (!isc_137.isc_138 || isc_status [1]) break;
							if (!/*FLD1.RDB$FIELD_PRECISION.NULL*/
							     isc_137.isc_141)
							{
								/* We are Dialect >=3 since FIELD_PRECISION is non-NULL */
								if (/*FLD1.RDB$FIELD_SUB_TYPE*/
								    isc_137.isc_140 > 0 &&
									/*FLD1.RDB$FIELD_SUB_TYPE*/
									isc_137.isc_140 <= MAX_INTSUBTYPES)
								{
									sprintf (Print_buffer, "%s(%d, %d)",
											 Integral_subtypes[/*FLD1.RDB$FIELD_SUB_TYPE*/
													   isc_137.isc_140],
											 /*FLD1.RDB$FIELD_PRECISION*/
											 isc_137.isc_142,
												 -/*FLD1.RDB$FIELD_SCALE*/
												  isc_137.isc_139);
									precision_known = true;
								}
							}
						/*END_FOR*/
						   }
						   };
						/*ON_ERROR*/
						if (isc_status [1])
						   {
							ISQL_errmsg (isc_status);
							return;
						/*END_ERROR;*/
						   }
						}
					}
				}

				if (!precision_known)
				{
					// Take a stab at numerics and decimals
					if ((/*FLD.RDB$FIELD_TYPE*/
					     isc_147.isc_164 == SMALLINT) && (/*FLD.RDB$FIELD_SCALE*/
		  isc_147.isc_163 < 0))
					{
						sprintf (Print_buffer, "NUMERIC(4, %d)", -/*FLD.RDB$FIELD_SCALE*/
											  isc_147.isc_163);
					}
					else if ((/*FLD.RDB$FIELD_TYPE*/
						  isc_147.isc_164 == INTEGER) && (/*FLD.RDB$FIELD_SCALE*/
		 isc_147.isc_163 < 0))
					{
						sprintf (Print_buffer, "NUMERIC(9, %d)", -/*FLD.RDB$FIELD_SCALE*/
											  isc_147.isc_163);
					}
					else if ((/*FLD.RDB$FIELD_TYPE*/
						  isc_147.isc_164 == DOUBLE_PRECISION) &&
							 (/*FLD.RDB$FIELD_SCALE*/
							  isc_147.isc_163 < 0))
					{
						sprintf (Print_buffer, "NUMERIC(15, %d)", -/*FLD.RDB$FIELD_SCALE*/
											   isc_147.isc_163);
					}
					else
					{
						sprintf (Print_buffer, "%s", Column_types[i].type_name);
					}
				}
				isqlGlob.prints(Print_buffer);
				break;
			}


		if (/*FLD.RDB$FIELD_TYPE*/
		    isc_147.isc_164 == BLOB)
		{
			const int subtype = /*FLD.RDB$FIELD_SUB_TYPE*/
					    isc_147.isc_162;
			isqlGlob.printf(" SUB_TYPE ");
			if ((subtype > 0) && (subtype <= MAX_BLOBSUBTYPES))
			{
				isqlGlob.prints(Sub_types[subtype]);
			}
			else
			{
				isqlGlob.printf("%d", subtype);
			}
			isqlGlob.printf(" SEGMENT SIZE %u", (USHORT) /*FLD.RDB$SEGMENT_LENGTH*/
								     isc_147.isc_161);
		}

		else if ((/*FLD.RDB$FIELD_TYPE*/
			  isc_147.isc_164 == T_CHAR) || (/*FLD.RDB$FIELD_TYPE*/
		isc_147.isc_164 == VARCHAR))
		{
			// Length for chars
			isqlGlob.printf("(%d)", ISQL_get_field_length(/*FLD.RDB$FIELD_NAME*/
								      isc_147.isc_150));
		}

		/* Bug 8261: do not show the collation information just yet!  If you
		   do, then the domain syntax when printed is not correct */

		/* since the character set is part of the field type, display that
		   information now. */
		if (!/*FLD.RDB$CHARACTER_SET_ID.NULL*/
		     isc_147.isc_159)
		{

			char_sets[0] = 0;
			if ((/*FLD.RDB$CHARACTER_SET_ID*/
			     isc_147.isc_160 != default_char_set_id) ||
				(!/*FLD.RDB$COLLATION_ID.NULL*/
				  isc_147.isc_157 && /*FLD.RDB$COLLATION_ID*/
    isc_147.isc_158 != 0))
			{
				ISQL_get_character_sets (/*FLD.RDB$CHARACTER_SET_ID*/
							 isc_147.isc_160, 0, false, false, char_sets);
			}
			if (char_sets[0])
				isqlGlob.prints(char_sets);
		}

		if (!/*FLD.RDB$DIMENSIONS.NULL*/
		     isc_147.isc_155)
			ISQL_array_dimensions (/*FLD.RDB$FIELD_NAME*/
					       isc_147.isc_150);

		if (!/*FLD.RDB$DEFAULT_SOURCE.NULL*/
		     isc_147.isc_154)
		{
			isqlGlob.printf("%s%s ", NEWLINE, TAB_AS_SPACES);
			SHOW_print_metadata_text_blob (isqlGlob.Out, &/*FLD.RDB$DEFAULT_SOURCE*/
								      isc_147.isc_149);
		}
		if (!/*FLD.RDB$VALIDATION_SOURCE.NULL*/
		     isc_147.isc_153)
		{
			isqlGlob.printf("%s%s ", NEWLINE, TAB_AS_SPACES);
			ISQL_print_validation (isqlGlob.Out, &/*FLD.RDB$VALIDATION_SOURCE*/
							      isc_147.isc_148, false, gds_trans);
		}
		if (/*FLD.RDB$NULL_FLAG*/
		    isc_147.isc_152 == 1)
			isqlGlob.printf(" NOT NULL");

		// Bug 8261:  Now show the collation order information
		/* Show the collation order if one has been specified.  If the collation
		   order is the default for the character set being used, then no collation
		   order will be shown ( because it isn't needed ).

		If the collation id is 0, then the default for the character set is
		being used so there is no need to retrieve the collation information.*/

		if (!/*FLD.RDB$COLLATION_ID.NULL*/
		     isc_147.isc_157 && /*FLD.RDB$COLLATION_ID*/
    isc_147.isc_158 != 0)
		{
			char_sets[0] = 0;
			ISQL_get_character_sets (/*FLD.RDB$CHARACTER_SET_ID*/
						 isc_147.isc_160, /*FLD.RDB$COLLATION_ID*/
  isc_147.isc_158, true, false, char_sets);
			if (char_sets[0])
				isqlGlob.prints(char_sets);
		}

		isqlGlob.printf("%s%s", isqlGlob.global_Term, NEWLINE);
	/*END_FOR*/
	   }
	   };
	/*ON_ERROR*/
	if (isc_status [1])
	   {
		ISQL_errmsg(gds_status);
		return;
	/*END_ERROR;*/
	   }
	}
}


static void list_domains(SSHORT default_char_set_id)
{
   struct isc_107_struct {
          short isc_108;	/* isc_utility */
          short isc_109;	/* RDB$FIELD_SCALE */
          short isc_110;	/* RDB$FIELD_SUB_TYPE */
          short isc_111;	/* gds__null_flag */
          short isc_112;	/* RDB$FIELD_PRECISION */
   } isc_107;
   struct isc_105_struct {
          char  isc_106 [32];	/* RDB$FIELD_NAME */
   } isc_105;
   struct isc_115_struct {
          ISC_QUAD isc_116;	/* RDB$VALIDATION_SOURCE */
          ISC_QUAD isc_117;	/* RDB$DEFAULT_SOURCE */
          char  isc_118 [32];	/* RDB$FIELD_NAME */
          short isc_119;	/* isc_utility */
          short isc_120;	/* RDB$NULL_FLAG */
          short isc_121;	/* gds__null_flag */
          short isc_122;	/* gds__null_flag */
          short isc_123;	/* gds__null_flag */
          short isc_124;	/* RDB$DIMENSIONS */
          short isc_125;	/* gds__null_flag */
          short isc_126;	/* RDB$COLLATION_ID */
          short isc_127;	/* gds__null_flag */
          short isc_128;	/* RDB$CHARACTER_SET_ID */
          short isc_129;	/* RDB$SEGMENT_LENGTH */
          short isc_130;	/* RDB$FIELD_SUB_TYPE */
          short isc_131;	/* RDB$FIELD_SCALE */
          short isc_132;	/* RDB$FIELD_TYPE */
   } isc_115;
/**************************************
 *
 *	l i s t _ d o m a i n s
 *
 **************************************
 *
 * Functional description
 *	List domains
 *
 *	Parameters:
 *	default_char_set_id -- character set def to supress
 *
 **************************************/
	bool first = true;
	SCHAR char_sets[86];

	/*FOR FLD IN RDB$FIELDS WITH
		FLD.RDB$FIELD_NAME NOT MATCHING "RDB$+" USING "+=[0-9][0-9]* *"
		AND FLD.RDB$SYSTEM_FLAG NE 1
		SORTED BY FLD.RDB$FIELD_NAME*/
	{
        if (!isc_113)
           isc_compile_request2 (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &isc_113, (short) sizeof(isc_114), (char*) isc_114);
	if (isc_113)
	   {
           isc_start_request (isc_status, (FB_API_HANDLE*) &isc_113, (FB_API_HANDLE*) &gds_trans, (short) 0);
	   }
	if (!isc_status [1]) {
	while (1)
	   {
           isc_receive (isc_status, (FB_API_HANDLE*) &isc_113, (short) 0, (short) 76, &isc_115, (short) 0);
	   if (!isc_115.isc_119 || isc_status [1]) break;

		if (first)
		{
			isqlGlob.printf("/* Domain definitions */%s", NEWLINE);
			first = false;
		}
		fb_utils::exact_name(/*FLD.RDB$FIELD_NAME*/
				     isc_115.isc_118);

		if (isqlGlob.db_SQL_dialect > SQL_DIALECT_V6_TRANSITION)
		{
			ISQL_copy_SQL_id(/*FLD.RDB$FIELD_NAME*/
					 isc_115.isc_118, SQL_identifier, DBL_QUOTE);
			isqlGlob.printf("CREATE DOMAIN %s AS ", SQL_identifier);
		}
		else
			isqlGlob.printf("CREATE DOMAIN %s AS ", /*FLD.RDB$FIELD_NAME*/
								isc_115.isc_118);

		// Get domain type
		for (int i = 0; Column_types[i].type; i++)
			if (/*FLD.RDB$FIELD_TYPE*/
			    isc_115.isc_132 == Column_types[i].type)
			{
				bool precision_known = false;

				if (isqlGlob.major_ods >= ODS_VERSION10)
				{
					// Handle Integral subtypes NUMERIC and DECIMAL
					if ((/*FLD.RDB$FIELD_TYPE*/
					     isc_115.isc_132 == SMALLINT) ||
						(/*FLD.RDB$FIELD_TYPE*/
						 isc_115.isc_132 == INTEGER) ||
						(/*FLD.RDB$FIELD_TYPE*/
						 isc_115.isc_132 == BIGINT))
					{
						/* We are ODS >= 10 and could be any Dialect */
						/*FOR FLD1 IN RDB$FIELDS WITH
							FLD1.RDB$FIELD_NAME EQ FLD.RDB$FIELD_NAME*/
						{
                                                if (!isc_103)
                                                   isc_compile_request2 (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &isc_103, (short) sizeof(isc_104), (char*) isc_104);
						isc_vtov ((const char*) isc_115.isc_118, (char*) isc_105.isc_106, 32);
						if (isc_103)
						   {
                                                   isc_start_and_send (isc_status, (FB_API_HANDLE*) &isc_103, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 32, &isc_105, (short) 0);
						   }
						if (!isc_status [1]) {
						while (1)
						   {
                                                   isc_receive (isc_status, (FB_API_HANDLE*) &isc_103, (short) 1, (short) 10, &isc_107, (short) 0);
						   if (!isc_107.isc_108 || isc_status [1]) break;

							if (!/*FLD1.RDB$FIELD_PRECISION.NULL*/
							     isc_107.isc_111)
							{
								/* We are Dialect >=3 since FIELD_PRECISION is non-NULL */
								if (/*FLD1.RDB$FIELD_SUB_TYPE*/
								    isc_107.isc_110 > 0 &&
									/*FLD1.RDB$FIELD_SUB_TYPE*/
									isc_107.isc_110 <= MAX_INTSUBTYPES)
								{
									sprintf (Print_buffer, "%s(%d, %d)",
											 Integral_subtypes[/*FLD1.RDB$FIELD_SUB_TYPE*/
													   isc_107.isc_110],
											 /*FLD1.RDB$FIELD_PRECISION*/
											 isc_107.isc_112,
											 -/*FLD1.RDB$FIELD_SCALE*/
											  isc_107.isc_109);
									precision_known = true;
								}
							}
						/*END_FOR*/
						   }
						   };
						/*ON_ERROR*/
						if (isc_status [1])
						   {
							ISQL_errmsg (isc_status);
							return;
						/*END_ERROR;*/
						   }
						}
					}
				}

				if (!precision_known)
				{
					// Take a stab at numerics and decimals
					if ((/*FLD.RDB$FIELD_TYPE*/
					     isc_115.isc_132 == SMALLINT) && (/*FLD.RDB$FIELD_SCALE*/
		  isc_115.isc_131 < 0))
					{
						sprintf (Print_buffer, "NUMERIC(4, %d)", -/*FLD.RDB$FIELD_SCALE*/
											  isc_115.isc_131);
					}
					else if ((/*FLD.RDB$FIELD_TYPE*/
						  isc_115.isc_132 == INTEGER) && (/*FLD.RDB$FIELD_SCALE*/
		 isc_115.isc_131 < 0))
					{
						sprintf (Print_buffer, "NUMERIC(9, %d)", -/*FLD.RDB$FIELD_SCALE*/
											  isc_115.isc_131);
					}
					else if ((/*FLD.RDB$FIELD_TYPE*/
						  isc_115.isc_132 == DOUBLE_PRECISION) &&
							 (/*FLD.RDB$FIELD_SCALE*/
							  isc_115.isc_131 < 0))
					{
						sprintf (Print_buffer, "NUMERIC(15, %d)", -/*FLD.RDB$FIELD_SCALE*/
											   isc_115.isc_131);
					}
					else
					{
						sprintf (Print_buffer, "%s", Column_types[i].type_name);
					}
				}
				isqlGlob.prints(Print_buffer);
				break;
			}

		if (/*FLD.RDB$FIELD_TYPE*/
		    isc_115.isc_132 == BLOB)
		{
			const int subtype = /*FLD.RDB$FIELD_SUB_TYPE*/
					    isc_115.isc_130;
			isqlGlob.printf(" SUB_TYPE ");

			if ((subtype > 0) && (subtype <= MAX_BLOBSUBTYPES))
			{
				isqlGlob.prints(Sub_types[subtype]);
			}
			else
			{
				isqlGlob.printf("%d", subtype);
			}
			isqlGlob.printf(" SEGMENT SIZE %u", (USHORT) /*FLD.RDB$SEGMENT_LENGTH*/
								     isc_115.isc_129);
		}

		else if ((/*FLD.RDB$FIELD_TYPE*/
			  isc_115.isc_132 == T_CHAR) || (/*FLD.RDB$FIELD_TYPE*/
		isc_115.isc_132 == VARCHAR))
		{
			// Length for chars
			isqlGlob.printf("(%d)", ISQL_get_field_length(/*FLD.RDB$FIELD_NAME*/
								      isc_115.isc_118));
		}

		/* Bug 8261: do not show the collation information just yet!  If you
		   do, then the domain syntax when printed is not correct */

		/* since the character set is part of the field type, display that
		   information now. */
		if (!/*FLD.RDB$CHARACTER_SET_ID.NULL*/
		     isc_115.isc_127)
		{
			char_sets[0] = 0;
			if ((/*FLD.RDB$CHARACTER_SET_ID*/
			     isc_115.isc_128 != default_char_set_id) ||
				(!/*FLD.RDB$COLLATION_ID.NULL*/
				  isc_115.isc_125 && /*FLD.RDB$COLLATION_ID*/
    isc_115.isc_126 != 0))
			{
				ISQL_get_character_sets (/*FLD.RDB$CHARACTER_SET_ID*/
							 isc_115.isc_128, 0, false, false, char_sets);
			}
			if (char_sets[0])
				isqlGlob.prints(char_sets);
		}

		if (!/*FLD.RDB$DIMENSIONS.NULL*/
		     isc_115.isc_123)
			ISQL_array_dimensions (/*FLD.RDB$FIELD_NAME*/
					       isc_115.isc_118);

		if (!/*FLD.RDB$DEFAULT_SOURCE.NULL*/
		     isc_115.isc_122)
		{
			isqlGlob.printf("%s%s ", NEWLINE, TAB_AS_SPACES);
			SHOW_print_metadata_text_blob (isqlGlob.Out, &/*FLD.RDB$DEFAULT_SOURCE*/
								      isc_115.isc_117);
		}
		if (!/*FLD.RDB$VALIDATION_SOURCE.NULL*/
		     isc_115.isc_121)
		{
			isqlGlob.printf("%s%s ", NEWLINE, TAB_AS_SPACES);
			ISQL_print_validation (isqlGlob.Out, &/*FLD.RDB$VALIDATION_SOURCE*/
							      isc_115.isc_116, false, gds_trans);
		}
		if (/*FLD.RDB$NULL_FLAG*/
		    isc_115.isc_120 == 1)
			isqlGlob.printf(" NOT NULL");

		// Bug 8261:  Now show the collation order information
		/* Show the collation order if one has been specified.  If the collation
		   order is the default for the character set being used, then no collation
		   order will be shown ( because it isn't needed

		   If the collation id is 0, then the default for the character set is
		   being used so there is no need to retrieve the collation information.*/

		if (!/*FLD.RDB$COLLATION_ID.NULL*/
		     isc_115.isc_125 && /*FLD.RDB$COLLATION_ID*/
    isc_115.isc_126 != 0)
		{
			char_sets[0] = 0;
			ISQL_get_character_sets (/*FLD.RDB$CHARACTER_SET_ID*/
						 isc_115.isc_128, /*FLD.RDB$COLLATION_ID*/
  isc_115.isc_126, true, false, char_sets);
			if (char_sets[0])
				isqlGlob.prints(char_sets);
		}

		isqlGlob.printf("%s%s", isqlGlob.global_Term, NEWLINE);
	/*END_FOR*/
	   }
	   };
	/*ON_ERROR*/
	if (isc_status [1])
	   {
		ISQL_errmsg(gds_status);
		return;
	/*END_ERROR;*/
	   }
	}
}


static void list_exception()
{
   struct isc_99_struct {
          char  isc_100 [1024];	/* RDB$MESSAGE */
          char  isc_101 [32];	/* RDB$EXCEPTION_NAME */
          short isc_102;	/* isc_utility */
   } isc_99;
/**************************************
 *
 *	l i s t _ e x c e p t i o n
 *
 **************************************
 *
 * Functional description
 *	List all exceptions defined in the database
 *
 *	Parameters:  none
 *
 **************************************/
	bool first = true;

	/*FOR EXC IN RDB$EXCEPTIONS
		SORTED BY EXC.RDB$EXCEPTION_NAME*/
	{
        if (!isc_97)
           isc_compile_request2 (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &isc_97, (short) sizeof(isc_98), (char*) isc_98);
	if (isc_97)
	   {
           isc_start_request (isc_status, (FB_API_HANDLE*) &isc_97, (FB_API_HANDLE*) &gds_trans, (short) 0);
	   }
	if (!isc_status [1]) {
	while (1)
	   {
           isc_receive (isc_status, (FB_API_HANDLE*) &isc_97, (short) 0, (short) 1058, &isc_99, (short) 0);
	   if (!isc_99.isc_102 || isc_status [1]) break;

		if (first)
		{
			isqlGlob.printf("%s/*  Exceptions */%s", NEWLINE, NEWLINE);
		}
		first = false;
		fb_utils::exact_name(/*EXC.RDB$EXCEPTION_NAME*/
				     isc_99.isc_101);

		ISQL_copy_SQL_id (/*EXC.RDB$MESSAGE*/
				  isc_99.isc_100, SQL_identifier2, SINGLE_QUOTE);
		if (isqlGlob.db_SQL_dialect > SQL_DIALECT_V6_TRANSITION)
		{
			ISQL_copy_SQL_id (/*EXC.RDB$EXCEPTION_NAME*/
					  isc_99.isc_101, SQL_identifier, DBL_QUOTE);
			isqlGlob.printf("CREATE EXCEPTION %s %s%s%s",
					 SQL_identifier, SQL_identifier2, isqlGlob.global_Term, NEWLINE);
		}
		else
			isqlGlob.printf("CREATE EXCEPTION %s %s%s%s",
					 /*EXC.RDB$EXCEPTION_NAME*/
					 isc_99.isc_101, SQL_identifier2, isqlGlob.global_Term, NEWLINE);

	/*END_FOR*/
	   }
	   };
	/*ON_ERROR*/
	if (isc_status [1])
	   {
		ISQL_errmsg(gds_status);
		return;
	/*END_ERROR;*/
	   }
	}
}


static void list_filters()
{
   struct isc_90_struct {
          char  isc_91 [32];	/* RDB$ENTRYPOINT */
          char  isc_92 [256];	/* RDB$MODULE_NAME */
          char  isc_93 [32];	/* RDB$FUNCTION_NAME */
          short isc_94;	/* isc_utility */
          short isc_95;	/* RDB$OUTPUT_SUB_TYPE */
          short isc_96;	/* RDB$INPUT_SUB_TYPE */
   } isc_90;
/**************************************
 *
 *	l i s t _ f i l t e r s
 *
 **************************************
 *
 * Functional description
 *	List all blob filters
 *
 *	Parameters:  none
 * Results in
 * DECLARE FILTER <fname> INPUT_TYPE <blob_sub_type> OUTPUT_TYPE <blob_subtype>
 *		 ENTRY_POINT <string> MODULE_NAME <string>
 **************************************/
	bool first = true;

	/*FOR FIL IN RDB$FILTERS
		SORTED BY FIL.RDB$FUNCTION_NAME*/
	{
        if (!isc_88)
           isc_compile_request2 (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &isc_88, (short) sizeof(isc_89), (char*) isc_89);
	if (isc_88)
	   {
           isc_start_request (isc_status, (FB_API_HANDLE*) &isc_88, (FB_API_HANDLE*) &gds_trans, (short) 0);
	   }
	if (!isc_status [1]) {
	while (1)
	   {
           isc_receive (isc_status, (FB_API_HANDLE*) &isc_88, (short) 0, (short) 326, &isc_90, (short) 0);
	   if (!isc_90.isc_94 || isc_status [1]) break;

		fb_utils::exact_name(/*FIL.RDB$FUNCTION_NAME*/
				     isc_90.isc_93);
		fb_utils::exact_name(/*FIL.RDB$MODULE_NAME*/
				     isc_90.isc_92);
		fb_utils::exact_name(/*FIL.RDB$ENTRYPOINT*/
				     isc_90.isc_91);

		if (first)
		{
			isqlGlob.printf("%s/*  BLOB Filter declarations */%s", NEWLINE, NEWLINE);
			first = false;
		}

		if (isqlGlob.db_SQL_dialect > SQL_DIALECT_V6_TRANSITION)
			ISQL_copy_SQL_id(/*FIL.RDB$FUNCTION_NAME*/
					 isc_90.isc_93, SQL_identifier, DBL_QUOTE);
		else
			strcpy(SQL_identifier, /*FIL.RDB$FUNCTION_NAME*/
					       isc_90.isc_93);

		isqlGlob.printf("DECLARE FILTER %s INPUT_TYPE %d OUTPUT_TYPE %d%s",
			SQL_identifier, /*FIL.RDB$INPUT_SUB_TYPE*/
					isc_90.isc_96, /*FIL.RDB$OUTPUT_SUB_TYPE*/
  isc_90.isc_95, NEWLINE);

		ISQL_copy_SQL_id(/*FIL.RDB$ENTRYPOINT*/
				 isc_90.isc_91, SQL_identifier, SINGLE_QUOTE);
		ISQL_copy_SQL_id(/*FIL.RDB$MODULE_NAME*/
				 isc_90.isc_92, SQL_identifier2, SINGLE_QUOTE);

		isqlGlob.printf("%sENTRY_POINT %s MODULE_NAME %s%s%s%s",
			TAB_AS_SPACES, SQL_identifier, SQL_identifier2,
			isqlGlob.global_Term, NEWLINE, NEWLINE);

	/*END_FOR*/
	   }
	   };
	/*ON_ERROR*/
	if (isc_status [1])
	   {
		ISQL_errmsg(gds_status);
		return;
	/*END_ERROR;*/
	   }
	}

}


static void list_foreign()
{
   struct isc_76_struct {
          char  isc_77 [32];	/* RDB$INDEX_NAME */
          char  isc_78 [32];	/* RDB$CONSTRAINT_NAME */
          char  isc_79 [32];	/* RDB$INDEX_NAME */
          char  isc_80 [32];	/* RDB$RELATION_NAME */
          char  isc_81 [32];	/* RDB$RELATION_NAME */
          char  isc_82 [12];	/* RDB$DELETE_RULE */
          char  isc_83 [12];	/* RDB$UPDATE_RULE */
          short isc_84;	/* isc_utility */
          short isc_85;	/* gds__null_flag */
          short isc_86;	/* gds__null_flag */
          short isc_87;	/* gds__null_flag */
   } isc_76;
/**************************************
 *
 *	l i s t _ f o r e i g n
 *
 **************************************
 *
 * Functional description
 *	List all foreign key constraints and alter the tables
 *
 **************************************/
	SCHAR collist[BUFFER_LENGTH512 * 2];

/* Static queries for obtaining foreign constraints, where RELC1 is the
   foreign key constraints, RELC2 is the primary key lookup and REFC
   is the join table */

	/*FOR RELC1 IN RDB$RELATION_CONSTRAINTS CROSS
		RELC2 IN RDB$RELATION_CONSTRAINTS CROSS
		REFC IN RDB$REF_CONSTRAINTS WITH
		RELC1.RDB$CONSTRAINT_TYPE EQ "FOREIGN KEY" AND
		REFC.RDB$CONST_NAME_UQ EQ RELC2.RDB$CONSTRAINT_NAME AND
		REFC.RDB$CONSTRAINT_NAME EQ RELC1.RDB$CONSTRAINT_NAME AND
		(RELC2.RDB$CONSTRAINT_TYPE EQ "UNIQUE" OR
		RELC2.RDB$CONSTRAINT_TYPE EQ "PRIMARY KEY")
		SORTED BY RELC1.RDB$RELATION_NAME, RELC1.RDB$CONSTRAINT_NAME*/
	{
        if (!isc_74)
           isc_compile_request2 (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &isc_74, (short) sizeof(isc_75), (char*) isc_75);
	if (isc_74)
	   {
           isc_start_request (isc_status, (FB_API_HANDLE*) &isc_74, (FB_API_HANDLE*) &gds_trans, (short) 0);
	   }
	if (!isc_status [1]) {
	while (1)
	   {
           isc_receive (isc_status, (FB_API_HANDLE*) &isc_74, (short) 0, (short) 192, &isc_76, (short) 0);
	   if (!isc_76.isc_84 || isc_status [1]) break;

		fb_utils::exact_name(/*RELC1.RDB$RELATION_NAME*/
				     isc_76.isc_81);
		fb_utils::exact_name(/*RELC2.RDB$RELATION_NAME*/
				     isc_76.isc_80);

		ISQL_get_index_segments (collist, sizeof(collist), /*RELC1.RDB$INDEX_NAME*/
								   isc_76.isc_79, true);

		isqlGlob.printf(NEWLINE);

		if (isqlGlob.db_SQL_dialect > SQL_DIALECT_V6_TRANSITION)
		{
			ISQL_copy_SQL_id (/*RELC1.RDB$RELATION_NAME*/
					  isc_76.isc_81, SQL_identifier, DBL_QUOTE);
			isqlGlob.printf("ALTER TABLE %s ADD ", SQL_identifier);
		}
		else
			isqlGlob.printf("ALTER TABLE %s ADD ", /*RELC1.RDB$RELATION_NAME*/
							       isc_76.isc_81);

		/* If the name of the constraint is not INTEG..., print it.
	      INTEG_... are internally generated names. */
		if (!/*RELC1.RDB$CONSTRAINT_NAME.NULL*/
		     isc_76.isc_87 &&
			!fb_utils::implicit_integrity(/*RELC1.RDB$CONSTRAINT_NAME*/
						      isc_76.isc_78))
		{
			ISQL_truncate_term (/*RELC1.RDB$CONSTRAINT_NAME*/
					    isc_76.isc_78, strlen(/*RELC1.RDB$CONSTRAINT_NAME*/
	 isc_76.isc_78));
			if (isqlGlob.db_SQL_dialect > SQL_DIALECT_V6_TRANSITION)
			{
				ISQL_copy_SQL_id (/*RELC1.RDB$CONSTRAINT_NAME*/
						  isc_76.isc_78, SQL_identifier, DBL_QUOTE);
				isqlGlob.printf("CONSTRAINT %s ", SQL_identifier);
			}
			else
				isqlGlob.printf("CONSTRAINT %s ", /*RELC1.RDB$CONSTRAINT_NAME*/
								  isc_76.isc_78);
		}

		if (isqlGlob.db_SQL_dialect > SQL_DIALECT_V6_TRANSITION)
		{
			ISQL_copy_SQL_id (/*RELC2.RDB$RELATION_NAME*/
					  isc_76.isc_80, SQL_identifier, DBL_QUOTE);
			isqlGlob.printf("FOREIGN KEY (%s) REFERENCES %s ", collist, SQL_identifier);
		}
		else
			isqlGlob.printf("FOREIGN KEY (%s) REFERENCES %s ", collist, /*RELC2.RDB$RELATION_NAME*/
										    isc_76.isc_80);

		// Get the column list for the primary key

		ISQL_get_index_segments (collist, sizeof(collist), /*RELC2.RDB$INDEX_NAME*/
								   isc_76.isc_77, true);

		isqlGlob.printf("(%s)", collist);

		// Add the referential actions, if any
		if (!/*REFC.RDB$UPDATE_RULE.NULL*/
		     isc_76.isc_86)
		{
			ISQL_truncate_term (/*REFC.RDB$UPDATE_RULE*/
					    isc_76.isc_83, strlen(/*REFC.RDB$UPDATE_RULE*/
	 isc_76.isc_83));
			ISQL_ri_action_print (/*REFC.RDB$UPDATE_RULE*/
					      isc_76.isc_83, " ON UPDATE", true);
		}

		if (!/*REFC.RDB$DELETE_RULE.NULL*/
		     isc_76.isc_85)
		{
			ISQL_truncate_term (/*REFC.RDB$DELETE_RULE*/
					    isc_76.isc_82, strlen(/*REFC.RDB$DELETE_RULE*/
	 isc_76.isc_82));
			ISQL_ri_action_print (/*REFC.RDB$DELETE_RULE*/
					      isc_76.isc_82, " ON DELETE", true);
		}

		isqlGlob.printf("%s%s", isqlGlob.global_Term, NEWLINE);

	/*END_FOR*/
	   }
	   };
	/*ON_ERROR*/
	if (isc_status [1])
	   {
		ISQL_errmsg(gds_status);
		return;
	/*END_ERROR;*/
	   }
	}
}


static void list_functions()
{
   struct isc_39_struct {
          short isc_40;	/* isc_utility */
          short isc_41;	/* RDB$FIELD_SCALE */
          short isc_42;	/* RDB$FIELD_SUB_TYPE */
          short isc_43;	/* gds__null_flag */
          short isc_44;	/* RDB$FIELD_PRECISION */
   } isc_39;
   struct isc_36_struct {
          char  isc_37 [32];	/* RDB$FUNCTION_NAME */
          short isc_38;	/* RDB$ARGUMENT_POSITION */
   } isc_36;
   struct isc_49_struct {
          char  isc_50 [32];	/* RDB$CHARACTER_SET_NAME */
          short isc_51;	/* isc_utility */
          short isc_52;	/* RDB$BYTES_PER_CHARACTER */
   } isc_49;
   struct isc_47_struct {
          short isc_48;	/* RDB$CHARACTER_SET_ID */
   } isc_47;
   struct isc_57_struct {
          char  isc_58 [32];	/* RDB$FUNCTION_NAME */
          short isc_59;	/* isc_utility */
          short isc_60;	/* RDB$MECHANISM */
          short isc_61;	/* RDB$FIELD_SCALE */
          short isc_62;	/* RDB$ARGUMENT_POSITION */
          short isc_63;	/* RDB$FIELD_LENGTH */
          short isc_64;	/* RDB$CHARACTER_SET_ID */
          short isc_65;	/* RDB$FIELD_TYPE */
   } isc_57;
   struct isc_55_struct {
          char  isc_56 [32];	/* RDB$FUNCTION_NAME */
   } isc_55;
   struct isc_68_struct {
          char  isc_69 [32];	/* RDB$ENTRYPOINT */
          char  isc_70 [256];	/* RDB$MODULE_NAME */
          char  isc_71 [32];	/* RDB$FUNCTION_NAME */
          short isc_72;	/* isc_utility */
          short isc_73;	/* RDB$RETURN_ARGUMENT */
   } isc_68;
/**************************************
 *
 *	l i s t _ f u n c t i o n s
 *
 **************************************
 *
 * Functional description
 *	List all external functions
 *
 *	Parameters:  none
 * Results in
 * DECLARE EXTERNAL FUNCTION function_name
 *               CHAR(256) , INTEGER, ....
 *               RETURNS INTEGER BY VALUE
 *               ENTRY_POINT entrypoint MODULE_NAME module;
 **************************************/
	char type_buffer[BUFFER_LENGTH128];
	char return_buffer[BUFFER_LENGTH128];

	bool first = true;

	/*FOR FUN IN RDB$FUNCTIONS
		WITH FUN.RDB$SYSTEM_FLAG NE 1 OR FUN.RDB$SYSTEM_FLAG MISSING
		SORTED BY FUN.RDB$FUNCTION_NAME*/
	{
        if (!isc_66)
           isc_compile_request2 (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &isc_66, (short) sizeof(isc_67), (char*) isc_67);
	if (isc_66)
	   {
           isc_start_request (isc_status, (FB_API_HANDLE*) &isc_66, (FB_API_HANDLE*) &gds_trans, (short) 0);
	   }
	if (!isc_status [1]) {
	while (1)
	   {
           isc_receive (isc_status, (FB_API_HANDLE*) &isc_66, (short) 0, (short) 324, &isc_68, (short) 0);
	   if (!isc_68.isc_72 || isc_status [1]) break;

		fb_utils::exact_name(/*FUN.RDB$FUNCTION_NAME*/
				     isc_68.isc_71);
		fb_utils::exact_name(/*FUN.RDB$MODULE_NAME*/
				     isc_68.isc_70);
		fb_utils::exact_name(/*FUN.RDB$ENTRYPOINT*/
				     isc_68.isc_69);
		if (first)
		{
			isqlGlob.printf("%s/*  External Function declarations */%s", NEWLINE, NEWLINE);
			first = false;
		}

		if (isqlGlob.db_SQL_dialect > SQL_DIALECT_V6_TRANSITION)
			ISQL_copy_SQL_id(/*FUN.RDB$FUNCTION_NAME*/
					 isc_68.isc_71, SQL_identifier, DBL_QUOTE);
		else
			strcpy(SQL_identifier, /*FUN.RDB$FUNCTION_NAME*/
					       isc_68.isc_71);

		// Start new function declaration
		isqlGlob.printf("DECLARE EXTERNAL FUNCTION %s%s", SQL_identifier, NEWLINE);

		bool firstarg = true;

		/*FOR FNA IN RDB$FUNCTION_ARGUMENTS WITH
			FUN.RDB$FUNCTION_NAME EQ FNA.RDB$FUNCTION_NAME
			SORTED BY FNA.RDB$ARGUMENT_POSITION*/
		{
                if (!isc_53)
                   isc_compile_request2 (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &isc_53, (short) sizeof(isc_54), (char*) isc_54);
		isc_vtov ((const char*) isc_68.isc_71, (char*) isc_55.isc_56, 32);
		if (isc_53)
		   {
                   isc_start_and_send (isc_status, (FB_API_HANDLE*) &isc_53, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 32, &isc_55, (short) 0);
		   }
		if (!isc_status [1]) {
		while (1)
		   {
                   isc_receive (isc_status, (FB_API_HANDLE*) &isc_53, (short) 1, (short) 46, &isc_57, (short) 0);
		   if (!isc_57.isc_59 || isc_status [1]) break;

			// Find parameter type
			int i = 0;
			while (/*FNA.RDB$FIELD_TYPE*/
			       isc_57.isc_65 != Column_types[i].type)
				i++;

			// Print length where appropriate
			if ((/*FNA.RDB$FIELD_TYPE*/
			     isc_57.isc_65 == T_CHAR) ||
				(/*FNA.RDB$FIELD_TYPE*/
				 isc_57.isc_65 == VARCHAR) ||
				(/*FNA.RDB$FIELD_TYPE*/
				 isc_57.isc_65 == CSTRING))
			{
				bool did_charset = false;
				/*FOR CHARSET IN RDB$CHARACTER_SETS
					WITH CHARSET.RDB$CHARACTER_SET_ID = FNA.RDB$CHARACTER_SET_ID*/
				{
                                if (!isc_45)
                                   isc_compile_request2 (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &isc_45, (short) sizeof(isc_46), (char*) isc_46);
				isc_47.isc_48 = isc_57.isc_64;
				if (isc_45)
				   {
                                   isc_start_and_send (isc_status, (FB_API_HANDLE*) &isc_45, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 2, &isc_47, (short) 0);
				   }
				if (!isc_status [1]) {
				while (1)
				   {
                                   isc_receive (isc_status, (FB_API_HANDLE*) &isc_45, (short) 1, (short) 36, &isc_49, (short) 0);
				   if (!isc_49.isc_51 || isc_status [1]) break;

					did_charset = true;
					fb_utils::exact_name(/*CHARSET.RDB$CHARACTER_SET_NAME*/
							     isc_49.isc_50);
					sprintf (type_buffer, "%s(%d) CHARACTER SET %s",
							 Column_types[i].type_name,
							 (/*FNA.RDB$FIELD_LENGTH*/
							  isc_57.isc_63 / MAX (1, /*CHARSET.RDB$BYTES_PER_CHARACTER*/
	   isc_49.isc_52)),
							 /*CHARSET.RDB$CHARACTER_SET_NAME*/
							 isc_49.isc_50);

				/*END_FOR*/
				   }
				   };
				/*ON_ERROR*/
				if (isc_status [1])
				   {
					ISQL_errmsg (gds_status);
					return;
				/*END_ERROR;*/
				   }
				}

				if (!did_charset)
					sprintf (type_buffer, "%s(%d)",  Column_types[i].type_name, /*FNA.RDB$FIELD_LENGTH*/
												    isc_57.isc_63);
			}
			else
			{
				bool precision_known = false;

				if ( (isqlGlob.major_ods >= ODS_VERSION10) &&
					((/*FNA.RDB$FIELD_TYPE*/
					  isc_57.isc_65 == SMALLINT) ||
					(/*FNA.RDB$FIELD_TYPE*/
					 isc_57.isc_65 == INTEGER) ||
					(/*FNA.RDB$FIELD_TYPE*/
					 isc_57.isc_65 == BIGINT)))
				{
					/*FOR FNA1 IN RDB$FUNCTION_ARGUMENTS WITH
						FNA1.RDB$FUNCTION_NAME EQ FNA.RDB$FUNCTION_NAME AND
						FNA1.RDB$ARGUMENT_POSITION EQ FNA.RDB$ARGUMENT_POSITION*/
					{
                                        if (!isc_34)
                                           isc_compile_request2 (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &isc_34, (short) sizeof(isc_35), (char*) isc_35);
					isc_vtov ((const char*) isc_57.isc_58, (char*) isc_36.isc_37, 32);
					isc_36.isc_38 = isc_57.isc_62;
					if (isc_34)
					   {
                                           isc_start_and_send (isc_status, (FB_API_HANDLE*) &isc_34, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 34, &isc_36, (short) 0);
					   }
					if (!isc_status [1]) {
					while (1)
					   {
                                           isc_receive (isc_status, (FB_API_HANDLE*) &isc_34, (short) 1, (short) 10, &isc_39, (short) 0);
					   if (!isc_39.isc_40 || isc_status [1]) break;

						/* We are ODS >= 10 and could be any Dialect */
						if (!/*FNA1.RDB$FIELD_PRECISION.NULL*/
						     isc_39.isc_43)
						{
							/* We are Dialect >=3 since FIELD_PRECISION is non-NULL */
							if (/*FNA1.RDB$FIELD_SUB_TYPE*/
							    isc_39.isc_42 > 0 &&
								/*FNA1.RDB$FIELD_SUB_TYPE*/
								isc_39.isc_42 <= MAX_INTSUBTYPES)
							{
								sprintf (type_buffer, "%s(%d, %d)",
										Integral_subtypes[/*FNA1.RDB$FIELD_SUB_TYPE*/
												  isc_39.isc_42],
										/*FNA1.RDB$FIELD_PRECISION*/
										isc_39.isc_44,
										-/*FNA1.RDB$FIELD_SCALE*/
										 isc_39.isc_41);
								precision_known = true;
							}
						} // if field_precision is not null
					/*END_FOR*/
					   }
					   };
					/*ON_ERROR*/
					if (isc_status [1])
					   {
						ISQL_errmsg (isc_status);
						return;
					/*END_ERROR;*/
					   }
					}
				} /* if isqlGlob.major_ods >= ods_version10 && */

				if (!precision_known)
				{
					// Take a stab at numerics and decimals
					if ((/*FNA.RDB$FIELD_TYPE*/
					     isc_57.isc_65 == SMALLINT) && (/*FNA.RDB$FIELD_SCALE*/
		  isc_57.isc_61 < 0))
					{
						sprintf (type_buffer, "NUMERIC(4, %d)", -/*FNA.RDB$FIELD_SCALE*/
											 isc_57.isc_61);
					}
					else if ((/*FNA.RDB$FIELD_TYPE*/
						  isc_57.isc_65 == INTEGER) && (/*FNA.RDB$FIELD_SCALE*/
		 isc_57.isc_61 < 0))
					{
						sprintf (type_buffer, "NUMERIC(9, %d)", -/*FNA.RDB$FIELD_SCALE*/
											 isc_57.isc_61);
					}
					else if ((/*FNA.RDB$FIELD_TYPE*/
						  isc_57.isc_65 == DOUBLE_PRECISION) && (/*FNA.RDB$FIELD_SCALE*/
			  isc_57.isc_61 < 0))
					{
						sprintf (type_buffer, "NUMERIC(15, %d)", -/*FNA.RDB$FIELD_SCALE*/
											  isc_57.isc_61);
					}
					else
						sprintf (type_buffer, "%s", Column_types[i].type_name);
				} // if !precision_known
			} // if T_CHAR or VARCHAR or CSTRING ... else

			// If a return argument, save it for the end, otherwise print

			/*
			 * Changed the following to not return a BLOB by value.
			 * To be sincere, this code doesn't cater for the RETURNS PARAMETER syntax but
			 * it would require more surgery than I'm willing to do, since I'm sick of isql
			 * so I started my own metadata extraction utility based on IBO that does this
			 * trick and others.
			 * Claudio Valderrama (by way of) MOD 23-Apr-2001

			 CVC: Finally enhanced the UDF metadata extraction.
			*/

			int ptype = (int) abs(/*FNA.RDB$MECHANISM*/
					      isc_57.isc_60);
			if (ptype > MAX_UDFPARAM_TYPES)
				ptype = MAX_UDFPARAM_TYPES;

			bool printarg = true;

			if (/*FUN.RDB$RETURN_ARGUMENT*/
			    isc_68.isc_73 == /*FNA.RDB$ARGUMENT_POSITION*/
    isc_57.isc_62)
			{
				if (/*FUN.RDB$RETURN_ARGUMENT*/
				    isc_68.isc_73) {
					sprintf (return_buffer, "RETURNS PARAMETER %d", /*FUN.RDB$RETURN_ARGUMENT*/
											isc_68.isc_73);
				}
				else
				{
					sprintf (return_buffer, "RETURNS %s%s %s", type_buffer,
							 UDF_param_types[ptype],
							 (/*FNA.RDB$MECHANISM*/
							  isc_57.isc_60 < 0 ? "FREE_IT" : ""));
					printarg = false;
				}

			}

			if (printarg)
			{
				// First arg needs no comma
				isqlGlob.printf("%s%s%s", (firstarg ? "" : ", "), type_buffer, UDF_param_types[ptype]);
				firstarg = false;
			}

		/*END_FOR*/
		   }
		   };
		/*ON_ERROR*/
		if (isc_status [1])
		   {
			ISQL_errmsg (gds_status);
			return;
		/*END_ERROR;*/
		   }
		}

		// Print the return type -- All functions return a type
		isqlGlob.printf("%s%s%s", NEWLINE, return_buffer, NEWLINE);

		// Print out entrypoint information
		ISQL_copy_SQL_id(/*FUN.RDB$ENTRYPOINT*/
				 isc_68.isc_69, SQL_identifier, SINGLE_QUOTE);
		ISQL_copy_SQL_id(/*FUN.RDB$MODULE_NAME*/
				 isc_68.isc_70, SQL_identifier2, SINGLE_QUOTE);

		isqlGlob.printf("ENTRY_POINT %s MODULE_NAME %s%s%s%s",
				 SQL_identifier,
				 SQL_identifier2,
				 isqlGlob.global_Term,
				 NEWLINE,
				 NEWLINE);

	/*END_FOR*/
	   }
	   };
	/*ON_ERROR*/
	if (isc_status [1])
	   {
		ISQL_errmsg(gds_status);
		return;
	/*END_ERROR;*/
	   }
	}
}




static void list_generators()
{
   struct isc_31_struct {
          char  isc_32 [32];	/* RDB$GENERATOR_NAME */
          short isc_33;	/* isc_utility */
   } isc_31;
/**************************************
 *
 *	l i s t _ g e n e r a t o r s
 *
 **************************************
 *
 * Functional description
 *	Re create all non-system generators
 *
 **************************************/

	bool first = true;

	/*FOR GEN IN RDB$GENERATORS WITH
		GEN.RDB$GENERATOR_NAME NOT MATCHING "RDB$+" USING "+=[0-9][0-9]* *" AND
		GEN.RDB$GENERATOR_NAME NOT MATCHING "SQL$+" USING "+=[0-9][0-9]* *" AND
		(GEN.RDB$SYSTEM_FLAG MISSING OR GEN.RDB$SYSTEM_FLAG NE 1)
		SORTED BY GEN.RDB$GENERATOR_NAME*/
	{
        if (!isc_29)
           isc_compile_request2 (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &isc_29, (short) sizeof(isc_30), (char*) isc_30);
	if (isc_29)
	   {
           isc_start_request (isc_status, (FB_API_HANDLE*) &isc_29, (FB_API_HANDLE*) &gds_trans, (short) 0);
	   }
	if (!isc_status [1]) {
	while (1)
	   {
           isc_receive (isc_status, (FB_API_HANDLE*) &isc_29, (short) 0, (short) 34, &isc_31, (short) 0);
	   if (!isc_31.isc_33 || isc_status [1]) break;

		if (first)
		{
			isqlGlob.printf("%s/*  Generators or sequences */%s", NEWLINE, NEWLINE);
			first = false;
		}

		fb_utils::exact_name(/*GEN.RDB$GENERATOR_NAME*/
				     isc_31.isc_32);

		if (isqlGlob.db_SQL_dialect > SQL_DIALECT_V6_TRANSITION)
			ISQL_copy_SQL_id (/*GEN.RDB$GENERATOR_NAME*/
					  isc_31.isc_32, SQL_identifier, DBL_QUOTE);
		else
			strcpy (SQL_identifier, /*GEN.RDB$GENERATOR_NAME*/
						isc_31.isc_32);

		isqlGlob.printf("CREATE GENERATOR %s%s%s", SQL_identifier, isqlGlob.global_Term, NEWLINE);
	/*END_FOR*/
	   }
	   };
	/*ON_ERROR*/
	if (isc_status [1])
	   {
		ISQL_errmsg(gds_status);
		return;
	/*END_ERROR;*/
	   }
	}

	isqlGlob.printf(NEWLINE);
}


static void list_index()
{
   struct isc_19_struct {
          ISC_QUAD isc_20;	/* RDB$EXPRESSION_SOURCE */
          ISC_QUAD isc_21;	/* RDB$EXPRESSION_BLR */
          char  isc_22 [32];	/* RDB$INDEX_NAME */
          char  isc_23 [32];	/* RDB$RELATION_NAME */
          short isc_24;	/* isc_utility */
          short isc_25;	/* gds__null_flag */
          short isc_26;	/* gds__null_flag */
          short isc_27;	/* RDB$INDEX_TYPE */
          short isc_28;	/* RDB$UNIQUE_FLAG */
   } isc_19;
/**************************************
 *
 *	l i s t _ i n d e x
 *
 **************************************
 *
 * Functional description
 *	Define all non-constraint indices
 *	Use a static SQL query to get the info and print it.
 *
 *	Uses get_index_segment to provide a key list for each index
 *
 **************************************/
	char collist[BUFFER_LENGTH512 * 2];

	bool first = true;

	/*FOR IDX IN RDB$INDICES CROSS RELC IN RDB$RELATIONS
		OVER RDB$RELATION_NAME
		WITH (RELC.RDB$SYSTEM_FLAG NE 1 OR RELC.RDB$SYSTEM_FLAG MISSING)
		AND NOT (ANY RC IN RDB$RELATION_CONSTRAINTS
				WITH RC.RDB$INDEX_NAME EQ IDX.RDB$INDEX_NAME)
		SORTED BY IDX.RDB$RELATION_NAME, IDX.RDB$INDEX_NAME*/
	{
        if (!isc_17)
           isc_compile_request2 (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &isc_17, (short) sizeof(isc_18), (char*) isc_18);
	if (isc_17)
	   {
           isc_start_request (isc_status, (FB_API_HANDLE*) &isc_17, (FB_API_HANDLE*) &gds_trans, (short) 0);
	   }
	if (!isc_status [1]) {
	while (1)
	   {
           isc_receive (isc_status, (FB_API_HANDLE*) &isc_17, (short) 0, (short) 90, &isc_19, (short) 0);
	   if (!isc_19.isc_24 || isc_status [1]) break;

		if (first)
		{
			isqlGlob.printf("%s/*  Index definitions for all user tables */%s", NEWLINE, NEWLINE);
			first = false;
		}

		// Strip trailing blanks
		fb_utils::exact_name(/*IDX.RDB$RELATION_NAME*/
				     isc_19.isc_23);
		fb_utils::exact_name(/*IDX.RDB$INDEX_NAME*/
				     isc_19.isc_22);

		if (isqlGlob.db_SQL_dialect > SQL_DIALECT_V6_TRANSITION)
		{
			ISQL_copy_SQL_id (/*IDX.RDB$INDEX_NAME*/
					  isc_19.isc_22,    SQL_identifier,  DBL_QUOTE);
			ISQL_copy_SQL_id (/*IDX.RDB$RELATION_NAME*/
					  isc_19.isc_23, SQL_identifier2, DBL_QUOTE);
			isqlGlob.printf("CREATE%s%s INDEX %s ON %s",
					(/*IDX.RDB$UNIQUE_FLAG*/
					 isc_19.isc_28 ? " UNIQUE" : ""),
					(/*IDX.RDB$INDEX_TYPE*/
					 isc_19.isc_27 ? " DESCENDING" : ""),
					SQL_identifier,
					SQL_identifier2);
		}
		else
			isqlGlob.printf("CREATE%s%s INDEX %s ON %s",
					(/*IDX.RDB$UNIQUE_FLAG*/
					 isc_19.isc_28 ? " UNIQUE" : ""),
					(/*IDX.RDB$INDEX_TYPE*/
					 isc_19.isc_27 ? " DESCENDING" : ""),
					/*IDX.RDB$INDEX_NAME*/
					isc_19.isc_22,
					/*IDX.RDB$RELATION_NAME*/
					isc_19.isc_23);

		// Get index expression or column names

		if (!/*IDX.RDB$EXPRESSION_BLR.NULL*/
		     isc_19.isc_26)
		{
			isqlGlob.printf(" COMPUTED BY ");
			if (!/*IDX.RDB$EXPRESSION_SOURCE.NULL*/
			     isc_19.isc_25)
				SHOW_print_metadata_text_blob (isqlGlob.Out, &/*IDX.RDB$EXPRESSION_SOURCE*/
									      isc_19.isc_20);
			isqlGlob.printf("%s%s", isqlGlob.global_Term, NEWLINE);
		}
		else if (ISQL_get_index_segments (collist, sizeof(collist), /*IDX.RDB$INDEX_NAME*/
									    isc_19.isc_22, true))
		{
			isqlGlob.printf(" (%s)%s%s", collist, isqlGlob.global_Term, NEWLINE);
		}

	/*END_FOR*/
	   }
	   };
	/*ON_ERROR*/
	if (isc_status [1])
	   {
		ISQL_errmsg(gds_status);
		return;
	/*END_ERROR;*/
	   }
	}
}


static void list_views()
{
   struct isc_4_struct {
          char  isc_5 [32];	/* RDB$FIELD_NAME */
          short isc_6;	/* isc_utility */
   } isc_4;
   struct isc_2_struct {
          char  isc_3 [32];	/* RDB$RELATION_NAME */
   } isc_2;
   struct isc_11_struct {
          ISC_QUAD isc_12;	/* RDB$VIEW_SOURCE */
          char  isc_13 [32];	/* RDB$OWNER_NAME */
          char  isc_14 [32];	/* RDB$RELATION_NAME */
          short isc_15;	/* isc_utility */
          short isc_16;	/* gds__null_flag */
   } isc_11;
   struct isc_9_struct {
          short isc_10;	/* RDB$FLAGS */
   } isc_9;
/**************************************
 *
 *	l i s t _ v i e w s
 *
 **************************************
 *
 * Functional description
 *	Show text of views.
 *	Use a SQL query to get the info and print it.
 *	Note: This should also contain check option
 *
 **************************************/

// If this is a view, use print_blob to print the view text

	/*FOR REL IN RDB$RELATIONS WITH
		(REL.RDB$SYSTEM_FLAG NE 1 OR REL.RDB$SYSTEM_FLAG MISSING) AND
		REL.RDB$VIEW_BLR NOT MISSING AND
		REL.RDB$FLAGS = REL_sql
		SORTED BY REL.RDB$RELATION_ID*/
	{
        if (!isc_7)
           isc_compile_request2 (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &isc_7, (short) sizeof(isc_8), (char*) isc_8);
	isc_9.isc_10 = REL_sql;
	if (isc_7)
	   {
           isc_start_and_send (isc_status, (FB_API_HANDLE*) &isc_7, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 2, &isc_9, (short) 0);
	   }
	if (!isc_status [1]) {
	while (1)
	   {
           isc_receive (isc_status, (FB_API_HANDLE*) &isc_7, (short) 1, (short) 76, &isc_11, (short) 0);
	   if (!isc_11.isc_15 || isc_status [1]) break;

		bool first = true;
		fb_utils::exact_name(/*REL.RDB$RELATION_NAME*/
				     isc_11.isc_14);

		if (isqlGlob.db_SQL_dialect > SQL_DIALECT_V6_TRANSITION)
			ISQL_copy_SQL_id (/*REL.RDB$RELATION_NAME*/
					  isc_11.isc_14, SQL_identifier, DBL_QUOTE);
		else
			strcpy (SQL_identifier, /*REL.RDB$RELATION_NAME*/
						isc_11.isc_14);

		fb_utils::exact_name(/*REL.RDB$OWNER_NAME*/
				     isc_11.isc_13);

		isqlGlob.printf("%s/* View: %s, Owner: %s */%s",
				 NEWLINE,
				 /*REL.RDB$RELATION_NAME*/
				 isc_11.isc_14,
				 /*REL.RDB$OWNER_NAME*/
				 isc_11.isc_13,
				 NEWLINE);
		isqlGlob.printf("CREATE VIEW %s (", SQL_identifier);

		// Get column list
		/*FOR RFR IN RDB$RELATION_FIELDS WITH
			RFR.RDB$RELATION_NAME = REL.RDB$RELATION_NAME
			SORTED BY RFR.RDB$FIELD_POSITION*/
		{
                if (!isc_0)
                   isc_compile_request2 (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &isc_0, (short) sizeof(isc_1), (char*) isc_1);
		isc_vtov ((const char*) isc_11.isc_14, (char*) isc_2.isc_3, 32);
		if (isc_0)
		   {
                   isc_start_and_send (isc_status, (FB_API_HANDLE*) &isc_0, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 32, &isc_2, (short) 0);
		   }
		if (!isc_status [1]) {
		while (1)
		   {
                   isc_receive (isc_status, (FB_API_HANDLE*) &isc_0, (short) 1, (short) 34, &isc_4, (short) 0);
		   if (!isc_4.isc_6 || isc_status [1]) break;

			fb_utils::exact_name(/*RFR.RDB$FIELD_NAME*/
					     isc_4.isc_5);

			if (isqlGlob.db_SQL_dialect > SQL_DIALECT_V6_TRANSITION)
				ISQL_copy_SQL_id (/*RFR.RDB$FIELD_NAME*/
						  isc_4.isc_5, SQL_identifier, DBL_QUOTE);
			else
				strcpy (SQL_identifier, /*RFR.RDB$FIELD_NAME*/
							isc_4.isc_5);

			isqlGlob.printf("%s%s", (first ? "" : ", "), SQL_identifier);
			first = false;

		/*END_FOR*/
		   }
		   };
		/*ON_ERROR*/
		if (isc_status [1])
		   {
			ISQL_errmsg (gds_status);
			return;
		/*END_ERROR;*/
		   }
		}
		isqlGlob.printf(") AS%s", NEWLINE);

		if (!/*REL.RDB$VIEW_SOURCE.NULL*/
		     isc_11.isc_16)
			SHOW_print_metadata_text_blob (isqlGlob.Out, &/*REL.RDB$VIEW_SOURCE*/
								      isc_11.isc_12);

		isqlGlob.printf("%s%s", isqlGlob.global_Term, NEWLINE);

	/*END_FOR*/
	   }
	   };
	/*ON_ERROR*/
	if (isc_status [1])
	   {
		ISQL_errmsg(gds_status);
		return;
	/*END_ERROR;*/
	   }
	}
}
