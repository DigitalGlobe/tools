/*
 * Please do not edit this file.
 * It was generated using rpcgen.
 */

#include "ecs.h"

bool_t
xdr_ecs_Family(xdrs, objp)
	register XDR *xdrs;
	ecs_Family *objp;
{

	register long *buf;

	if (!xdr_enum(xdrs, (enum_t *)objp))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_ecs_Region(xdrs, objp)
	register XDR *xdrs;
	ecs_Region *objp;
{

	register long *buf;

	if (!xdr_double(xdrs, &objp->north))
		return (FALSE);
	if (!xdr_double(xdrs, &objp->south))
		return (FALSE);
	if (!xdr_double(xdrs, &objp->east))
		return (FALSE);
	if (!xdr_double(xdrs, &objp->west))
		return (FALSE);
	if (!xdr_double(xdrs, &objp->ns_res))
		return (FALSE);
	if (!xdr_double(xdrs, &objp->ew_res))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_ecs_Resampling(xdrs, objp)
	register XDR *xdrs;
	ecs_Resampling *objp;
{

	register long *buf;

	if (!xdr_enum(xdrs, (enum_t *)objp))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_ecs_Transformation(xdrs, objp)
	register XDR *xdrs;
	ecs_Transformation *objp;
{

	register long *buf;

	if (!xdr_enum(xdrs, (enum_t *)objp))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_ecs_RasterConversion(xdrs, objp)
	register XDR *xdrs;
	ecs_RasterConversion *objp;
{

	register long *buf;

	if (!xdr_array(xdrs, (char **)&objp->coef.coef_val, (u_int *) &objp->coef.coef_len, ~0,
		sizeof (double), (xdrproc_t) xdr_double))
		return (FALSE);
	if (!xdr_int(xdrs, &objp->isProjEqual))
		return (FALSE);
	if (!xdr_ecs_Resampling(xdrs, &objp->r_method))
		return (FALSE);
	if (!xdr_ecs_Transformation(xdrs, &objp->t_method))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_ecs_Coordinate(xdrs, objp)
	register XDR *xdrs;
	ecs_Coordinate *objp;
{

	register long *buf;

	if (!xdr_double(xdrs, &objp->x))
		return (FALSE);
	if (!xdr_double(xdrs, &objp->y))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_ecs_FeatureRing(xdrs, objp)
	register XDR *xdrs;
	ecs_FeatureRing *objp;
{

	register long *buf;

	if (!xdr_ecs_Coordinate(xdrs, &objp->centroid))
		return (FALSE);
	if (!xdr_array(xdrs, (char **)&objp->c.c_val, (u_int *) &objp->c.c_len, ~0,
		sizeof (ecs_Coordinate), (xdrproc_t) xdr_ecs_Coordinate))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_ecs_Area(xdrs, objp)
	register XDR *xdrs;
	ecs_Area *objp;
{

	register long *buf;

	if (!xdr_array(xdrs, (char **)&objp->ring.ring_val, (u_int *) &objp->ring.ring_len, ~0,
		sizeof (ecs_FeatureRing), (xdrproc_t) xdr_ecs_FeatureRing))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_ecs_Line(xdrs, objp)
	register XDR *xdrs;
	ecs_Line *objp;
{

	register long *buf;

	if (!xdr_array(xdrs, (char **)&objp->c.c_val, (u_int *) &objp->c.c_len, ~0,
		sizeof (ecs_Coordinate), (xdrproc_t) xdr_ecs_Coordinate))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_ecs_Point(xdrs, objp)
	register XDR *xdrs;
	ecs_Point *objp;
{

	register long *buf;

	if (!xdr_ecs_Coordinate(xdrs, &objp->c))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_ecs_Matrix(xdrs, objp)
	register XDR *xdrs;
	ecs_Matrix *objp;
{

	register long *buf;

	if (!xdr_array(xdrs, (char **)&objp->x.x_val, (u_int *) &objp->x.x_len, ~0,
		sizeof (u_int), (xdrproc_t) xdr_u_int))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_ecs_Image(xdrs, objp)
	register XDR *xdrs;
	ecs_Image *objp;
{

	register long *buf;

	if (!xdr_array(xdrs, (char **)&objp->x.x_val, (u_int *) &objp->x.x_len, ~0,
		sizeof (u_int), (xdrproc_t) xdr_u_int))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_ecs_Text(xdrs, objp)
	register XDR *xdrs;
	ecs_Text *objp;
{

	register long *buf;

	if (!xdr_string(xdrs, &objp->desc, ~0))
		return (FALSE);
	if (!xdr_ecs_Coordinate(xdrs, &objp->c))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_ecs_Node(xdrs, objp)
	register XDR *xdrs;
	ecs_Node *objp;
{

	register long *buf;

	if (!xdr_int(xdrs, &objp->id))
		return (FALSE);
	if (!xdr_int(xdrs, &objp->containfaceid))
		return (FALSE);
	if (!xdr_ecs_Coordinate(xdrs, &objp->c))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_ecs_Edge(xdrs, objp)
	register XDR *xdrs;
	ecs_Edge *objp;
{

	register long *buf;


	if (xdrs->x_op == XDR_ENCODE) {
		buf = XDR_INLINE(xdrs, 7 * BYTES_PER_XDR_UNIT);
		if (buf == NULL) {
			if (!xdr_int(xdrs, &objp->id))
				return (FALSE);
			if (!xdr_int(xdrs, &objp->startnodeid))
				return (FALSE);
			if (!xdr_int(xdrs, &objp->endnodeid))
				return (FALSE);
			if (!xdr_int(xdrs, &objp->rightfaceid))
				return (FALSE);
			if (!xdr_int(xdrs, &objp->leftfaceid))
				return (FALSE);
			if (!xdr_int(xdrs, &objp->rightfedgeid))
				return (FALSE);
			if (!xdr_int(xdrs, &objp->leftfedgeid))
				return (FALSE);

		} else {
			IXDR_PUT_LONG(buf, objp->id);
			IXDR_PUT_LONG(buf, objp->startnodeid);
			IXDR_PUT_LONG(buf, objp->endnodeid);
			IXDR_PUT_LONG(buf, objp->rightfaceid);
			IXDR_PUT_LONG(buf, objp->leftfaceid);
			IXDR_PUT_LONG(buf, objp->rightfedgeid);
			IXDR_PUT_LONG(buf, objp->leftfedgeid);
		}
		if (!xdr_array(xdrs, (char **)&objp->c.c_val, (u_int *) &objp->c.c_len, ~0,
			sizeof (ecs_Coordinate), (xdrproc_t) xdr_ecs_Coordinate))
			return (FALSE);
		return (TRUE);
	} else if (xdrs->x_op == XDR_DECODE) {
		buf = XDR_INLINE(xdrs, 7 * BYTES_PER_XDR_UNIT);
		if (buf == NULL) {
			if (!xdr_int(xdrs, &objp->id))
				return (FALSE);
			if (!xdr_int(xdrs, &objp->startnodeid))
				return (FALSE);
			if (!xdr_int(xdrs, &objp->endnodeid))
				return (FALSE);
			if (!xdr_int(xdrs, &objp->rightfaceid))
				return (FALSE);
			if (!xdr_int(xdrs, &objp->leftfaceid))
				return (FALSE);
			if (!xdr_int(xdrs, &objp->rightfedgeid))
				return (FALSE);
			if (!xdr_int(xdrs, &objp->leftfedgeid))
				return (FALSE);

		} else {
			objp->id = IXDR_GET_LONG(buf);
			objp->startnodeid = IXDR_GET_LONG(buf);
			objp->endnodeid = IXDR_GET_LONG(buf);
			objp->rightfaceid = IXDR_GET_LONG(buf);
			objp->leftfaceid = IXDR_GET_LONG(buf);
			objp->rightfedgeid = IXDR_GET_LONG(buf);
			objp->leftfedgeid = IXDR_GET_LONG(buf);
		}
		if (!xdr_array(xdrs, (char **)&objp->c.c_val, (u_int *) &objp->c.c_len, ~0,
			sizeof (ecs_Coordinate), (xdrproc_t) xdr_ecs_Coordinate))
			return (FALSE);
		return (TRUE);
	}

	if (!xdr_int(xdrs, &objp->id))
		return (FALSE);
	if (!xdr_int(xdrs, &objp->startnodeid))
		return (FALSE);
	if (!xdr_int(xdrs, &objp->endnodeid))
		return (FALSE);
	if (!xdr_int(xdrs, &objp->rightfaceid))
		return (FALSE);
	if (!xdr_int(xdrs, &objp->leftfaceid))
		return (FALSE);
	if (!xdr_int(xdrs, &objp->rightfedgeid))
		return (FALSE);
	if (!xdr_int(xdrs, &objp->leftfedgeid))
		return (FALSE);
	if (!xdr_array(xdrs, (char **)&objp->c.c_val, (u_int *) &objp->c.c_len, ~0,
		sizeof (ecs_Coordinate), (xdrproc_t) xdr_ecs_Coordinate))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_ecs_TopoLevel(xdrs, objp)
	register XDR *xdrs;
	ecs_TopoLevel *objp;
{

	register long *buf;

	if (!xdr_enum(xdrs, (enum_t *)objp))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_ecs_Face(xdrs, objp)
	register XDR *xdrs;
	ecs_Face *objp;
{

	register long *buf;

	if (!xdr_int(xdrs, &objp->id))
		return (FALSE);
	if (!xdr_array(xdrs, (char **)&objp->edgeid.edgeid_val, (u_int *) &objp->edgeid.edgeid_len, ~0,
		sizeof (int), (xdrproc_t) xdr_int))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_ecs_AreaPrim(xdrs, objp)
	register XDR *xdrs;
	ecs_AreaPrim *objp;
{

	register long *buf;

	if (!xdr_ecs_TopoLevel(xdrs, &objp->level))
		return (FALSE);
	switch (objp->level) {
	case Level012:
		if (!xdr_array(xdrs, (char **)&objp->ecs_AreaPrim_u.edgeid.edgeid_val, (u_int *) &objp->ecs_AreaPrim_u.edgeid.edgeid_len, ~0,
			sizeof (int), (xdrproc_t) xdr_int))
			return (FALSE);
		break;
	case Level3:
		if (!xdr_array(xdrs, (char **)&objp->ecs_AreaPrim_u.fedgeid.fedgeid_val, (u_int *) &objp->ecs_AreaPrim_u.fedgeid.fedgeid_len, ~0,
			sizeof (ecs_Face), (xdrproc_t) xdr_ecs_Face))
			return (FALSE);
		break;
	}
	return (TRUE);
}

bool_t
xdr_ecs_Geometry(xdrs, objp)
	register XDR *xdrs;
	ecs_Geometry *objp;
{

	register long *buf;

	if (!xdr_ecs_Family(xdrs, &objp->family))
		return (FALSE);
	switch (objp->family) {
	case Area:
		if (!xdr_ecs_Area(xdrs, &objp->ecs_Geometry_u.area))
			return (FALSE);
		break;
	case Line:
		if (!xdr_ecs_Line(xdrs, &objp->ecs_Geometry_u.line))
			return (FALSE);
		break;
	case Point:
		if (!xdr_ecs_Point(xdrs, &objp->ecs_Geometry_u.point))
			return (FALSE);
		break;
	case Matrix:
		if (!xdr_ecs_Matrix(xdrs, &objp->ecs_Geometry_u.matrix))
			return (FALSE);
		break;
	case Image:
		if (!xdr_ecs_Image(xdrs, &objp->ecs_Geometry_u.image))
			return (FALSE);
		break;
	case Text:
		if (!xdr_ecs_Text(xdrs, &objp->ecs_Geometry_u.text))
			return (FALSE);
		break;
	case Node:
		if (!xdr_ecs_Node(xdrs, &objp->ecs_Geometry_u.node))
			return (FALSE);
		break;
	case Edge:
		if (!xdr_ecs_Edge(xdrs, &objp->ecs_Geometry_u.edge))
			return (FALSE);
		break;
	case Ring:
		if (!xdr_ecs_AreaPrim(xdrs, &objp->ecs_Geometry_u.ring))
			return (FALSE);
		break;
	}
	return (TRUE);
}

bool_t
xdr_ecs_Object(xdrs, objp)
	register XDR *xdrs;
	ecs_Object *objp;
{

	register long *buf;

	if (!xdr_string(xdrs, &objp->Id, ~0))
		return (FALSE);
	if (!xdr_ecs_Geometry(xdrs, &objp->geom))
		return (FALSE);
	if (!xdr_string(xdrs, &objp->attr, ~0))
		return (FALSE);
	if (!xdr_double(xdrs, &objp->xmin))
		return (FALSE);
	if (!xdr_double(xdrs, &objp->ymin))
		return (FALSE);
	if (!xdr_double(xdrs, &objp->xmax))
		return (FALSE);
	if (!xdr_double(xdrs, &objp->ymax))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_ecs_AttributeFormat(xdrs, objp)
	register XDR *xdrs;
	ecs_AttributeFormat *objp;
{

	register long *buf;

	if (!xdr_enum(xdrs, (enum_t *)objp))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_ecs_ObjAttribute(xdrs, objp)
	register XDR *xdrs;
	ecs_ObjAttribute *objp;
{

	register long *buf;

	if (!xdr_string(xdrs, &objp->name, ~0))
		return (FALSE);
	if (!xdr_ecs_AttributeFormat(xdrs, &objp->type))
		return (FALSE);
	if (!xdr_int(xdrs, &objp->lenght))
		return (FALSE);
	if (!xdr_int(xdrs, &objp->precision))
		return (FALSE);
	if (!xdr_int(xdrs, &objp->nullable))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_ecs_ObjAttributeFormat(xdrs, objp)
	register XDR *xdrs;
	ecs_ObjAttributeFormat *objp;
{

	register long *buf;

	if (!xdr_array(xdrs, (char **)&objp->oa.oa_val, (u_int *) &objp->oa.oa_len, ~0,
		sizeof (ecs_ObjAttribute), (xdrproc_t) xdr_ecs_ObjAttribute))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_ecs_Category(xdrs, objp)
	register XDR *xdrs;
	ecs_Category *objp;
{

	register long *buf;

	if (!xdr_long(xdrs, &objp->no_cat))
		return (FALSE);
	if (!xdr_u_int(xdrs, &objp->r))
		return (FALSE);
	if (!xdr_u_int(xdrs, &objp->g))
		return (FALSE);
	if (!xdr_u_int(xdrs, &objp->b))
		return (FALSE);
	if (!xdr_string(xdrs, &objp->label, ~0))
		return (FALSE);
	if (!xdr_u_long(xdrs, &objp->qty))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_ecs_RasterInfo(xdrs, objp)
	register XDR *xdrs;
	ecs_RasterInfo *objp;
{

	register long *buf;

	if (!xdr_long(xdrs, &objp->mincat))
		return (FALSE);
	if (!xdr_long(xdrs, &objp->maxcat))
		return (FALSE);
	if (!xdr_int(xdrs, &objp->width))
		return (FALSE);
	if (!xdr_int(xdrs, &objp->height))
		return (FALSE);
	if (!xdr_array(xdrs, (char **)&objp->cat.cat_val, (u_int *) &objp->cat.cat_len, ~0,
		sizeof (ecs_Category), (xdrproc_t) xdr_ecs_Category))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_ecs_ResultType(xdrs, objp)
	register XDR *xdrs;
	ecs_ResultType *objp;
{

	register long *buf;

	if (!xdr_enum(xdrs, (enum_t *)objp))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_ecs_ResultUnion(xdrs, objp)
	register XDR *xdrs;
	ecs_ResultUnion *objp;
{

	register long *buf;

	if (!xdr_ecs_ResultType(xdrs, &objp->type))
		return (FALSE);
	switch (objp->type) {
	case Object:
		if (!xdr_ecs_Object(xdrs, &objp->ecs_ResultUnion_u.dob))
			return (FALSE);
		break;
	case GeoRegion:
		if (!xdr_ecs_Region(xdrs, &objp->ecs_ResultUnion_u.gr))
			return (FALSE);
		break;
	case objAttributeFormat:
		if (!xdr_ecs_ObjAttributeFormat(xdrs, &objp->ecs_ResultUnion_u.oaf))
			return (FALSE);
		break;
	case RasterInfo:
		if (!xdr_ecs_RasterInfo(xdrs, &objp->ecs_ResultUnion_u.ri))
			return (FALSE);
		break;
	case AText:
		if (!xdr_string(xdrs, &objp->ecs_ResultUnion_u.s, ~0))
			return (FALSE);
		break;
	}
	return (TRUE);
}

bool_t
xdr_ecs_Result(xdrs, objp)
	register XDR *xdrs;
	ecs_Result *objp;
{

	register long *buf;

	if (!xdr_int(xdrs, &objp->error))
		return (FALSE);
	if (!xdr_string(xdrs, &objp->message, ~0))
		return (FALSE);
	if (!xdr_ecs_ResultUnion(xdrs, &objp->res))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_ecs_LayerSelection(xdrs, objp)
	register XDR *xdrs;
	ecs_LayerSelection *objp;
{

	register long *buf;

	if (!xdr_string(xdrs, &objp->Select, ~0))
		return (FALSE);
	if (!xdr_ecs_Family(xdrs, &objp->F))
		return (FALSE);
	return (TRUE);
}
